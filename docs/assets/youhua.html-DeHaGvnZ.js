import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as p,c,b as n,e as a,f as i,d as s}from"./app-D8HBJYTp.js";const l={},r=s(`<h2 id="使用dbcontext池" tabindex="-1"><a class="header-anchor" href="#使用dbcontext池"><span>使用DbContext池</span></a></h2><p>在Core Mvc中,如果使用 AddDbContextPool 方法，那么在控制器请求 DbContext 实例时，我们会首先检查池中有无可用的实例。 请求处理完成后，实例的任何状态都将被重置，并且实例本身会返回池中。 从概念上讲，此方法类似于 ADO.NET 连接池的运行原理，并具有节约 DbContext 实例初始化成本的优势。 poolSize 参数 AddDbContextPool 设置池保留的最大实例数 中128。 一旦 poolSize 超出，就不会缓存新的上下文实例，EF 会回退到按需创建实例的非池行为。</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code>services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddDbContextPool</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>BloggingContext<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span> options <span class="token operator">=&gt;</span> options<span class="token punctuation">.</span><span class="token function">UseSqlServer</span><span class="token punctuation">(</span>connectionString<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,3),u={href:"https://masuit.org/2049?t=uhwxjhl4ecqo",target:"_blank",rel:"noopener noreferrer"},d=s(`<h2 id="连接池原理" tabindex="-1"><a class="header-anchor" href="#连接池原理"><span>连接池原理</span></a></h2><p>概念：连接到数据源可能需要很长时间。 为了最大程度地降低打开连接的成本，ADO.NET 使用一种称为连接池的优化技术，这会最大程度地降低重复打开和关闭连接的成本。 A. 当一个程序执行Connection.open()时候，ADO.Net就需要判断，此连接是否支持Connection Pool (Pooling 默认为True) 　①：如果指定为False, ADO.Net就与数据库之间创建一个连接，然后返回给程序。 　②：如果指定为 True，ADO.Net就会根据ConnectString创建一个Connection Pool，然后向Connection Pool中填充Connection。填充多少个Connection由Min Pool Size (默认为0)属性来决定。例如如果指定为5，则ADO.Net会一次与SQL数据库之间打开5个连接，然后将4个Connection，保存在 Connection Pool中，1个Connection返回给程序。 B. 当程序执行到Connection.close() 的时候。如果Pooling 为True，ADO.net 就把当前的Connection放到Connection Pool并且保持与数据库之间的连接。 同时还会判断Connection Lifetime(默认为0)属性，0代表无限大，如果Connection存在的时间超过了Connection LifeTime，ADO.net就会关闭的Connection同时断开与数据库的连接，而不是重新保存到Connection Pool中。 C. 当下一次Connection.Open() 执行的时候，ADO.Net就会判断新的ConnectionString与之前保存在Connection Pool中的Connection的connectionString是否一致。 D. ADO.Net需要判断当前的Connection Pool中是否有可以使用的Connection(没有被其他程序所占用)，如果没有的话，ADO.Net就需要判断ConnectionString设 置的Max Pool Size （默认为100） 　①. 如果Connection Pool中的所有Connection没有达到Max Pool Size，ADO.net则会再次连接数据库，创建一个连接，然后将Connection返回给程序。 　②. 如果已经达到了 Max Pool Size，ADO.Net就不会再次创建任何新的连接，而是等待Connection Pool中被其他程序所占用的Connection释放，这个等待时间受SqlConnection.ConnectionTimeout（默认是15 秒）限制，也就是说如果时间超过了15秒，SqlConnection就会抛出超时错误。 E. 如果有可用的Connection，从Connection Pool 取出的Connection也不是直接就返回给程序，ADO.Net还需要检查ConnectionString的ConnectionReset属性 (默认为True)是否需要对Connection 做一次reset。</p><h2 id="批处理" tabindex="-1"><a class="header-anchor" href="#批处理"><span>批处理</span></a></h2><p>当操作数量大于等于3条时候，会进行批处理(将添加的sql合成一个)，可以手动设置批处理的条数MaxBatchSize，默认值很大。</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code>optionsBuilder<span class="token punctuation">.</span><span class="token function">UseSqlServer</span><span class="token punctuation">(</span><span class="token string">&quot;Server=localhost;Database=EFDB01;User ID=sa;Password=123456;&quot;</span><span class="token punctuation">,</span> b <span class="token operator">=&gt;</span> b<span class="token punctuation">.</span><span class="token function">MaxBatchSize</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="关闭状态追踪" tabindex="-1"><a class="header-anchor" href="#关闭状态追踪"><span>关闭状态追踪</span></a></h2><p>当决定只查询数据，不更改数据时候，应当使用非追踪模式，非追踪查询执行更快</p><ul><li>单体查询关闭：AsNoTracking()</li><li>整个上下文关闭 <ul><li>context.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;</li><li>开启：context.ChangeTracker.DetectChanges();</li></ul></li></ul><p>非跟踪添加</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code>_dataContext<span class="token punctuation">.</span><span class="token function">Entry</span><span class="token punctuation">(</span>region<span class="token punctuation">)</span><span class="token punctuation">.</span>State <span class="token operator">=</span> EntityState<span class="token punctuation">.</span>Added<span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">int</span></span> res <span class="token operator">=</span> <span class="token keyword">await</span> _dataContext<span class="token punctuation">.</span><span class="token function">SaveChangesAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>非跟踪修改</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code>_dataContext<span class="token punctuation">.</span><span class="token function">Entry</span><span class="token punctuation">(</span>region<span class="token punctuation">)</span><span class="token punctuation">.</span>State <span class="token operator">=</span> EntityState<span class="token punctuation">.</span>Modified<span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">int</span></span> res <span class="token operator">=</span> <span class="token keyword">await</span> _dataContext<span class="token punctuation">.</span><span class="token function">SaveChangesAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>非跟踪删除</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code>_dataContext<span class="token punctuation">.</span><span class="token function">Entry</span><span class="token punctuation">(</span>region<span class="token punctuation">)</span><span class="token punctuation">.</span>State <span class="token operator">=</span> EntityState<span class="token punctuation">.</span>Deleted<span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">int</span></span> res <span class="token operator">=</span> <span class="token keyword">await</span> _dataContext<span class="token punctuation">.</span><span class="token function">SaveChangesAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="包含关系" tabindex="-1"><a class="header-anchor" href="#包含关系"><span>包含关系</span></a></h2><p>比如现在已知一堆用户名称p1,p2,p3,p4,x2,y4，现在需要这几个用户的信息 正确的做法是：将字符串转换成list，然后再使用contains</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">string</span></span> str <span class="token operator">=</span> <span class="token string">&quot;p1,p2,p3,p4,x2,y4&quot;</span><span class="token punctuation">;</span>
 <span class="token class-name"><span class="token keyword">var</span></span> strList <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span><span class="token char">&#39;,&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token class-name"><span class="token keyword">var</span></span> data5 <span class="token operator">=</span> dbContext<span class="token punctuation">.</span>T_UserInfor<span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>u <span class="token operator">=&gt;</span> strList<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>userName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="find查询" tabindex="-1"><a class="header-anchor" href="#find查询"><span>Find查询</span></a></h2><p>多使用Find()方法，建议在查询的时候使用Find()方法，会有限走内存缓存，如果内存已经存在，就不会去数据库中去查询数据；</p><h2 id="ef-compileasyncquery" tabindex="-1"><a class="header-anchor" href="#ef-compileasyncquery"><span>EF.CompileAsyncQuery</span></a></h2><p>EF.CompileAsyncQuery是EF Core的一个扩展方法，它可以将LINQ表达式编译为一个异步查询。相比于动态生成LINQ查询，使用EF.CompileAsyncQuery可以提高查询性能，减少不必要的内存分配。</p><p>编译后的查询可以多次调用，而不必每次动态生成查询表达式。这样可以避免不必要的内存分配和查询优化开销，提高查询性能。</p><p>在EF Core 5.0及以上版本中，EF.CompileAsyncQuery已经成为了标准的扩展方法，无需进行任何特殊的安装或配置即可使用。</p><p>它适用于查询条件固定的情况，当然也可以重新编译，不过频繁的编译会造成内存和性能的开销。</p><p>示例如下：</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code>using Microsoft<span class="token punctuation">.</span>EntityFrameworkCore<span class="token punctuation">.</span>Query<span class="token punctuation">;</span>
<span class="token comment">// 定义一个异步查询</span>
private <span class="token keyword">static</span> readonly Func<span class="token operator">&lt;</span>MyDbContext<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> Task<span class="token operator">&lt;</span>Order<span class="token operator">&gt;&gt;</span> GetOrderById <span class="token operator">=</span>
    EF<span class="token punctuation">.</span><span class="token function">CompileAsyncQuery</span><span class="token punctuation">(</span><span class="token punctuation">(</span>MyDbContext context<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
        context<span class="token punctuation">.</span>Orders<span class="token punctuation">.</span><span class="token function">FirstOrDefaultAsync</span><span class="token punctuation">(</span>o <span class="token operator">=</span><span class="token operator">&gt;</span> o<span class="token punctuation">.</span>Id <span class="token operator">==</span> id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 调用异步查询</span>
var order <span class="token operator">=</span> await <span class="token function">GetOrderById</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,26);function k(m,h){const t=o("ExternalLinkIcon");return p(),c("div",null,[r,n("blockquote",null,[n("p",null,[a("注意：如果同时使用数据库池和延迟加载，那么就出现内存上升问题，详情看："),n("a",u,[a("https://masuit.org/2049?t=uhwxjhl4ecqo"),i(t)])])]),d])}const C=e(l,[["render",k],["__file","youhua.html.vue"]]),b=JSON.parse('{"path":"/orm/efcore/youhua.html","title":"优化","lang":"zh-CN","frontmatter":{"title":"优化","lang":"zh-CN","date":"2022-08-17T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["orm"],"tag":["无"],"filename":"youhua","slug":"wucu19","docsId":"29500546","description":"使用DbContext池 在Core Mvc中,如果使用 AddDbContextPool 方法，那么在控制器请求 DbContext 实例时，我们会首先检查池中有无可用的实例。 请求处理完成后，实例的任何状态都将被重置，并且实例本身会返回池中。 从概念上讲，此方法类似于 ADO.NET 连接池的运行原理，并具有节约 DbContext 实例初始化成本...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/orm/efcore/youhua.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"优化"}],["meta",{"property":"og:description","content":"使用DbContext池 在Core Mvc中,如果使用 AddDbContextPool 方法，那么在控制器请求 DbContext 实例时，我们会首先检查池中有无可用的实例。 请求处理完成后，实例的任何状态都将被重置，并且实例本身会返回池中。 从概念上讲，此方法类似于 ADO.NET 连接池的运行原理，并具有节约 DbContext 实例初始化成本..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-01-15T15:10:20.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2022-08-17T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-01-15T15:10:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"优化\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-08-17T00:00:00.000Z\\",\\"dateModified\\":\\"2024-01-15T15:10:20.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"使用DbContext池","slug":"使用dbcontext池","link":"#使用dbcontext池","children":[]},{"level":2,"title":"连接池原理","slug":"连接池原理","link":"#连接池原理","children":[]},{"level":2,"title":"批处理","slug":"批处理","link":"#批处理","children":[]},{"level":2,"title":"关闭状态追踪","slug":"关闭状态追踪","link":"#关闭状态追踪","children":[]},{"level":2,"title":"包含关系","slug":"包含关系","link":"#包含关系","children":[]},{"level":2,"title":"Find查询","slug":"find查询","link":"#find查询","children":[]},{"level":2,"title":"EF.CompileAsyncQuery","slug":"ef-compileasyncquery","link":"#ef-compileasyncquery","children":[]}],"git":{"createdTime":1690042937000,"updatedTime":1705331420000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":3}]},"readingTime":{"minutes":4.49,"words":1348},"filePathRelative":"orm/efcore/youhua.md","localizedDate":"2022年8月17日","excerpt":"<h2>使用DbContext池</h2>\\n<p>在Core Mvc中,如果使用 AddDbContextPool 方法，那么在控制器请求 DbContext 实例时，我们会首先检查池中有无可用的实例。 请求处理完成后，实例的任何状态都将被重置，并且实例本身会返回池中。&nbsp;从概念上讲，此方法类似于 ADO.NET 连接池的运行原理，并具有节约 DbContext 实例初始化成本的优势。\\npoolSize 参数 AddDbContextPool 设置池保留的最大实例数 中128。 一旦 poolSize 超出，就不会缓存新的上下文实例，EF 会回退到按需创建实例的非池行为。</p>\\n<div class=\\"language-csharp\\" data-ext=\\"cs\\" data-title=\\"cs\\"><pre class=\\"language-csharp\\"><code>services<span class=\\"token punctuation\\">.</span><span class=\\"token generic-method\\"><span class=\\"token function\\">AddDbContextPool</span><span class=\\"token generic class-name\\"><span class=\\"token punctuation\\">&lt;</span>BloggingContext<span class=\\"token punctuation\\">&gt;</span></span></span><span class=\\"token punctuation\\">(</span> options <span class=\\"token operator\\">=&gt;</span> options<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">UseSqlServer</span><span class=\\"token punctuation\\">(</span>connectionString<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n</code></pre></div>","autoDesc":true}');export{C as comp,b as data};
