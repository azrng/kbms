import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as i,o as s,c as o,b as e,e as t,f as n,d as l}from"./app-D8HBJYTp.js";const c="/kbms/common/1610857066845-9bbc20c4-ebd1-4e9a-9149-1ac0b6ba499a.png",p={},h=l('<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h2><p>Rabbitmq.cap只能算分布式应用框架，实现了本地消息表模式，dtm才是纯粹的分布式事务框架</p><h2 id="场景" tabindex="-1"><a class="header-anchor" href="#场景"><span>场景</span></a></h2><p>一个项目对应一个数据库，这种单机业务是平时处理的比较多的；这里主要归纳一下会出现分布式事务的场景。</p><h3 id="一个项目对个数据库" tabindex="-1"><a class="header-anchor" href="#一个项目对个数据库"><span>一个项目对个数据库</span></a></h3><p>在一个下纲目中，同时连接了两个数据库，分别操作两个数据库，并且确保两次操作要不都成功，要不都失败，这就需要分布式事务进行处理。</p><h3 id="多个项目一个数据库" tabindex="-1"><a class="header-anchor" href="#多个项目一个数据库"><span>多个项目一个数据库</span></a></h3><p>有些系统需要将业务分开开发和部署，便于代码管理和后期维护，在数据库资源允许的情况下可以共用一个数据库，在这种情况下如果有事务操作，同样需要分布式事务进行处理。</p><h3 id="多个项目多个数据库" tabindex="-1"><a class="header-anchor" href="#多个项目多个数据库"><span>多个项目多个数据库</span></a></h3><p>这种方式其实就是微服务模式，分业务划分项目，每个业务对应一个数据库，这种场景下项目之间的事务肯定是分布式的。</p><h2 id="cap理论" tabindex="-1"><a class="header-anchor" href="#cap理论"><span>CAP理论</span></a></h2><p>CAP理论(<strong>Consistency(一致性)、Availability(可用性)、PartitionTolerance(分区容错性)</strong>)核心指在一个分布式系统中，一致性、可用性、分区容错性最多只能同时实现两点，不可能三者兼顾。</p><ul><li><strong>C(Consistency-一致性)：是指在写操作之后，任意节点进行读取时，都能一致获取到最新的数据状态</strong>。为了保证数据一致性，在同步数据时会对资源短时进行锁定，目的为了避免获取到老的数据，导致数据不一致情况，但这样就会导致服务在短时间内不可用。</li><li><strong>A(Availability-可用性)：是指发起任何操作时都可以得到响应结果，不会出现响应超时或响应错误</strong>。就算是数据在同步过程中也要保证可用，即宁可拿到旧数据也不要报错。</li><li><strong>P(PartitionTolerance-分区容错性)：这里的分区是指网络分区</strong>，通常分布式系统，各节点会部署到不同子网，由于网络具有不可控性，可能会导致节点之间的通信失败；但在设计此类系统时，应该考虑这种情况，保证提供正常的服务，这其实可以理解为平时咱们说的高可用；<strong>这个指标是分布式系统必备的，不然就不能叫高可用系统啦</strong>。</li></ul><figure><img src="'+c+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h3 id="cap组合" tabindex="-1"><a class="header-anchor" href="#cap组合"><span>CAP组合</span></a></h3><p>其实通过上面的概述，<strong>C(一致性)和A(可用性)是互相排斥的</strong>，为了保证一致性，会锁定资源导致短时间不可用，而可用性的要求就是必须对操作有对应的响应结果，就算得到的数据不是最新的也行，目的是保证可用。<strong>而P(分区容错性)是分布式系统中必备指标，所以在分布式系统中经常的组合就是CP和AP</strong>。 CA：单点集群，满足一致性，可用性的系统通常在扩展性上不太强大，传统的Oracle数据库。 CP：放弃可用性，注重一致性和分区容错性，其实这就是所谓的强一致性，可能在银行跨行转账这种强一致业务场景才会用到，具体得根据业务场景做取舍，通常性能不是特别高。 AP：放弃强一致性，注重可用性和分区容错性，这是现在绝大多数分布式业务场景的选择，只要最后能保证最终一致性(Base理论)即可。大多数网站架构的选择。弱一致性和高可用。</p><h2 id="base理论" tabindex="-1"><a class="header-anchor" href="#base理论"><span>Base理论</span></a></h2><p><strong>BASE是Basically Available(基本可用)，Soft State（软状态）和Eventually Consistent（最终一致性）三个短语的缩写，是对AP的一种扩展，即当出现故障时允许部分服务不可用，但要保证核心服务正常。对于数据，允许一定时间内不一致，通过中间状态(软状态)过渡，最后保证最终一致即可</strong>。 举例说明： <strong>Basically Available(基本可用)</strong>：比如一个系统注册用户成功时需要发送信息通知，允许发送信息不成功，但注册这个核心功能要保证可用。 <strong>Soft State（软状态）</strong>：平时见得最多的软状态有：“支付中”、“数据处理中”等，这些状态是为了满足可用性和最终一致增加的过渡状态。 <strong>Eventually Consistent（最终一致性）</strong>：比如在购买商品时，支付的过程中会显示“支付中”，最终会显示“支付成功”，这个时候其实就保证最终你的账户和收款账户这个事务最终一致了，这种事务可以理解为“<strong>柔性事务</strong>”。</p><h2 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案"><span>解决方案</span></a></h2><ul><li><strong>2PC（Two-phase commit protocol）</strong>，又称二阶段提交，是一种强一致性解决方案。对其进行补充的还有一个叫<strong>3PC</strong>的解决方案。</li><li><strong>TCC（Try Confirm Cancel）</strong>，补偿事务。</li><li><strong>本地消息表</strong></li><li><strong>消息事务</strong></li><li><strong>最大努力通知</strong></li></ul>',20),d={href:"https://www.yuque.com/docs/share/8916ba9b-b05e-4028-b04f-5d2c350692eb?view=doc_embed",target:"_blank",rel:"noopener noreferrer"},m=e("h2",{id:"资料",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#资料"},[e("span",null,"资料")])],-1),g={href:"https://mp.weixin.qq.com/s/1upcmOHMN-sgZ34844ad3w",target:"_blank",rel:"noopener noreferrer"},b={href:"https://mp.weixin.qq.com/s/1hr-tZOiUDfSVOW4cAumLQ",target:"_blank",rel:"noopener noreferrer"},u={href:"https://github.com/dtm-labs/dtm",target:"_blank",rel:"noopener noreferrer"};function f(_,y){const a=i("ExternalLinkIcon");return s(),o("div",null,[h,e("p",null,[e("a",d,[t("介绍"),n(a)])]),m,e("p",null,[e("a",g,[t("https://mp.weixin.qq.com/s/1upcmOHMN-sgZ34844ad3w"),n(a)]),t(" | 避不开的分布式事务 分布式事务知多少？"),e("a",b,[t("https://mp.weixin.qq.com/s/1hr-tZOiUDfSVOW4cAumLQ"),n(a)]),t(" 分布式事务管理器："),e("a",u,[t("https://github.com/dtm-labs/dtm"),n(a)])])])}const w=r(p,[["render",f],["__file","fenbushishiwu.html.vue"]]),C=JSON.parse('{"path":"/middleware/smallService/fenbushishiwu/fenbushishiwu.html","title":"分布式事务","lang":"zh-CN","frontmatter":{"title":"分布式事务","lang":"zh-CN","date":"2023-04-02T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["middleware"],"tag":["无"],"filename":"fenbushishiwu","slug":"fpv3yd","docsId":"65981973","description":"概述 Rabbitmq.cap只能算分布式应用框架，实现了本地消息表模式，dtm才是纯粹的分布式事务框架 场景 一个项目对应一个数据库，这种单机业务是平时处理的比较多的；这里主要归纳一下会出现分布式事务的场景。 一个项目对个数据库 在一个下纲目中，同时连接了两个数据库，分别操作两个数据库，并且确保两次操作要不都成功，要不都失败，这就需要分布式事务进行处...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/middleware/smallService/fenbushishiwu/fenbushishiwu.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"分布式事务"}],["meta",{"property":"og:description","content":"概述 Rabbitmq.cap只能算分布式应用框架，实现了本地消息表模式，dtm才是纯粹的分布式事务框架 场景 一个项目对应一个数据库，这种单机业务是平时处理的比较多的；这里主要归纳一下会出现分布式事务的场景。 一个项目对个数据库 在一个下纲目中，同时连接了两个数据库，分别操作两个数据库，并且确保两次操作要不都成功，要不都失败，这就需要分布式事务进行处..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://azrng.gitee.io/kbms/kbms/common/1610857066845-9bbc20c4-ebd1-4e9a-9149-1ac0b6ba499a.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-11-09T14:02:29.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-04-02T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-11-09T14:02:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"分布式事务\\",\\"image\\":[\\"https://azrng.gitee.io/kbms/kbms/common/1610857066845-9bbc20c4-ebd1-4e9a-9149-1ac0b6ba499a.png\\"],\\"datePublished\\":\\"2023-04-02T00:00:00.000Z\\",\\"dateModified\\":\\"2023-11-09T14:02:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[]},{"level":2,"title":"场景","slug":"场景","link":"#场景","children":[{"level":3,"title":"一个项目对个数据库","slug":"一个项目对个数据库","link":"#一个项目对个数据库","children":[]},{"level":3,"title":"多个项目一个数据库","slug":"多个项目一个数据库","link":"#多个项目一个数据库","children":[]},{"level":3,"title":"多个项目多个数据库","slug":"多个项目多个数据库","link":"#多个项目多个数据库","children":[]}]},{"level":2,"title":"CAP理论","slug":"cap理论","link":"#cap理论","children":[{"level":3,"title":"CAP组合","slug":"cap组合","link":"#cap组合","children":[]}]},{"level":2,"title":"Base理论","slug":"base理论","link":"#base理论","children":[]},{"level":2,"title":"解决方案","slug":"解决方案","link":"#解决方案","children":[]},{"level":2,"title":"资料","slug":"资料","link":"#资料","children":[]}],"git":{"createdTime":1697724028000,"updatedTime":1699538549000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":1}]},"readingTime":{"minutes":4.63,"words":1390},"filePathRelative":"middleware/smallService/fenbushishiwu/fenbushishiwu.md","localizedDate":"2023年4月2日","excerpt":"<h2>概述</h2>\\n<p>Rabbitmq.cap只能算分布式应用框架，实现了本地消息表模式，dtm才是纯粹的分布式事务框架</p>\\n<h2>场景</h2>\\n<p>一个项目对应一个数据库，这种单机业务是平时处理的比较多的；这里主要归纳一下会出现分布式事务的场景。</p>\\n<h3>一个项目对个数据库</h3>\\n<p>在一个下纲目中，同时连接了两个数据库，分别操作两个数据库，并且确保两次操作要不都成功，要不都失败，这就需要分布式事务进行处理。</p>\\n<h3>多个项目一个数据库</h3>\\n<p>有些系统需要将业务分开开发和部署，便于代码管理和后期维护，在数据库资源允许的情况下可以共用一个数据库，在这种情况下如果有事务操作，同样需要分布式事务进行处理。</p>","autoDesc":true}');export{w as comp,C as data};
