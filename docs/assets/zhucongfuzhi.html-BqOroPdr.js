import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,o as s,d as a}from"./app-BguyEeV-.js";const t="/kbms/common/1614056262236-4899a721-3403-46ad-9e2e-eadb3ccac404.jpeg",l={},n=a('<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h2><p><img src="'+t+`" alt="image.jpeg" loading="lazy"> （1）Master将改变记录到二进制日志(binary log)中（这些记录叫做二进制日志事件，binary log events）； （2）Slave将Master的二进制日志事件(binary log events)拷贝到它的中继日志(relay log)； 注：Slave服务器中有一个I/O线程(I/O Thread)在不停地监听Master的二进制日志(Binary Log)是否有更新：如果没有它会睡眠等待Master产生新的日志事件；如果有新的日志事件(Log Events)，则会将其拷贝至Slave服务器中的中继日志(Relay Log)。 （3）Slave重做中继日志(Relay Log)中的事件，将Master上的改变反映到它自己的数据库中。 注：Slave服务器中有一个SQL线程(SQL Thread)从中继日志读取事件，并重做其中的事件从而更新Slave的数据，使其与Master中的数据一致。只要该线程与I/O线程保持一致，中继日志通常会位于OS的缓存中，所以中继日志的开销很小。</p><h2 id="主从数据库不一致" tabindex="-1"><a class="header-anchor" href="#主从数据库不一致"><span>主从数据库不一致</span></a></h2><p>先上Master库：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>mysql&gt;show processlist;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>查看下进程是否Sleep太多。发现很正常。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>show master status;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>也正常。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>mysql&gt; show master status;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><table><thead><tr><th>File</th><th>Position</th><th>Binlog_Do_DB</th><th>Binlog_Ignore_DB</th></tr></thead><tbody><tr><td>mysqld-bin.000001</td><td>3260</td><td></td><td>mysql,test,information_schema</td></tr><tr><td>1 row in set (0.00 sec)</td><td></td><td></td><td></td></tr><tr><td>再到Slave上查看</td><td></td><td></td><td></td></tr></tbody></table><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>mysql&gt; show slave status\\G</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Slave_IO_Running: Yes Slave_SQL_Running: No 可见是Slave不同步</p><h3 id="解决方案-忽略错误后-继续同步" tabindex="-1"><a class="header-anchor" href="#解决方案-忽略错误后-继续同步"><span>解决方案：忽略错误后，继续同步</span></a></h3><p>该方法适用于主从库数据相差不大，或者要求数据可以不完全统一的情况，数据要求不严格的情况 解决：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>stop slave;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#表示跳过一步错误，后面的数字可变</span></span>
<span class="line"><span>set global sql_slave_skip_counter =1;</span></span>
<span class="line"><span>start slave;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>之后再用mysql&gt; show slave status\\G  查看</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>mysql&gt; show slave status\\G</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Slave_IO_Running: Yes Slave_SQL_Running: Yes ok，现在主从同步状态正常了。。。</p><h3 id="解决方案-重新做主从-完全同步" tabindex="-1"><a class="header-anchor" href="#解决方案-重新做主从-完全同步"><span>解决方案：重新做主从，完全同步</span></a></h3><p>该方法适用于主从库数据相差较大，或者要求数据完全统一的情况 解决步骤如下： 1.先进入主库，进行锁表，防止数据写入 使用命令：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>mysql&gt; flush tables with read lock;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>注意：该处是锁定为只读状态，语句不区分大小写 2.进行数据备份 #把数据备份到mysql.bak.sql文件</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>mysqldump -uroot -p -hlocalhost &gt; mysql.bak.sql</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里注意一点：数据库备份一定要定期进行，可以用shell脚本或者python脚本，都比较方便，确保数据万无一失。 3.查看master 状态</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>mysql&gt; show master status;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><table><thead><tr><th>File</th><th>Position</th><th>Binlog_Do_DB</th><th>Binlog_Ignore_DB</th></tr></thead><tbody><tr><td>mysqld-bin.000001</td><td>3260</td><td></td><td>mysql,test,information_schema</td></tr></tbody></table><p>1 row in set (0.00 sec) 4.把mysql备份文件传到从库机器，进行数据恢复</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>scp mysql.bak.sql root@192.168.128.101:/tmp/</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>5.停止从库的状态</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>mysql&gt; stop slave;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>6.然后到从库执行mysql命令，导入数据备份</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>mysql&gt; source /tmp/mysql.bak.sql</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>7.设置从库同步，注意该处的同步点，就是主库show master status信息里的| File| Position两项</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>change master to master_host = &#39;192.168.128.100&#39;, master_user = &#39;rsync&#39;,  master_port=3306, master_password=&#39;&#39;, master_log_file =  &#39;mysqld-bin.000001&#39;, master_log_pos=3260;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>8.重新开启从同步</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>mysql&gt; start slave;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>9.查看同步状态</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>mysql&gt; show slave status\\G</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Slave_IO_Running: Yes Slave_SQL_Running: Yes 10.回到主库并执行如下命令解除表锁定。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>UNLOCK TABLES;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,40),r=[n];function d(h,o){return s(),i("div",null,r)}const p=e(l,[["render",d],["__file","zhucongfuzhi.html.vue"]]),b=JSON.parse('{"path":"/dataBase/mysql/jinjie/zhucongfuzhi.html","title":"主从复制","lang":"zh-CN","frontmatter":{"title":"主从复制","lang":"zh-CN","date":"2023-09-03T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["dataBase"],"tag":["无"],"filename":"zhucongfuzhi","slug":"yzxd47","docsId":"31804880","description":"概述 image.jpeg （1）Master将改变记录到二进制日志(binary log)中（这些记录叫做二进制日志事件，binary log events）； （2）Slave将Master的二进制日志事件(binary log events)拷贝到它的中继日志(relay log)； 注：Slave服务器中有一个I/O线程(I/O Thread)...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dataBase/mysql/jinjie/zhucongfuzhi.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"主从复制"}],["meta",{"property":"og:description","content":"概述 image.jpeg （1）Master将改变记录到二进制日志(binary log)中（这些记录叫做二进制日志事件，binary log events）； （2）Slave将Master的二进制日志事件(binary log events)拷贝到它的中继日志(relay log)； 注：Slave服务器中有一个I/O线程(I/O Thread)..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://azrng.gitee.io/kbms/kbms/common/1614056262236-4899a721-3403-46ad-9e2e-eadb3ccac404.jpeg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-18T14:41:28.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-09-03T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-18T14:41:28.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"主从复制\\",\\"image\\":[\\"https://azrng.gitee.io/kbms/kbms/common/1614056262236-4899a721-3403-46ad-9e2e-eadb3ccac404.jpeg\\"],\\"datePublished\\":\\"2023-09-03T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-18T14:41:28.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[]},{"level":2,"title":"主从数据库不一致","slug":"主从数据库不一致","link":"#主从数据库不一致","children":[{"level":3,"title":"解决方案：忽略错误后，继续同步","slug":"解决方案-忽略错误后-继续同步","link":"#解决方案-忽略错误后-继续同步","children":[]},{"level":3,"title":"解决方案：重新做主从，完全同步","slug":"解决方案-重新做主从-完全同步","link":"#解决方案-重新做主从-完全同步","children":[]}]}],"git":{"createdTime":1695484404000,"updatedTime":1702910488000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":1}]},"readingTime":{"minutes":2.71,"words":812},"filePathRelative":"dataBase/mysql/jinjie/zhucongfuzhi.md","localizedDate":"2023年9月3日","excerpt":"<h2>概述</h2>\\n<p><img src=\\"/common/1614056262236-4899a721-3403-46ad-9e2e-eadb3ccac404.jpeg\\" alt=\\"image.jpeg\\" loading=\\"lazy\\">\\n（1）Master将改变记录到二进制日志(binary log)中（这些记录叫做二进制日志事件，binary log events）；\\n（2）Slave将Master的二进制日志事件(binary log events)拷贝到它的中继日志(relay log)；\\n注：Slave服务器中有一个I/O线程(I/O Thread)在不停地监听Master的二进制日志(Binary Log)是否有更新：如果没有它会睡眠等待Master产生新的日志事件；如果有新的日志事件(Log Events)，则会将其拷贝至Slave服务器中的中继日志(Relay Log)。\\n（3）Slave重做中继日志(Relay Log)中的事件，将Master上的改变反映到它自己的数据库中。\\n注：Slave服务器中有一个SQL线程(SQL Thread)从中继日志读取事件，并重做其中的事件从而更新Slave的数据，使其与Master中的数据一致。只要该线程与I/O线程保持一致，中继日志通常会位于OS的缓存中，所以中继日志的开销很小。</p>","autoDesc":true}');export{p as comp,b as data};
