import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as t,e as i}from"./app-vSdX8vi3.js";const a={},s=i(`<p>https://mp.weixin.qq.com/s/EyzVsV-AgHBOh543r7kttw | 【面试题解析】.NET实战面试题及答案AI补充，大家对比学习</p><p>https://mp.weixin.qq.com/s/dBwNXl_c3b0nqynansY_LA | 热心网友收集的.NET实战面试题</p><h2 id="net、asp-net、c-、visualstudio之间的关系是什么" tabindex="-1"><a class="header-anchor" href="#net、asp-net、c-、visualstudio之间的关系是什么"><span>.Net、ASP.Net、C#、VisualStudio之间的关系是什么？</span></a></h2><p>.Net期初指的是.Net Framework 该框架最高版本为4.8，2016年左右出了.NetCore在更新一直到5版本的时候，成为了大统一的.Net，所以在.Net5 .Net6 .Net7 .Net8 等高版本也指.NetCore，该框架提供了基础的.Net类，这些类可以被任何一种.Net编程语言调用，.Net还提供了CLR、JIT、GC等基础功能。</p><p>ASP.Net是.Net中用来进行Web开发的一种技术，ASP.Net的页面部分写在aspx 文件中，逻辑代码通常通过Code-behind的方式用C#、VB.Net等支持.Net的语言编写。</p><p>C#是使用最广泛的支持.Net的编程语言。除了C#还有VB.Net等。</p><p>VisualStudio是微软提供的用来进行.Net开发的集成开发环境（IDE），使用VisualStudio可以简化很多工作，不用程序员直接调用csc.exe等命令行进行程序的编译，而且VisualStudio提供了代码自动完成、代码高亮等功能方便开发，最新版本是VS2022。除了VisualStudio，还有Rider等。</p><h2 id="asp-net-framework-和-asp-net-core-有什么区别" tabindex="-1"><a class="header-anchor" href="#asp-net-framework-和-asp-net-core-有什么区别"><span>ASP.NET Framework 和 ASP.NET Core 有什么区别？</span></a></h2><p>ASP.NET Framework：是传统的.NET Web应用程序框架，主要运行在Windows平台上，依赖于IIS，功能丰富但较为笨重，不支持跨平台。</p><p>ASP.NET Core：是跨平台的.NET Web应用程序框架，支持Windows、Mac和Linux等平台，可以使用不同的运行时，更轻量且性能更高，适合现代应用开发。</p><p>优点：.NET Core具有更小的文件大小、更快的启动时间和更好的性能表现，同时还可以使用新的C#语言功能。</p><h2 id="net-core相比-net-framework-的优点" tabindex="-1"><a class="header-anchor" href="#net-core相比-net-framework-的优点"><span>.NET Core相比.NET Framework 的优点</span></a></h2><p>全家桶还是想自选</p><p>Net：默认包含了所有东西，满足所有人使用需求</p><p>Netcore：需要啥自己加啥，看个人使用需求。</p><p>Asp.NetCore与Asp.Net不一样的地方，前者是根据需求添加对应的中间件，而后者是提前就全部准备好了，不管用不用，反正都要经过，这也是Asp.NetCore性能比较好的原因之一。</p><p>ASP.NET Core 具有如下优点：跨平台、自托管、开源、高性能</p><ul><li>生成 Web UI 和 Web API 的统一场景。</li><li>集成<strong>新式客户端框架</strong>和开发工作流。</li><li>基于环境的云就绪<strong>配置系统</strong>。</li><li>内置<strong>依赖项注入</strong>。</li><li>轻型的<strong>高性能</strong>模块化 HTTP 请求管道。</li><li>能够在 <strong>IIS、Nginx、Apache、Docker</strong> 上进行托管或在自己的进程中进行自托管。</li><li>定目标到 <strong>.NET Core</strong> 时，可以使用并行应用版本控制。</li><li>简化新式 Web 开发的工具。</li><li>能够在 Windows、macOS 和 Linux 进行生成和运行。</li><li>开放源代码和<strong>以社区为中心</strong>。</li></ul><p>.net core 完全作为nuget包提供，借助nuget包可以将应用优化减少到只包含到必须的依赖项，提升了安全性，减少了维护和提高性能</p><p>跨平台的本质是因为已经内置了主机，只要是程序启动就是启动了主机，就可以监听端口</p><h2 id="ado-net中的五个主要对象" tabindex="-1"><a class="header-anchor" href="#ado-net中的五个主要对象"><span>ADO.NET中的五个主要对象</span></a></h2><p>Connection：主要是开启程序和数据库之间的连接。没有利用连接对象将数据库打开，是无法从数据库中取得数据的。Close和Dispose的区别，Close以后还可以Open，Dispose以后则不能再用。</p><p>Command：主要可以用来对数据库发出一些指令，例如可以对数据库下达查询、新增、修改、删除数据等指令，以及调用存在数据库中的存储过程等。这个对象是架构在Connection 对象上，也就是Command 对象是透过连接到数据源。</p><p>DataAdapter：主要是在数据源以及DataSet 之间执行数据传输的工作，它可以透过Command 对象下达命令后，并将取得的数据放入DataSet 对象中。这个对象是架构在Command对象上，并提供了许多配合DataSet 使用的功能。</p><p>DataSet：这个对象可以视为一个暂存区（Cache），可以把从数据库中所查询到的数据保留起来，甚至可以将整个数据库显示出来，DataSet是放在内存中的。DataSet 的能力不只是可以储存多个Table 而已，还可以透过DataAdapter对象取得一些例如主键等的数据表结构，并可以记录数据表间的关联。DataSet 对象可以说是ADO.NET 中重量级的对象，这个对象架构在DataAdapter对象上，本身不具备和数据源沟通的能力；也就是说我们是将DataAdapter对象当做DataSet 对象以及数据源间传输数据的桥梁。DataSet包含若干DataTable、DataTableTable包含若干DataRow。</p><p>DataReader：当我们只需要循序的读取数据而不需要其它操作时，可以使用DataReader 对象。DataReader对象只是一次一笔向下循序的读取数据源中的数据，这些数据是存在数据库服务器中的，而不是一次性加载到程序的内存中的，只能（通过游标）读取当前行的数据，而且这些数据是只读的，并不允许作其它的操作。因为DataReader 在读取数据的时候限制了每次只读取一笔，而且只能只读，所以使用起来不但节省资源而且效率很好。使用DataReader 对象除了效率较好之外，因为不用把数据全部传回，故可以降低网络的负载。</p><p>ADO.NET 使用Connection 对象来连接数据库，使用Command 或DataAdapter对象来执行SQL语句，并将执行的结果返回给DataReader 或 DataAdapter ,然后再使用取得的DataReader 或DataAdapter 对象操作数据结果。</p><h2 id="列举asp-net-页面之间传递值的几种方式。" tabindex="-1"><a class="header-anchor" href="#列举asp-net-页面之间传递值的几种方式。"><span>列举ASP.NET 页面之间传递值的几种方式。</span></a></h2><p>1.使用QueryString, 如....?id=1; response. Redirect()....</p><p>2.使用Session变量</p><p>3.使用Server.Transfer</p><p>4.Cookie传值</p><h2 id="什么是dotnet-core的startup-class" tabindex="-1"><a class="header-anchor" href="#什么是dotnet-core的startup-class"><span><strong>什么是dotNet core的startup class?</strong></span></a></h2><p>答：Startup class是dot net core应用的入口。所有的dot net core应用必须有这个class 这个类用来配置应用。</p><p>这个类的调用是在program main函数里面进行配置的。类的名字可以自己定义。</p><h2 id="post、get的区别" tabindex="-1"><a class="header-anchor" href="#post、get的区别"><span>post、get的区别？</span></a></h2><p>get的参数会显示在浏览器地址栏中，而post的参数不会显示在浏览器地址栏中；</p><p>使用post提交的页面在点击【刷新】按钮的时候浏览器一般会提示“是否重新提交”，而get则不会；</p><p>用get的页面可以被搜索引擎抓取，而用post的则不可以；</p><p>用post可以提交的数据量非常大，而用get可以提交的数据量则非常小(2k)，受限于网页地址的长度。</p><p>用post可以进行文件的提交，而用get则不可以。</p><h2 id="application-、cookie和-session-两种会话有什么不同" tabindex="-1"><a class="header-anchor" href="#application-、cookie和-session-两种会话有什么不同"><span>Application 、Cookie和 Session 两种会话有什么不同？</span></a></h2><p>Application是用来存取整个网站全局的信息，而Session是用来存取与具体某个访问者关联的信息。Cookie是保存在客户端的，机密信息不能保存在Cookie中，只能放小数据；Session是保存在服务器端的，比较安全，可以放大数据。</p><h2 id="session有什么重大bug-微软提出了什么方法加以解决" tabindex="-1"><a class="header-anchor" href="#session有什么重大bug-微软提出了什么方法加以解决"><span>Session有什么重大BUG，微软提出了什么方法加以解决？</span></a></h2><p>IIS中由于有进程回收机制，系统繁忙的话Session会丢失，IIS重启也会造成Session失。这样用户就要重新登录或者重新添加购物车、验证码等放到Session中的信息。可以用State Server或SQL Server数据库的方式存储Session不过这种方式比较慢，而且无法捕获Session的END事件。但是这不是Bug，只能说是In-Proc方式存储Session的缺陷，缺陷是和Bug不一样的，In-Proc方式存储Session会由服务器来决定什么时候释Session，In-Proc方式不满足要求的话完全可以用StateServer和数据库的方式。</p><p>StateServer还可以解决集群Session共享的问题。</p><h2 id="介绍几个使用过的开源的项目" tabindex="-1"><a class="header-anchor" href="#介绍几个使用过的开源的项目"><span>介绍几个使用过的开源的项目？</span></a></h2><p>AutoMapper、Dapper、Redis、NPOI、JQuery、Quartz.Net、JqueryUI、Vue、Lucene.net。在GitHub、Gitee网站上有更多的开源项目。</p><h2 id="谈谈你对mvc和三层架构的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对mvc和三层架构的理解"><span>谈谈你对MVC和三层架构的理解？</span></a></h2><p>MVC即模型、视图、控制器，模型表示业务数据及业务处理，用来封装数据及行为；视图是用户看到并与之交互的界面；控制器接受用户输入并调用模型和视图去完成用户的请求。使用MVC有利于关注点分离，自动化UI测试成为了可能。</p><p>三层架构即表现层(UI)、业务逻辑层(BLL)、数据访问层(DAL)。区分层次的目的即为了“高内聚，低耦合”的思想。表现层通俗讲就是展现给用户的界面，业务逻辑层即针对具体问题的操作，也可以说是对数据层的操作，对数据业务逻辑处理。数据访问层：该层所做事务直接操作数据库，针对数据的增添、删除、修改、更新、查找等。</p><h2 id="什么是中间件" tabindex="-1"><a class="header-anchor" href="#什么是中间件"><span><strong>什么是中间件?</strong></span></a></h2><p>答：中间件在这里是指注入到应用中处理请求和响应的组件。</p><h2 id="application-builder的use和run方法有什么区别" tabindex="-1"><a class="header-anchor" href="#application-builder的use和run方法有什么区别"><span><strong>application builder的use和run方法有什么区别?</strong></span></a></h2><p>答：这两个方法都在start up class的configure方法里面调用。都是用来向应用请求管道里面添加中间件的。Use方法可以调用下一个中间件的添加，而run不会。</p><h2 id="dotnet-core-管道里面的map拓展有什么作用" tabindex="-1"><a class="header-anchor" href="#dotnet-core-管道里面的map拓展有什么作用"><span>dotNet core 管道里面的map拓展有什么作用?</span></a></h2><p>答：可以针对不同的路径添加不同的中间件。</p><h2 id="dotnet-core里面的路径是如何处理的" tabindex="-1"><a class="header-anchor" href="#dotnet-core里面的路径是如何处理的"><span>dotNet core里面的路径是如何处理的?</span></a></h2><p>答：路径处理是用来为进入的请求寻找处理函数的机制。所有的路径在函数运行开始时进行注册。</p><p>主要有两种路径处理方式，常规路径处理和属性路径处理。常规路径处理就是用MapRoute的方式设定调用路径，属性路径处理是指在调用函数的上方设定一个路径属性。</p><h2 id="如何在dotnet-core中使用session" tabindex="-1"><a class="header-anchor" href="#如何在dotnet-core中使用session"><span>如何在dotNet core中使用session</span></a></h2><p>答：首先要添加session包. 其次要在config service方法里面添加session。然后又在configure方法里面调用usesession。</p><h2 id="描述一下依赖注入后的服务生命周期" tabindex="-1"><a class="header-anchor" href="#描述一下依赖注入后的服务生命周期"><span>描述一下依赖注入后的服务生命周期?</span></a></h2><p>答：asp.net core主要提供了三种依赖注入的方式</p><p>其中AddTransient与AddSingleton比较好区别</p><p>AddTransient瞬时模式：每次都获取一个新的实例</p><p>AddSingleton单例模式：每次都获取同一个实例</p><p>而AddTransient与AddScoped的区别更不容易区别一点</p><p>首先这两种方式每次请求得到的都不是同一个对象，从这点看会发现这两个都一样。</p><p>但是我们可以继续分细一点，虽然不同的请求得到的结果不同，但是我们可以在同一次请求中去获取多次实例测试。</p><p>小总结:</p><p>AddTransient瞬时模式：每次请求，都获取一个新的实例。即使同一个请求获取多次也会是不同的实例</p><p>AddScoped：每次请求，都获取一个新的实例。同一个请求获取多次会得到相同的实例</p><p>AddSingleton单例模式：每次都获取同一个实例。</p><h2 id="net生成-windows、mac、linux-等系统客户端的方式" tabindex="-1"><a class="header-anchor" href="#net生成-windows、mac、linux-等系统客户端的方式"><span><strong>.NET生成 Windows、Mac、Linux 等系统客户端的方式</strong></span></a></h2><p>事实上.NET本身的桌面客户端支持Windows 。当然一些开源的组件可以支持多平台，比如Avalonia，Electron.NET等等。如果是网站</p><h2 id="server-transfer和response-redirect的区别是什么" tabindex="-1"><a class="header-anchor" href="#server-transfer和response-redirect的区别是什么"><span>Server.Transfer和Response.Redirect的区别是什么？</span></a></h2><p>Server.Transfer仅是服务器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；Response.Redirect则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。</p><p>Server.Transfer是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。 这个过程中浏览器和Web服务器之间经过了一次交互。</p><p>Response.Redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求。这个过程中浏览器和Web服务器之间经过了两次交互。</p><h2 id="什么是内存映射文件" tabindex="-1"><a class="header-anchor" href="#什么是内存映射文件"><span>什么是内存映射文件？</span></a></h2><p>答：内存映射文件用于将文件内容映射到应用程序的逻辑地址。它使你能够在同一台计算机上运行多个进程以彼此共享数据。要获得一个内存映射文件对象, 可以使用MemoryMappedFile.CreateFromFiles()方法。它表示磁盘上文件中的持久性内存映射文件。</p><h2 id="net中有几种类型的内存" tabindex="-1"><a class="header-anchor" href="#net中有几种类型的内存"><span>.Net中有几种类型的内存？</span></a></h2><p>答：.Net中有两种类型的内存</p><ul><li>堆栈内存</li><li>堆内存</li></ul><h2 id="说说iis的工作原理" tabindex="-1"><a class="header-anchor" href="#说说iis的工作原理"><span>说说IIS的工作原理？</span></a></h2><p>对比IIS来说，它依赖HTTP.SYS的内置程序来监听外部的HTTP请求，如果请求的是一个可访问的URL，HTTP.SYS会将这个请求交给IIS工作进程，把信息保存到HttpWorkRequest中，在相互隔离的应用程序域AppDomain中加载HttpRuntime，调用HttpRuntime的ProcessRequest方法，之后就是我们的程序操作，最后返回数据流，并重新返回到HTTP.SYS,HTTP.SYS在将数据返回给客户端浏览器。</p><h2 id="多租户系统的实现方式" tabindex="-1"><a class="header-anchor" href="#多租户系统的实现方式"><span><strong>多租户系统的实现方式</strong></span></a></h2><p>多租户系统通过为不同租户提供隔离的环境来实现。常用的有三种实现方式，如下：</p><p>1）独立数据库方案：为每个租户创建独立的数据库，实现数据隔离。</p><p>2）共享数据库方案：在同一个数据库中使用租户ID来区分数据。</p><p>3）SCHEMA方案：使用数据库中的不同 schema 来区分租户数据。</p><p>常见的多租户开源项目有ABP等</p><h2 id="net系统如何实现水平扩展、如何解决高并发问题" tabindex="-1"><a class="header-anchor" href="#net系统如何实现水平扩展、如何解决高并发问题"><span>.NET系统如何实现水平扩展、如何解决高并发问题</span></a></h2><p>水平扩展：利用Nginx建立分布式系统，增加服务器，增加CPU</p><p>解决高并发问题:增加缓存、禁止用户重复操作、建立请求队列</p><h2 id="请问如何构架一个高负载的系统" tabindex="-1"><a class="header-anchor" href="#请问如何构架一个高负载的系统"><span>请问如何构架一个高负载的系统？</span></a></h2><p>应用服务和数据服务分离，使用缓存改善网站性能，使用应用服务器集群改善网站的并发处理能力，数据库读写分离，使用反向代理和CDN加速网站响应，使用分布式文件系统和分布式数据库系统，使用NoSQL和搜索引擎，对业务拆分，建立分布式服务。</p><h2 id="聊聊-net的管道和-net-core的中间件" tabindex="-1"><a class="header-anchor" href="#聊聊-net的管道和-net-core的中间件"><span>聊聊.NET的管道和.NET Core的中间件</span></a></h2><p>.NET的管道：在管道模型运行开始前，首先HTTP的请求被被传递到HttpRuntime类的一个实例中，然后这个实例对象检测请求并找到被接受的那个应用程序，接下来管道模型就使用HttpApplicationFactory对象来创建一个HttpApplication对象来处理这个请求（在此同时也将创建HttpContext，HttpRequest和HttpResponse），一个HttpApplication可以包含一系列HttpModule对象。</p><h2 id="net-core的中间件" tabindex="-1"><a class="header-anchor" href="#net-core的中间件"><span>.NET Core的中间件</span></a></h2><p>中间件是一种装配到应用管道中以处理请求和响应的程序，使用Run、Map和Use扩展方法来配置请求委托。请求委托用于构建请求管道，处理每个HTTP请求。</p><p>每个委托可以在下一个委托之前和之后执行操作。委托还可以决定不将请求传递给下一个委托，这称为请求管道的短路。短路通常是可取的，因为它避免了不必要的工作。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public class Startup
{
    //此处省略部分代码，创建一个新的Core web项目，可以自行查看
    public void Configure(IApplicationBuilder app, IHostingEnvironment env)
    {
        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }
        else
        {
            app.UseExceptionHandler(&quot;/Home/Error&quot;);
            app.UseHsts();
        }
        app.UseHttpsRedirection();
        app.UseStaticFiles();
        app.UseCookiePolicy();
        app.UseMvc(routes =&gt;
        {
            routes.MapRoute(
                name: &quot;default&quot;,
                template: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
        });
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Configure方法中的就是中间件，中间件组件的顺序定义了在请求上调用它们的顺序，以及响应的相反顺序，此排序对于安全性，性能和功能至关重要。</p><p>常用的中间件顺序</p><ol><li><p>异常/错误处理</p></li><li><p>HTTP 严格传输安全协议，HTTP协议介绍</p></li><li><p>HTTPS 重定向</p></li><li><p>静态文件服务器</p></li><li><p>Cookie 策略实施</p></li><li><p>身份验证</p></li><li><p>会话</p></li><li><p>MVC</p></li></ol><p>中间件例子：</p><div class="language-c# line-numbers-mode" data-ext="c#" data-title="c#"><pre class="language-c#"><code>public class LogMiddleware
{
    private readonly RequestDelegate _next;
    public LogMiddleware(RequestDelegate next)
    {
        _next = next;
    }
    public async Task Invoke(HttpContext context)
    {
        Debug.WriteLine(&quot;程序运行 开始。&quot;);
        await _next(context);
        Debug.WriteLine(&quot;程序运行 结束。&quot;);
    }
}

public static class LogMiddlewareExtensions {
    public static IApplicationBuilder UseLog(this IApplicationBuilder app) {
        return app.UseMiddleware&lt;LogMiddleware&gt;();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在Configure中 app.UseLog();就可，程序运行，会在VS调试输出的地方显示</p><p>程序运行 开始。</p><p>xxx</p><p>程序运行 结束。</p><h2 id="微服务的缺点" tabindex="-1"><a class="header-anchor" href="#微服务的缺点"><span><strong>微服务的缺点</strong></span></a></h2><p>微服务架构的缺点包括增加了分布式系统的复杂性，导致服务间通信开销增加，部署和维护困难度提升，一致性问题和事务管理挑战加大，测试变得更加复杂，安全性难题增多，运维负担增加，学习曲线陡峭，如果网站太小不建议采用，一般适用于业务种类较多的大项目。</p><h2 id="领域驱动设计-ddd-以及原则和实现" tabindex="-1"><a class="header-anchor" href="#领域驱动设计-ddd-以及原则和实现"><span><strong>领域驱动设计（DDD）以及原则和实现</strong></span></a></h2><p>DDD不过是一种软件设计思想和方法而已。它主要关注于将业务逻辑和领域模型融入设计过程。实现有多种方式。</p><h2 id="把一个对象赋值为null会被gc回收吗" tabindex="-1"><a class="header-anchor" href="#把一个对象赋值为null会被gc回收吗"><span>把一个对象赋值为null会被GC回收吗</span></a></h2><p>示例代码如下</p><div class="language-c# line-numbers-mode" data-ext="c#" data-title="c#"><pre class="language-c#"><code>internal class Program
{
	static void Main(string[] args)
	{
		Program pm = new Program();
		Console.WriteLine(&quot;Hello World&quot;);
		GC.SuppressFinalize(pm);//这句是废话
		pm = null;
		GC.Collect(0);//默认的GC垃圾回收器
		Console.ReadLine();
	}
	~Program()
	{
		Console.WriteLine(&quot;调用了析构函数&quot;);
	}
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>被GC回收的条件是这个对象不再存活(也就是没有被标记为1),但是pm对象是根(局部引用对象)，所以它是存活的(标记为1)。是不会被垃圾回收的。</p><p>但是如果把pm=null呢？同样的它也不会被GC回收，为什么呢？</p><p>首先看下这段代码，GC.SuppressFinalize不运行pm对象的析构函数，因为这段程序本身就不执行，所以这句代码可有可无。这句代码的后面是pm=null，以及垃圾回收。</p><p>正确的回答是:面试官你好，我认为不能被回收的。原因在于，pm对象是根对象，它本身是不能够被GC回收的。如果把pm赋值为null，也不能被回收。原因在于pm的null被赋值给了.Ctor默认构造函数的指针。而不是pm实例指针。即使单独赋值给了pm实例指针也是不行的，需要.Ctor和pm实例指针同时为null才可以被GC回收。所以个人认为它不会被GC回收。</p><p>资料来自：https://mp.weixin.qq.com/s/QhaBqFkluG2WQX_iwVG12A</p>`,125),l=[s];function r(p,o){return n(),t("div",null,l)}const u=e(a,[["render",r],["__file","dotnet.html.vue"]]),h=JSON.parse('{"path":"/interview/dotnet.html","title":"dotNet面试题","lang":"zh-CN","frontmatter":{"title":"dotNet面试题","date":"2023-03-24T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":false,"order":200,"category":["面试"],"tag":["面试题"],"article":false,"description":"https://mp.weixin.qq.com/s/EyzVsV-AgHBOh543r7kttw | 【面试题解析】.NET实战面试题及答案AI补充，大家对比学习 https://mp.weixin.qq.com/s/dBwNXl_c3b0nqynansY_LA | 热心网友收集的.NET实战面试题 .Net、ASP.Net、C#、VisualStu...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/interview/dotnet.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"dotNet面试题"}],["meta",{"property":"og:description","content":"https://mp.weixin.qq.com/s/EyzVsV-AgHBOh543r7kttw | 【面试题解析】.NET实战面试题及答案AI补充，大家对比学习 https://mp.weixin.qq.com/s/dBwNXl_c3b0nqynansY_LA | 热心网友收集的.NET实战面试题 .Net、ASP.Net、C#、VisualStu..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-11-25T12:50:39.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"面试题"}],["meta",{"property":"article:published_time","content":"2023-03-24T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-11-25T12:50:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"dotNet面试题\\",\\"description\\":\\"https://mp.weixin.qq.com/s/EyzVsV-AgHBOh543r7kttw | 【面试题解析】.NET实战面试题及答案AI补充，大家对比学习 https://mp.weixin.qq.com/s/dBwNXl_c3b0nqynansY_LA | 热心网友收集的.NET实战面试题 .Net、ASP.Net、C#、VisualStu...\\"}"]]},"headers":[{"level":2,"title":".Net、ASP.Net、C#、VisualStudio之间的关系是什么？","slug":"net、asp-net、c-、visualstudio之间的关系是什么","link":"#net、asp-net、c-、visualstudio之间的关系是什么","children":[]},{"level":2,"title":"ASP.NET Framework 和 ASP.NET Core 有什么区别？","slug":"asp-net-framework-和-asp-net-core-有什么区别","link":"#asp-net-framework-和-asp-net-core-有什么区别","children":[]},{"level":2,"title":".NET Core相比.NET Framework 的优点","slug":"net-core相比-net-framework-的优点","link":"#net-core相比-net-framework-的优点","children":[]},{"level":2,"title":"ADO.NET中的五个主要对象","slug":"ado-net中的五个主要对象","link":"#ado-net中的五个主要对象","children":[]},{"level":2,"title":"列举ASP.NET 页面之间传递值的几种方式。","slug":"列举asp-net-页面之间传递值的几种方式。","link":"#列举asp-net-页面之间传递值的几种方式。","children":[]},{"level":2,"title":"什么是dotNet core的startup class?","slug":"什么是dotnet-core的startup-class","link":"#什么是dotnet-core的startup-class","children":[]},{"level":2,"title":"post、get的区别？","slug":"post、get的区别","link":"#post、get的区别","children":[]},{"level":2,"title":"Application 、Cookie和 Session 两种会话有什么不同？","slug":"application-、cookie和-session-两种会话有什么不同","link":"#application-、cookie和-session-两种会话有什么不同","children":[]},{"level":2,"title":"Session有什么重大BUG，微软提出了什么方法加以解决？","slug":"session有什么重大bug-微软提出了什么方法加以解决","link":"#session有什么重大bug-微软提出了什么方法加以解决","children":[]},{"level":2,"title":"介绍几个使用过的开源的项目？","slug":"介绍几个使用过的开源的项目","link":"#介绍几个使用过的开源的项目","children":[]},{"level":2,"title":"谈谈你对MVC和三层架构的理解？","slug":"谈谈你对mvc和三层架构的理解","link":"#谈谈你对mvc和三层架构的理解","children":[]},{"level":2,"title":"什么是中间件?","slug":"什么是中间件","link":"#什么是中间件","children":[]},{"level":2,"title":"application builder的use和run方法有什么区别?","slug":"application-builder的use和run方法有什么区别","link":"#application-builder的use和run方法有什么区别","children":[]},{"level":2,"title":"dotNet core 管道里面的map拓展有什么作用?","slug":"dotnet-core-管道里面的map拓展有什么作用","link":"#dotnet-core-管道里面的map拓展有什么作用","children":[]},{"level":2,"title":"dotNet core里面的路径是如何处理的?","slug":"dotnet-core里面的路径是如何处理的","link":"#dotnet-core里面的路径是如何处理的","children":[]},{"level":2,"title":"如何在dotNet core中使用session","slug":"如何在dotnet-core中使用session","link":"#如何在dotnet-core中使用session","children":[]},{"level":2,"title":"描述一下依赖注入后的服务生命周期?","slug":"描述一下依赖注入后的服务生命周期","link":"#描述一下依赖注入后的服务生命周期","children":[]},{"level":2,"title":".NET生成 Windows、Mac、Linux 等系统客户端的方式","slug":"net生成-windows、mac、linux-等系统客户端的方式","link":"#net生成-windows、mac、linux-等系统客户端的方式","children":[]},{"level":2,"title":"Server.Transfer和Response.Redirect的区别是什么？","slug":"server-transfer和response-redirect的区别是什么","link":"#server-transfer和response-redirect的区别是什么","children":[]},{"level":2,"title":"什么是内存映射文件？","slug":"什么是内存映射文件","link":"#什么是内存映射文件","children":[]},{"level":2,"title":".Net中有几种类型的内存？","slug":"net中有几种类型的内存","link":"#net中有几种类型的内存","children":[]},{"level":2,"title":"说说IIS的工作原理？","slug":"说说iis的工作原理","link":"#说说iis的工作原理","children":[]},{"level":2,"title":"多租户系统的实现方式","slug":"多租户系统的实现方式","link":"#多租户系统的实现方式","children":[]},{"level":2,"title":".NET系统如何实现水平扩展、如何解决高并发问题","slug":"net系统如何实现水平扩展、如何解决高并发问题","link":"#net系统如何实现水平扩展、如何解决高并发问题","children":[]},{"level":2,"title":"请问如何构架一个高负载的系统？","slug":"请问如何构架一个高负载的系统","link":"#请问如何构架一个高负载的系统","children":[]},{"level":2,"title":"聊聊.NET的管道和.NET Core的中间件","slug":"聊聊-net的管道和-net-core的中间件","link":"#聊聊-net的管道和-net-core的中间件","children":[]},{"level":2,"title":".NET Core的中间件","slug":"net-core的中间件","link":"#net-core的中间件","children":[]},{"level":2,"title":"微服务的缺点","slug":"微服务的缺点","link":"#微服务的缺点","children":[]},{"level":2,"title":"领域驱动设计（DDD）以及原则和实现","slug":"领域驱动设计-ddd-以及原则和实现","link":"#领域驱动设计-ddd-以及原则和实现","children":[]},{"level":2,"title":"把一个对象赋值为null会被GC回收吗","slug":"把一个对象赋值为null会被gc回收吗","link":"#把一个对象赋值为null会被gc回收吗","children":[]}],"git":{"createdTime":1679813969000,"updatedTime":1700916639000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":9},{"name":"zhangyunpeng","email":"zhang.yunpeng@synyi.com","commits":1}]},"readingTime":{"minutes":16.27,"words":4882},"filePathRelative":"interview/dotnet.md","localizedDate":"2023年3月24日","excerpt":"<p>https://mp.weixin.qq.com/s/EyzVsV-AgHBOh543r7kttw | 【面试题解析】.NET实战面试题及答案AI补充，大家对比学习</p>\\n<p>https://mp.weixin.qq.com/s/dBwNXl_c3b0nqynansY_LA | 热心网友收集的.NET实战面试题</p>\\n<h2>.Net、ASP.Net、C#、VisualStudio之间的关系是什么？</h2>\\n<p>.Net期初指的是.Net Framework 该框架最高版本为4.8，2016年左右出了.NetCore在更新一直到5版本的时候，成为了大统一的.Net，所以在.Net5 .Net6 .Net7 .Net8 等高版本也指.NetCore，该框架提供了基础的.Net类，这些类可以被任何一种.Net编程语言调用，.Net还提供了CLR、JIT、GC等基础功能。</p>","autoDesc":true}');export{u as comp,h as data};
