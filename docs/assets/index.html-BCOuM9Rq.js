import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,o as r,d as a}from"./app-S-drW72G.js";const o={},n=a('<h2 id="说明" tabindex="-1"><a class="header-anchor" href="#说明"><span>说明</span></a></h2><p>容器的本质是一个进程，进程与进程之前的相互隔离就造成了容器与容器的相互不影响的特性。将集装箱的思想应用到了软件的打包和部署上，为不同的代码提供了基于容器标准化运输系统。</p><p>思想： 集装箱：会将所有需要的内容放到不同的集装箱中，谁需要这些环境就直接拿到 这个集装箱就可以了 标准化：1.运输的标准化2.命令的标准化3.提供的rrest的api 隔离化：docker在运行集装箱内的内容时候，会在linux的内核中，单独的开辟一片</p><p></p><p>比较出名的有： Containerd 和 Podman 和Docker</p><h2 id="镜像仓库" tabindex="-1"><a class="header-anchor" href="#镜像仓库"><span>镜像仓库</span></a></h2><p><a href="https://hub.docker.com" target="_blank" rel="noopener noreferrer">https://hub.docker.com</a></p><p>代理地址：<a href="https://dockerproxy.com/" target="_blank" rel="noopener noreferrer">https://dockerproxy.com/</a></p><h3 id="私有镜像仓库" tabindex="-1"><a class="header-anchor" href="#私有镜像仓库"><span>私有镜像仓库</span></a></h3><ul><li>Harbor <ul><li>安装文档：<a href="https://mp.weixin.qq.com/s/QVsOsG9dewX03QXbj2Ufrw" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/QVsOsG9dewX03QXbj2Ufrw</a></li></ul></li></ul><h2 id="虚拟机对比容器" tabindex="-1"><a class="header-anchor" href="#虚拟机对比容器"><span>虚拟机对比容器</span></a></h2><p>虚拟机：主要是由硬件虚拟化+内核虚拟化技术来实现，它在宿主机操作系统或硬件层的基础之上引入一层Hypervisor来虚拟出磁盘、CPU等资源，然后在虚拟出来的资源的基础之上运行Guest OS进而实现最终的虚拟机。</p><p>容器：直接在宿主机操作系统之上构建一个Docker Engine，共享宿主机操作系统内核，在此基础之上只引入了少量的Guest OS来实现。 对比： （1）虚拟机的隔离性比容器好，因为虚拟机是一种强隔离机制； （2）虚拟机比较重量级，启动时速度比较慢，消耗资源也比较多； （3）容器的隔离性不如虚拟机，它是一种软件隔离机制，但它比较轻量级，引入的东西较少，所以速度快消耗资源少；因此，在同一个物理机上能够启动的容器的数量远远多于虚拟机的数量；</p><h2 id="镜像和容器" tabindex="-1"><a class="header-anchor" href="#镜像和容器"><span>镜像和容器</span></a></h2><p>linux的内核相当于地0层，那么docker是运行在内核上面的，位于第1层，一个镜像可以构建与另一个docker镜像上，第一层的镜像我们可以理解为基础镜像，其他层的镜像我们称为父层镜像，这些镜像继承了父层镜像的属性和设置，并在dockerfile里面添加了自己的配置</p><p>docker通过镜像id来进行识别，镜像id是一个64位的十六进制的字符串，一般运行镜像，我们是通过镜像名来引用的。</p><p>docker容器通过docker镜像来创建</p><p>容器与镜像的关系类似于面向对象编程中的对象与类。</p><h2 id="资料" tabindex="-1"><a class="header-anchor" href="#资料"><span>资料</span></a></h2><p>官网：<a href="https://docs.docker.com/" target="_blank" rel="noopener noreferrer">https://docs.docker.com/</a> 从入门到实践：<a href="https://yeasy.gitbook.io/docker_practice/" target="_blank" rel="noopener noreferrer">https://yeasy.gitbook.io/docker_practice/</a> docker入门教程： <a href="https://www.cnblogs.com/ityouknow/p/8520296.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/ityouknow/p/8520296.html</a> netcore on k8s系列文章  <a href="https://www.cnblogs.com/edisonchou/p/aspnet_core_k8s_artcles_index.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/edisonchou/p/aspnet_core_k8s_artcles_index.html</a> docker-compose  <a href="https://mp.weixin.qq.com/s?__biz=MzAwMzM2MjU4MQ==&amp;mid=2247484126&amp;idx=2&amp;sn=c7c16ce36c3da7dad9f65189e0f76801&amp;chksm=9b3d18a4ac4a91b2040b3e61067173799c3a36d54704c565e61ca385a95f6ee442faf5e773b6&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1588806494793&amp;sharer_shareid=b24b68115bb61d7d2faf0d3d81a3e656&amp;key=6f25b447608369f0781636534f4cc4af9af5db2e7397592b6a1a731c5008a9603ea1d1ddf06f0b623790b74500dd1753a678406542c6786a6c92ac8117b40aec775522ad549035cee8ba38d9c1ad7d73&amp;ascene=1&amp;uin=MzE1MjEyNzg0OQ%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090072&amp;lang=zh_CN&amp;exportkey=A%2B4BvwC3Pt6bM1NWwGTUUxA%3D&amp;pass_ticket=sP%2FI4qmJbQKHOCWKyFHB1IKSnTPOmcp3L0O%2FsQQak%2FA1EUhuhyEle9zGCjw3wI1e" target="_blank" rel="noopener noreferrer">此处</a> docker部署 <a href="https://www.cnblogs.com/savorboard/p/dotnetcore-docker.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/savorboard/p/dotnetcore-docker.html</a> Netcore devops <a href="https://www.cnblogs.com/stulzq/p/8629165.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/stulzq/p/8629165.html</a></p>',20),p=[n];function c(s,i){return r(),t("div",null,p)}const h=e(o,[["render",c],["__file","index.html.vue"]]),m=JSON.parse('{"path":"/cloud/container/","title":"容器","lang":"zh-CN","frontmatter":{"title":"容器","lang":"zh-CN","date":"2021-05-17T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["cloud"],"tag":["无"],"filename":"readme","slug":"feic6p","docsId":"29454085","description":"说明 容器的本质是一个进程，进程与进程之前的相互隔离就造成了容器与容器的相互不影响的特性。将集装箱的思想应用到了软件的打包和部署上，为不同的代码提供了基于容器标准化运输系统。 思想： 集装箱：会将所有需要的内容放到不同的集装箱中，谁需要这些环境就直接拿到 这个集装箱就可以了 标准化：1.运输的标准化2.命令的标准化3.提供的rrest的api 隔离化：...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/cloud/container/"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"容器"}],["meta",{"property":"og:description","content":"说明 容器的本质是一个进程，进程与进程之前的相互隔离就造成了容器与容器的相互不影响的特性。将集装箱的思想应用到了软件的打包和部署上，为不同的代码提供了基于容器标准化运输系统。 思想： 集装箱：会将所有需要的内容放到不同的集装箱中，谁需要这些环境就直接拿到 这个集装箱就可以了 标准化：1.运输的标准化2.命令的标准化3.提供的rrest的api 隔离化：..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-21T12:34:44.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2021-05-17T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-21T12:34:44.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"容器\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-05-17T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-21T12:34:44.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"说明","slug":"说明","link":"#说明","children":[]},{"level":2,"title":"镜像仓库","slug":"镜像仓库","link":"#镜像仓库","children":[{"level":3,"title":"私有镜像仓库","slug":"私有镜像仓库","link":"#私有镜像仓库","children":[]}]},{"level":2,"title":"虚拟机对比容器","slug":"虚拟机对比容器","link":"#虚拟机对比容器","children":[]},{"level":2,"title":"镜像和容器","slug":"镜像和容器","link":"#镜像和容器","children":[]},{"level":2,"title":"资料","slug":"资料","link":"#资料","children":[]}],"git":{"createdTime":1695541854000,"updatedTime":1713702884000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":4},{"name":"zhangyunpeng","email":"zhang.yunpeng@synyi.com","commits":2}]},"readingTime":{"minutes":2.69,"words":808},"filePathRelative":"cloud/container/readme.md","localizedDate":"2021年5月17日","excerpt":"<h2>说明</h2>\\n<p>容器的本质是一个进程，进程与进程之前的相互隔离就造成了容器与容器的相互不影响的特性。将集装箱的思想应用到了软件的打包和部署上，为不同的代码提供了基于容器标准化运输系统。</p>\\n<p>思想：\\n集装箱：会将所有需要的内容放到不同的集装箱中，谁需要这些环境就直接拿到\\n这个集装箱就可以了\\n标准化：1.运输的标准化2.命令的标准化3.提供的rrest的api\\n隔离化：docker在运行集装箱内的内容时候，会在linux的内核中，单独的开辟一片</p>\\n<p></p>\\n<p>比较出名的有： Containerd 和 Podman 和Docker</p>\\n<h2>镜像仓库</h2>","autoDesc":true}');export{h as comp,m as data};
