import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as s,d as e}from"./app-D8HBJYTp.js";const t="/kbms/common/1629346436931-7827203b-7003-4c14-8397-b1ba3a67bee4.png",p="/kbms/common/1629345827282-1af8d8e0-a0c8-44e5-9e39-2de2cdec1f62.png",o={},c=e(`<h2 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍"><span>介绍</span></a></h2><p>服务端缓存，将东西存储在服务器，如果服务器缓存中有，那么就直接返回结果，并不会重新访问Action的内容。</p><p>可以对来自不同客户端的相同请求或者不支持客户端缓存的客户端进行处理，能降级服务器端的压力。</p><h2 id="操作" tabindex="-1"><a class="header-anchor" href="#操作"><span>操作</span></a></h2><p>ConfigureServices使用</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code>services<span class="token punctuation">.</span><span class="token function">AddResponseCaching</span><span class="token punctuation">(</span>options <span class="token operator">=&gt;</span>
<span class="token punctuation">{</span>
    options<span class="token punctuation">.</span>MaximumBodySize <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span><span class="token comment">//用于指定单个缓存项的最大尺寸，默认65mb</span>
    options<span class="token punctuation">.</span>UseCaseSensitivePaths <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//指定response cache是否对缓存key区分大小写</span>
    <span class="token comment">//options.SizeLimit = 1024 * 100;//用户指定response cache的最大缓存尺寸，默认是100mb</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Configure使用</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token comment">//使用cache</span>
app<span class="token punctuation">.</span><span class="token function">UseResponseCaching</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>方法上使用</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">ResponseCache</span><span class="token attribute-arguments"><span class="token punctuation">(</span>Duration <span class="token operator">=</span> <span class="token number">6000</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span> <span class="token comment">// 为了测试效果</span>
<span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">HttpGet</span></span><span class="token punctuation">]</span>
<span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>参数说明 Duration：用于指定 Response Cache 的存活时间(秒)。 Location：用于指定 Response Cache 缓存的位置，有：Any，Client,None。 NoStore：用于指定是否存储数据在客户端。 CacheProfileName：用于指定 cache profile 的名字。 VaryByHeader：用于指定Vary响应头。 VaryByQueryKeys：基于 querystring 参数来实现缓存。</p></blockquote><p>关于配置查看</p><blockquote><p>通过查看响应头：Cache-Control: public,max-age=10 可以看出来被缓存了10s 该中间件只缓存http 200的服务端响应，非200的或者一些错误是没有被缓存的。</p></blockquote><h2 id="请求示例" tabindex="-1"><a class="header-anchor" href="#请求示例"><span>请求示例</span></a></h2><p>当按照上面配置后，我通过postman发现并没有效果，经过检查发现 <img src="`+t+'" alt="image.png" loading="lazy"> 这是因为postman默认发送了不缓存的请求头，通过浏览器查看，直接用过地址栏访问该Get接口，也会自动发送不缓存的请求头，不过经过swagger调用则不会增加该请求头，会出来我们想要的结果。</p><h2 id="了解源码" tabindex="-1"><a class="header-anchor" href="#了解源码"><span>了解源码</span></a></h2><p>请求的内容使用IMemoryCache进行缓存的 <img src="'+p+'" alt="image.png" loading="lazy"></p><h2 id="鸡肋" tabindex="-1"><a class="header-anchor" href="#鸡肋"><span>鸡肋</span></a></h2><p>为什么感觉很鸡肋？ 1.无法解决恶意请求给服务器带来的压力(如果调用方给请求头设置不缓存，那么服务端缓存就不会生效)。 2.服务器端缓存还有很多限制，包括但是不限于：响应码状态为200的get或者head响应才可能被缓存，报文头不能含有Authorization、Set-Cookie等。</p>',19),i=[c];function l(r,u){return a(),s("div",null,i)}const h=n(o,[["render",l],["__file","fuwuqihuancunresponsecaching.html.vue"]]),k=JSON.parse('{"path":"/dotnet/base/huancun/fuwuqihuancunresponsecaching.html","title":"服务器缓存ResponseCaching","lang":"zh-CN","frontmatter":{"title":"服务器缓存ResponseCaching","lang":"zh-CN","date":"2023-08-20T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["dotNET"],"tag":["无"],"filename":"fuwuqihuancunresponsecaching","slug":"zisdsv","docsId":"30869209","description":"介绍 服务端缓存，将东西存储在服务器，如果服务器缓存中有，那么就直接返回结果，并不会重新访问Action的内容。 可以对来自不同客户端的相同请求或者不支持客户端缓存的客户端进行处理，能降级服务器端的压力。 操作 ConfigureServices使用 Configure使用 方法上使用 参数说明 Duration：用于指定 Response Cache...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dotnet/base/huancun/fuwuqihuancunresponsecaching.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"服务器缓存ResponseCaching"}],["meta",{"property":"og:description","content":"介绍 服务端缓存，将东西存储在服务器，如果服务器缓存中有，那么就直接返回结果，并不会重新访问Action的内容。 可以对来自不同客户端的相同请求或者不支持客户端缓存的客户端进行处理，能降级服务器端的压力。 操作 ConfigureServices使用 Configure使用 方法上使用 参数说明 Duration：用于指定 Response Cache..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://azrng.gitee.io/kbms/kbms/common/1629346436931-7827203b-7003-4c14-8397-b1ba3a67bee4.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-10-25T13:23:37.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-08-20T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-10-25T13:23:37.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"服务器缓存ResponseCaching\\",\\"image\\":[\\"https://azrng.gitee.io/kbms/kbms/common/1629346436931-7827203b-7003-4c14-8397-b1ba3a67bee4.png\\",\\"https://azrng.gitee.io/kbms/kbms/common/1629345827282-1af8d8e0-a0c8-44e5-9e39-2de2cdec1f62.png\\"],\\"datePublished\\":\\"2023-08-20T00:00:00.000Z\\",\\"dateModified\\":\\"2023-10-25T13:23:37.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"介绍","slug":"介绍","link":"#介绍","children":[]},{"level":2,"title":"操作","slug":"操作","link":"#操作","children":[]},{"level":2,"title":"请求示例","slug":"请求示例","link":"#请求示例","children":[]},{"level":2,"title":"了解源码","slug":"了解源码","link":"#了解源码","children":[]},{"level":2,"title":"鸡肋","slug":"鸡肋","link":"#鸡肋","children":[]}],"git":{"createdTime":1697962303000,"updatedTime":1698240217000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":1}]},"readingTime":{"minutes":1.98,"words":595},"filePathRelative":"dotnet/base/huancun/fuwuqihuancunresponsecaching.md","localizedDate":"2023年8月20日","excerpt":"<h2>介绍</h2>\\n<p>服务端缓存，将东西存储在服务器，如果服务器缓存中有，那么就直接返回结果，并不会重新访问Action的内容。</p>\\n<p>可以对来自不同客户端的相同请求或者不支持客户端缓存的客户端进行处理，能降级服务器端的压力。</p>\\n<h2>操作</h2>\\n<p>ConfigureServices使用</p>\\n<div class=\\"language-csharp\\" data-ext=\\"cs\\" data-title=\\"cs\\"><pre class=\\"language-csharp\\"><code>services<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">AddResponseCaching</span><span class=\\"token punctuation\\">(</span>options <span class=\\"token operator\\">=&gt;</span>\\n<span class=\\"token punctuation\\">{</span>\\n    options<span class=\\"token punctuation\\">.</span>MaximumBodySize <span class=\\"token operator\\">=</span> <span class=\\"token number\\">1024</span><span class=\\"token punctuation\\">;</span><span class=\\"token comment\\">//用于指定单个缓存项的最大尺寸，默认65mb</span>\\n    options<span class=\\"token punctuation\\">.</span>UseCaseSensitivePaths <span class=\\"token operator\\">=</span> <span class=\\"token boolean\\">true</span><span class=\\"token punctuation\\">;</span><span class=\\"token comment\\">//指定response cache是否对缓存key区分大小写</span>\\n    <span class=\\"token comment\\">//options.SizeLimit = 1024 * 100;//用户指定response cache的最大缓存尺寸，默认是100mb</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n</code></pre></div>","autoDesc":true}');export{h as comp,k as data};
