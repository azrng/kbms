import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,d as a,o as l}from"./app-BQsqMNmR.js";const t={};function n(h,i){return l(),s("div",null,i[0]||(i[0]=[a(`<div class="hint-container tip"><p class="hint-container-title">提示</p><p>注意本文是SQL执行顺序，不是MySQL内部执行流程。<br> MySQL并非像PostgreSQL（被认为是最接近 SQL 标准的数据库之一）一样严格按照SQL标准，MySQL执行引擎会根据查询的具体情况和优化策略来决定具体的执行顺序，所以SQL执行顺序是理论顺序。</p></div><h2 id="书写顺序" tabindex="-1"><a class="header-anchor" href="#书写顺序"><span>书写顺序</span></a></h2><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">...</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">...</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">join</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">...</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">on</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">...</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">...</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">group by</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">...</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">having</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">...</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">order by</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">...</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">limit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="执行顺序" tabindex="-1"><a class="header-anchor" href="#执行顺序"><span>执行顺序</span></a></h2><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">join</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">on</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">group by</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">having</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">order by</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">limit</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="sql书写顺序与执行顺序不一致的原因" tabindex="-1"><a class="header-anchor" href="#sql书写顺序与执行顺序不一致的原因"><span>SQL书写顺序与执行顺序不一致的原因？</span></a></h2><p>SQL语言设计受到了数学中的关系代数和元组演算的影响。这些数学理论中并没有考虑操作顺序，历史原因造成SQL书写上的差异。<br> 中国的语法是姓在前名在后，英文的反过来。国内是年月日，英文是月日年，文化上的差异，也是造成SQL顺序别扭的原因之一。</p><h2 id="sql执行顺序的逻辑是什么" tabindex="-1"><a class="header-anchor" href="#sql执行顺序的逻辑是什么"><span>SQL执行顺序的逻辑是什么？</span></a></h2><ol><li>from用于确定操作对象，放第一位毋庸置疑。</li><li>join和on用于关联，后面的各种处理逻辑依附于关联后内部创建的临时表，先生成数据集，才能为后续处理做基础。</li><li>where用于筛选，可以减少后续操作的数据量，提高查询性能。</li><li>group by用于对数据进行分类汇总，不放where前面，是为了避免分组后的数据被where过滤掉（分组分了个寂寞），造成算力浪费和内存资源（数据量大还是很消耗算力和内存的）的问题。</li><li>having用于对分组结果进行过滤，所以要在group by之后。</li><li>select用于决定迭代显示那些列，而不是限制只有这些列才可以参与处理，上游的各种操作（如复杂的where条件）不能受select字段的影响，这也是where后面跟的字段，不必在select出现的原因。select的本意是处理数据后仅仅返回这些字段，而不是决定只有这些字段进行数据处理，所以必定要放偏后的位置。</li><li>order by用于结果进行排序，肯定是结果处理后才排序的，理由和group by相似。</li><li>limit用于限制返回结果的行数和偏移量，必须是等筛选完分组完拍完序之后再限制，否则可能导致结果有误。</li></ol><h2 id="为什么sql执行不是先group-by再where" tabindex="-1"><a class="header-anchor" href="#为什么sql执行不是先group-by再where"><span>为什么SQL执行不是先group by再where？</span></a></h2><p>先分组再筛选，逻辑上说的过去，相当于整理好数据再筛选，类似于创建索引和使用索引的过程，这也是问题的由来。<br> 如果group by放在where之前执行，则需要对大量数据进行分组，分组后还要对每个组进行筛选，事先分组好的部分数据又被过滤掉了，造成算力和内存浪费，可能导致内存不足或者性能问题，这不是一个优秀的选择，倒不如先筛选过滤大量数据，然后对少量数据分组。</p><h2 id="为什么sql执行要先select再order-by" tabindex="-1"><a class="header-anchor" href="#为什么sql执行要先select再order-by"><span>为什么SQL执行要先select再order by？</span></a></h2><p>尝试select field2 from table order by field1，select后面没跟order by后面的field1也不报错。<br> 根据结果反推：select影响不到order by，所以先order by在select也说的过去。<br> 但是：select字段的别名可以在order by中使用，如果反过来就达不到这样的效果了。</p><h2 id="为什么mysql的where比having效率更高" tabindex="-1"><a class="header-anchor" href="#为什么mysql的where比having效率更高"><span>为什么MySQL的where比having效率更高？</span></a></h2><p>mysql执行时，先执行from用于定位操作对象，然后就是where，可能百万条的数据经过where之后只剩下几十条，然后在进行之后的操作。而group by比where多了一个环节。</p><h2 id="聚合函数参与筛选条件-为什么只能用having" tabindex="-1"><a class="header-anchor" href="#聚合函数参与筛选条件-为什么只能用having"><span>聚合函数参与筛选条件，为什么只能用having？</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>//报错，Invalid use of group function</span></span>
<span class="line"><span>select field from table where avg(field) &gt; 2</span></span>
<span class="line"><span>//需要修改为</span></span>
<span class="line"><span>select field from table group by field having avg(field) &gt; 2</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>聚合函数（常见的avg、sum、count、min、max）需要在分组之后才能计算，执行到where时还没有分组，此时对分组进行数据处理，所以报错。相当于要喝一口还没生产的可乐，不符合事物的发展规律。</p><h2 id="为什么使用聚合函数有分组的前提" tabindex="-1"><a class="header-anchor" href="#为什么使用聚合函数有分组的前提"><span>为什么使用聚合函数有分组的前提？</span></a></h2><p>所谓聚合函数，就是对一组数据进行汇总计算，所以有分组的前提。即便没有使用group by显式声明，SQL也会对上游过来的数据集进行默认分组（隐式分组）。</p><h2 id="为什么字段别名不能在where中使用" tabindex="-1"><a class="header-anchor" href="#为什么字段别名不能在where中使用"><span>为什么字段别名不能在where中使用？</span></a></h2><p>where执行在select之前，此时别名未生效。</p><h2 id="为什么group-by和having执行顺序优先于select-却可以使用字段别名" tabindex="-1"><a class="header-anchor" href="#为什么group-by和having执行顺序优先于select-却可以使用字段别名"><span>为什么group by和having执行顺序优先于select，却可以使用字段别名？</span></a></h2><p>可以肯定进行了预加载，不然一定找不到别名，会报错的。<br> 参考官网：<a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-handling.html" target="_blank" rel="noopener noreferrer">https://dev.mysql.com/doc/refman/8.0/en/group-by-handling.html</a><br> 文章说：标准 SQL 也不允许在子句中使用别名，MySQL扩展了标准SQL以允许别名。标准 SQL 不允许在子句中使用别名，MySQL扩展了标准SQL，详细的底层原理，文档并未说明。</p><h2 id="来源" tabindex="-1"><a class="header-anchor" href="#来源"><span>来源</span></a></h2><p>转自：小松聊PHP进阶</p><p>链接：<a href="https://www.cnblogs.com/phpphp/p/18013733" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/phpphp/p/18013733</a></p>`,27)]))}const d=e(t,[["render",n],["__file","executeOrder.html.vue"]]),k=JSON.parse('{"path":"/dataBase/commonOperator/executeOrder.html","title":"执行顺序","lang":"zh-CN","frontmatter":{"title":"执行顺序","lang":"zh-CN","date":"2024-02-25T00:00:00.000Z","publish":true,"author":"小松聊PHP进阶","isOriginal":false,"category":["dataBase"],"tag":["执行"],"description":"提示 注意本文是SQL执行顺序，不是MySQL内部执行流程。 MySQL并非像PostgreSQL（被认为是最接近 SQL 标准的数据库之一）一样严格按照SQL标准，MySQL执行引擎会根据查询的具体情况和优化策略来决定具体的执行顺序，所以SQL执行顺序是理论顺序。 书写顺序 执行顺序 SQL书写顺序与执行顺序不一致的原因？ SQL语言设计受到了数学中...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dataBase/commonOperator/executeOrder.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"执行顺序"}],["meta",{"property":"og:description","content":"提示 注意本文是SQL执行顺序，不是MySQL内部执行流程。 MySQL并非像PostgreSQL（被认为是最接近 SQL 标准的数据库之一）一样严格按照SQL标准，MySQL执行引擎会根据查询的具体情况和优化策略来决定具体的执行顺序，所以SQL执行顺序是理论顺序。 书写顺序 执行顺序 SQL书写顺序与执行顺序不一致的原因？ SQL语言设计受到了数学中..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-19T14:59:33.000Z"}],["meta",{"property":"article:author","content":"小松聊PHP进阶"}],["meta",{"property":"article:tag","content":"执行"}],["meta",{"property":"article:published_time","content":"2024-02-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-19T14:59:33.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"执行顺序\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-02-25T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-19T14:59:33.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小松聊PHP进阶\\"}]}"]]},"headers":[{"level":2,"title":"书写顺序","slug":"书写顺序","link":"#书写顺序","children":[]},{"level":2,"title":"执行顺序","slug":"执行顺序","link":"#执行顺序","children":[]},{"level":2,"title":"SQL书写顺序与执行顺序不一致的原因？","slug":"sql书写顺序与执行顺序不一致的原因","link":"#sql书写顺序与执行顺序不一致的原因","children":[]},{"level":2,"title":"SQL执行顺序的逻辑是什么？","slug":"sql执行顺序的逻辑是什么","link":"#sql执行顺序的逻辑是什么","children":[]},{"level":2,"title":"为什么SQL执行不是先group by再where？","slug":"为什么sql执行不是先group-by再where","link":"#为什么sql执行不是先group-by再where","children":[]},{"level":2,"title":"为什么SQL执行要先select再order by？","slug":"为什么sql执行要先select再order-by","link":"#为什么sql执行要先select再order-by","children":[]},{"level":2,"title":"为什么MySQL的where比having效率更高？","slug":"为什么mysql的where比having效率更高","link":"#为什么mysql的where比having效率更高","children":[]},{"level":2,"title":"聚合函数参与筛选条件，为什么只能用having？","slug":"聚合函数参与筛选条件-为什么只能用having","link":"#聚合函数参与筛选条件-为什么只能用having","children":[]},{"level":2,"title":"为什么使用聚合函数有分组的前提？","slug":"为什么使用聚合函数有分组的前提","link":"#为什么使用聚合函数有分组的前提","children":[]},{"level":2,"title":"为什么字段别名不能在where中使用？","slug":"为什么字段别名不能在where中使用","link":"#为什么字段别名不能在where中使用","children":[]},{"level":2,"title":"为什么group by和having执行顺序优先于select，却可以使用字段别名？","slug":"为什么group-by和having执行顺序优先于select-却可以使用字段别名","link":"#为什么group-by和having执行顺序优先于select-却可以使用字段别名","children":[]},{"level":2,"title":"来源","slug":"来源","link":"#来源","children":[]}],"git":{"createdTime":1708876415000,"updatedTime":1721401173000,"contributors":[{"name":"azrng","username":"azrng","email":"itzhangyunpeng@163.com","commits":2}]},"readingTime":{"minutes":4.46,"words":1338},"filePathRelative":"dataBase/commonOperator/executeOrder.md","localizedDate":"2024年2月25日","excerpt":"<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">提示</p>\\n<p>注意本文是SQL执行顺序，不是MySQL内部执行流程。<br>\\nMySQL并非像PostgreSQL（被认为是最接近 SQL 标准的数据库之一）一样严格按照SQL标准，MySQL执行引擎会根据查询的具体情况和优化策略来决定具体的执行顺序，所以SQL执行顺序是理论顺序。</p>\\n</div>\\n<h2>书写顺序</h2>\\n<div class=\\"language-sql line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"sql\\" data-title=\\"sql\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">select</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">...</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">from</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">...</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">join</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">...</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">on</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">...</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">where</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">...</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">group by</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">...</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">having</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">...</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">order by</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">...</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">limit</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">...</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{d as comp,k as data};
