import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,o,b as e,e as t}from"./app-CX6H2AQa.js";const i={},c=e("p",null,[t("http头域列表与解释之request篇 HTTP 头域是HTTP协议中请求(request)和响应(response)中的头部信息,其实就是HTTP通信的操作参数，告诉web服务器和浏览器怎样处理这个通信。HTTP头从一个请求信息或者响应信息的第二行开始（第一行是请求行或者响应行），以两个CR-LF字符组结束（CR：回车符,\\r，LF：换行符\\n）而每个HTTP头是字符串形式的，用冒号分割的键值对，多个HTTP头之间用CR-LF字符组隔开。 某些http头可以有注释，例如user-agent,server,via。但这些注释会被服务器或者浏览器忽略IETF组织已经将一些核心的HTTP头定义在RFC2616规范中，这些HTTP头是每个基于HTTP协议的软件必须实现的，而其他一些更新和扩展的头域也必须被基于HTTP的软件实现。当然，各个软件也可以定义自己的头域。 另一方面，RFC2616规范中并没有限制每个HTTP头的长度，或者限制HTTP头的数量，但出于性能和安全的考虑，多数服务器都会自己作规定，例如apache2.3 就规定每个HTTP头不能超过8190个字节，每个请求不能超过100个HTTP头。 以下来看看发送一个请求(request)时候，可能包含的各个HTTP头和它的解释。 1.标准请求头 Accept : 浏览器（或者其他基于HTTP的客户端程序）可以接收的内容类型（Content-types）,例如 Accept: text/plain   Accept-Charset：浏览器能识别的字符集，例如 Accept-Charset: utf-8   Accept-Encoding：浏览器可以处理的编码方式，注意这里的编码方式有别于字符集，这里的编码方式通常指gzip,deflate等。例如 Accept-Encoding: gzip, deflate   Accept-Language：浏览器接收的语言，其实也就是用户在什么语言地区，例如简体中文的就是 Accept-Language: zh-CN   Accept-Datetime：（这个暂时没搞清楚什么意思）   Authorization：在HTTP中，服务器可以对一些资源进行认证保护，如果你要访问这些资源，就要提供用户名和密码，这个用户名和密码就是在Authorization头中附带的，格式是“username:password”字符串的base64编码，例如：Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ"),e("mark",null,"中，basic指使用basic认证方式，　QWxhZGRpbjpvcGVuIHNlc2FtZQ"),t("使用base64解码就是Aladdin:open sesame   Cache-Control：这个指令在request和response中都有，用来指示缓存系统（服务器上的，或者浏览器上的）应该怎样处理缓存，因为这个头域比较重要，特别是希望使用缓　存改善性能的时候，内容也较多，所以我想在下一篇博文中主要介绍一下。   Connection：告诉服务器这个user agent（通常就是浏览器）想要使用怎样的连接方式。值有keep-alive和close。http1.1默认是keep-alive。keep-alive就是浏览器和服务器　的通信连接会被持续保存，不会马上关闭，而close就会在response后马上关闭。但这里要注意一点，我们说HTTP是无状态的，跟这个是否keep-alive没有关系，不要认为keep-alive是对HTTP无状态的特性的改进。   Cookie：浏览器向服务器发送请求时发送cookie，或者服务器向浏览器附加cookie，就是将cookie附近在这里的。例如：Cookie:user=admin   Content-Length：一个请求的请求体的内存长度，单位为字节(byte)。请求体是指在HTTP头结束后，两个CR-LF字符组之后的内容，常见的有POST提交的表单数据，这个Content-Length并不包含请求行和HTTP头的数据长度。   Content-MD5：使用base64进行了编码的请求体的MD5校验和。例如：Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==   Content-Type：请求体中的内容的mime类型。通常只会用在POST和PUT方法的请求中。例如：Content-Type: application/x-www-form-urlencoded   Date：发送请求时的GMT时间。例如：Date: Tue, 15 Nov 1994 08:12:31 GMT   Expect：指示需要使用服务器某些特殊的功能。（这个我不是很清楚）   From：发送这个请求的用户的email地址。例如：From: user@example.com   Host：被服务器的域名或IP地址，如果不是通用端口，还包含该端口号，例如：Host: www.some.com:182   If-Match :通常用在使用PUT方法对服务器资源进行更新的请求中，意思就是，询问服务器，现在正在请求的资源的tag和这个If-Match的tag相不相同，如果相同，则证明服务器上的这个资源还是旧的，现在可以被更新，如果不相同，则证明该资源被更新过，现在就不用再更新了（否则有可能覆盖掉其他人所做的更改）。   If-Modified-Since：询问服务器现在正在请求的资源在某个时间以来有没有被修改过，如果没有，服务器则返回304状态来告诉浏览器使用浏览器自己本地的缓存，如果有修改过，则返回200，并发送新的资源（当然如果资源不存在，则返回404。）   If-None-Match：和If-Modified-Since用意差不多，不过不是根据时间来确定，而是根据一个叫ETag的东西来确定。关于etag我想在下一篇博客介绍一下。   If-Range：告诉服务器如果这个资源没有更改过(根据If-Range后面给出的Etag判断)，就发送这个资源中在浏览器缺少了的某些部分给浏览器，如果该资源以及被修改过，则将整个资源重新发送一份给浏览器。   If-Unmodified-Since：询问服务器现在正在请求的资源在某个时刻以来是否没有被修改过。   Max-Forwards：限制请求信息在代理服务器或网关中向前传递的次数。   Pragma：好像只有一个值，就是:no-cache。Pragma:no-cache 与cache-control:no-cache相同，只不过cache-control:no-cache是http1.1专门指定的，而Pragma:no-cache可以在http1.0和1.1中使用   Proxy-Authorization：连接到某个代理时使用的身份认证信息，跟Authorization头差不多。例如：Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==   Range：在HTTP头中，”Range”字眼都表示“资源的byte形式数据的顺序排列，并且取其某一段数据”的意思。Range头就是表示请求资源的从某个数值到某个数值间的数据，例如：Range: bytes=500-999 就是表示请求资源从500到999byte的数据。数据的分段下载和多线程下载就是利用这个实现的。   Referer：指当前请求的URL是在什么地址引用的。例如在www.a.com/index.html页面中点击一个指向www.b.com的超链接，那么，这个www.b.com的请求中的Referer就是www.a.com/index.html。通常我们见到的图片防盗链就是用这个实现的。   Upgrade：请求服务器更新至另外一个协议，例如：Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11   User-Agent：通常就是用户的浏览器相关信息。例如：User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/12.0   Via：用来记录一个请求经过了哪些代理或网关才被送到目标服务器上。例如一个请求从浏览器出发(假设使用http/1.0)，发送给名为 SomeProxy的内部代理，然后被转发至www.somenet.com的公共代理（使用http/1.1），最后被转发至目标服务器www.someweb.com，那么在someweb.com中收到的via 头应该是：via:1.0 someProxy 1.1 [www.someweb.com(apache](http://www.someweb.com(apache) 1.1)   Warning：记录一些警告信息。 2.通用但是并非标准的http头 X-Requested-With：主要是用来识别ajax请求，很多javascript框架会发送这个头域（值为XMLHttpRequest）   DNT : DO NOT TRACK的缩写，要求服务器程序不要跟踪记录用户信息。DNT: 1 (开启DNT) DNT: 0 (关闭DNT)火狐，safari,IE9都支持这个头域，并且于2011年3月7日被提交至IETF组织实现标准化   X-Forwarded-For : 记录一个请求从客户端出发到目标服务器过程中经历的代理，或者负载平衡设备的IP。   X-Forwarded-Proto：记录一个请求一个请求最初从浏览器发出时候，是使用什么协议。因为有可能当一个请求最初和反向代理通信时，是使用https，但反向代理和服务器通信时改变成http协议，这个时候，X-Forwarded-Proto的值应该是https   Front-End-Https：微软使用与其负载平衡的一个头域。")],-1),r=[c];function p(s,T){return o(),a("div",null,r)}const l=n(i,[["render",p],["__file","liulanqiqingqiutou.html.vue"]]),g=JSON.parse('{"path":"/web/webkaifa/changedaimajiexi/liulanqiqingqiutou.html","title":"浏览器请求头","lang":"zh-CN","frontmatter":{"title":"浏览器请求头","lang":"zh-CN","date":"2023-08-19T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["web"],"tag":["无"],"filename":"liulanqiqingqiutou","slug":"zhmdtf","docsId":"29633634","description":"http头域列表与解释之request篇 HTTP 头域是HTTP协议中请求(request)和响应(response)中的头部信息,其实就是HTTP通信的操作参数，告诉web服务器和浏览器怎样处理这个通信。HTTP头从一个请求信息或者响应信息的第二行开始（第一行是请求行或者响应行），以两个CR-LF字符组结束（CR：回车符,\\\\r，LF：换行符\\\\n）而...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/web/webkaifa/changedaimajiexi/liulanqiqingqiutou.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"浏览器请求头"}],["meta",{"property":"og:description","content":"http头域列表与解释之request篇 HTTP 头域是HTTP协议中请求(request)和响应(response)中的头部信息,其实就是HTTP通信的操作参数，告诉web服务器和浏览器怎样处理这个通信。HTTP头从一个请求信息或者响应信息的第二行开始（第一行是请求行或者响应行），以两个CR-LF字符组结束（CR：回车符,\\\\r，LF：换行符\\\\n）而..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-08-19T10:58:50.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-08-19T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-08-19T10:58:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"浏览器请求头\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-08-19T00:00:00.000Z\\",\\"dateModified\\":\\"2023-08-19T10:58:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[],"git":{"createdTime":1692442730000,"updatedTime":1692442730000,"contributors":[{"name":"zhangyunpeng","email":"zhang.yunpeng@synyi.com","commits":1}]},"readingTime":{"minutes":7.38,"words":2213},"filePathRelative":"web/webkaifa/changedaimajiexi/liulanqiqingqiutou.md","localizedDate":"2023年8月19日","excerpt":"<p>http头域列表与解释之request篇\\nHTTP 头域是HTTP协议中请求(request)和响应(response)中的头部信息,其实就是HTTP通信的操作参数，告诉web服务器和浏览器怎样处理这个通信。HTTP头从一个请求信息或者响应信息的第二行开始（第一行是请求行或者响应行），以两个CR-LF字符组结束（CR：回车符,\\\\r，LF：换行符\\\\n）而每个HTTP头是字符串形式的，用冒号分割的键值对，多个HTTP头之间用CR-LF字符组隔开。\\n某些http头可以有注释，例如user-agent,server,via。但这些注释会被服务器或者浏览器忽略IETF组织已经将一些核心的HTTP头定义在RFC2616规范中，这些HTTP头是每个基于HTTP协议的软件必须实现的，而其他一些更新和扩展的头域也必须被基于HTTP的软件实现。当然，各个软件也可以定义自己的头域。\\n另一方面，RFC2616规范中并没有限制每个HTTP头的长度，或者限制HTTP头的数量，但出于性能和安全的考虑，多数服务器都会自己作规定，例如apache2.3 就规定每个HTTP头不能超过8190个字节，每个请求不能超过100个HTTP头。\\n以下来看看发送一个请求(request)时候，可能包含的各个HTTP头和它的解释。\\n1.标准请求头\\nAccept : 浏览器（或者其他基于HTTP的客户端程序）可以接收的内容类型（Content-types）,例如 Accept: text/plain\\n&nbsp;\\nAccept-Charset：浏览器能识别的字符集，例如 Accept-Charset: utf-8\\n&nbsp;\\nAccept-Encoding：浏览器可以处理的编码方式，注意这里的编码方式有别于字符集，这里的编码方式通常指gzip,deflate等。例如 Accept-Encoding: gzip, deflate\\n&nbsp;\\nAccept-Language：浏览器接收的语言，其实也就是用户在什么语言地区，例如简体中文的就是 Accept-Language: zh-CN\\n&nbsp;\\nAccept-Datetime：（这个暂时没搞清楚什么意思）\\n&nbsp;\\nAuthorization：在HTTP中，服务器可以对一些资源进行认证保护，如果你要访问这些资源，就要提供用户名和密码，这个用户名和密码就是在Authorization头中附带的，格式是“username:password”字符串的base64编码，例如：Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ<mark>中，basic指使用basic认证方式，　QWxhZGRpbjpvcGVuIHNlc2FtZQ</mark>使用base64解码就是Aladdin:open sesame\\n&nbsp;\\nCache-Control：这个指令在request和response中都有，用来指示缓存系统（服务器上的，或者浏览器上的）应该怎样处理缓存，因为这个头域比较重要，特别是希望使用缓　存改善性能的时候，内容也较多，所以我想在下一篇博文中主要介绍一下。\\n&nbsp;\\nConnection：告诉服务器这个user agent（通常就是浏览器）想要使用怎样的连接方式。值有keep-alive和close。http1.1默认是keep-alive。keep-alive就是浏览器和服务器　的通信连接会被持续保存，不会马上关闭，而close就会在response后马上关闭。但这里要注意一点，我们说HTTP是无状态的，跟这个是否keep-alive没有关系，不要认为keep-alive是对HTTP无状态的特性的改进。\\n&nbsp;\\nCookie：浏览器向服务器发送请求时发送cookie，或者服务器向浏览器附加cookie，就是将cookie附近在这里的。例如：Cookie:user=admin\\n&nbsp;\\nContent-Length：一个请求的请求体的内存长度，单位为字节(byte)。请求体是指在HTTP头结束后，两个CR-LF字符组之后的内容，常见的有POST提交的表单数据，这个Content-Length并不包含请求行和HTTP头的数据长度。\\n&nbsp;\\nContent-MD5：使用base64进行了编码的请求体的MD5校验和。例如：Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==\\n&nbsp;\\nContent-Type：请求体中的内容的mime类型。通常只会用在POST和PUT方法的请求中。例如：Content-Type: application/x-www-form-urlencoded\\n&nbsp;\\nDate：发送请求时的GMT时间。例如：Date: Tue, 15 Nov 1994 08:12:31 GMT\\n&nbsp;\\nExpect：指示需要使用服务器某些特殊的功能。（这个我不是很清楚）\\n&nbsp;\\nFrom：发送这个请求的用户的email地址。例如：From: user@example.com\\n&nbsp;\\nHost：被服务器的域名或IP地址，如果不是通用端口，还包含该端口号，例如：Host: www.some.com:182\\n&nbsp;\\nIf-Match :通常用在使用PUT方法对服务器资源进行更新的请求中，意思就是，询问服务器，现在正在请求的资源的tag和这个If-Match的tag相不相同，如果相同，则证明服务器上的这个资源还是旧的，现在可以被更新，如果不相同，则证明该资源被更新过，现在就不用再更新了（否则有可能覆盖掉其他人所做的更改）。\\n&nbsp;\\nIf-Modified-Since：询问服务器现在正在请求的资源在某个时间以来有没有被修改过，如果没有，服务器则返回304状态来告诉浏览器使用浏览器自己本地的缓存，如果有修改过，则返回200，并发送新的资源（当然如果资源不存在，则返回404。）\\n&nbsp;\\nIf-None-Match：和If-Modified-Since用意差不多，不过不是根据时间来确定，而是根据一个叫ETag的东西来确定。关于etag我想在下一篇博客介绍一下。\\n&nbsp;\\nIf-Range：告诉服务器如果这个资源没有更改过(根据If-Range后面给出的Etag判断)，就发送这个资源中在浏览器缺少了的某些部分给浏览器，如果该资源以及被修改过，则将整个资源重新发送一份给浏览器。\\n&nbsp;\\nIf-Unmodified-Since：询问服务器现在正在请求的资源在某个时刻以来是否没有被修改过。\\n&nbsp;\\nMax-Forwards：限制请求信息在代理服务器或网关中向前传递的次数。\\n&nbsp;\\nPragma：好像只有一个值，就是:no-cache。Pragma:no-cache 与cache-control:no-cache相同，只不过cache-control:no-cache是http1.1专门指定的，而Pragma:no-cache可以在http1.0和1.1中使用\\n&nbsp;\\nProxy-Authorization：连接到某个代理时使用的身份认证信息，跟Authorization头差不多。例如：Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\\n&nbsp;\\nRange：在HTTP头中，”Range”字眼都表示“资源的byte形式数据的顺序排列，并且取其某一段数据”的意思。Range头就是表示请求资源的从某个数值到某个数值间的数据，例如：Range: bytes=500-999 就是表示请求资源从500到999byte的数据。数据的分段下载和多线程下载就是利用这个实现的。\\n&nbsp;\\nReferer：指当前请求的URL是在什么地址引用的。例如在www.a.com/index.html页面中点击一个指向www.b.com的超链接，那么，这个www.b.com的请求中的Referer就是www.a.com/index.html。通常我们见到的图片防盗链就是用这个实现的。\\n&nbsp;\\nUpgrade：请求服务器更新至另外一个协议，例如：Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11\\n&nbsp;\\nUser-Agent：通常就是用户的浏览器相关信息。例如：User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/12.0\\n&nbsp;\\nVia：用来记录一个请求经过了哪些代理或网关才被送到目标服务器上。例如一个请求从浏览器出发(假设使用http/1.0)，发送给名为 SomeProxy的内部代理，然后被转发至www.somenet.com的公共代理（使用http/1.1），最后被转发至目标服务器www.someweb.com，那么在someweb.com中收到的via 头应该是：via:1.0 someProxy 1.1 [www.someweb.com(apache](http://www.someweb.com(apache) 1.1)\\n&nbsp;\\nWarning：记录一些警告信息。\\n2.通用但是并非标准的http头\\nX-Requested-With：主要是用来识别ajax请求，很多javascript框架会发送这个头域（值为XMLHttpRequest）\\n&nbsp;\\nDNT : DO NOT TRACK的缩写，要求服务器程序不要跟踪记录用户信息。DNT: 1 (开启DNT) DNT: 0 (关闭DNT)火狐，safari,IE9都支持这个头域，并且于2011年3月7日被提交至IETF组织实现标准化\\n&nbsp;\\nX-Forwarded-For : 记录一个请求从客户端出发到目标服务器过程中经历的代理，或者负载平衡设备的IP。\\n&nbsp;\\nX-Forwarded-Proto：记录一个请求一个请求最初从浏览器发出时候，是使用什么协议。因为有可能当一个请求最初和反向代理通信时，是使用https，但反向代理和服务器通信时改变成http协议，这个时候，X-Forwarded-Proto的值应该是https\\n&nbsp;\\nFront-End-Https：微软使用与其负载平衡的一个头域。</p>","autoDesc":true}');export{l as comp,g as data};
