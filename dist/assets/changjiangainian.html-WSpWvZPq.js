import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,e as n,o as t}from"./app-SmdjEsew.js";const h="/kbms/common/1614502329036-0e01cbf5-313b-46c5-ae32-0b8c26ba1a6a.png",e="/kbms/common/1614503448828-88fe6191-1c89-48e7-8c20-f83417caace2.png",l={};function k(p,s){return t(),a("div",null,s[0]||(s[0]=[n('<h2 id="缓存穿透" tabindex="-1"><a class="header-anchor" href="#缓存穿透"><span>缓存穿透</span></a></h2><h3 id="描述" tabindex="-1"><a class="header-anchor" href="#描述"><span>描述</span></a></h3><p>大并发查询不存在的key，导致每一次请求数据都从缓存中获取不到，结果请求到了数据库服务器，可是数据库服务器也没有数据，这就导致每次请求都会到数据库服务器。如果在高并发场景下，会导致数据库服务器压力增大，最终系统可能崩溃。<br><img src="'+h+`" alt="" loading="lazy"></p><blockquote><p>绿色块代表有缓存数据，粉色块代表缓存中没有数据；绿色箭头代表直接从缓存中获取数据，黄色箭头代表穿过缓存从数据库中获取数据，但是不一定有。</p></blockquote><h3 id="常见解决措施" tabindex="-1"><a class="header-anchor" href="#常见解决措施"><span>常见解决措施</span></a></h3><h4 id="缓存空值" tabindex="-1"><a class="header-anchor" href="#缓存空值"><span>缓存空值</span></a></h4><p>如果在数据库中没有获取到数据，那么就将其对应键的空值进行缓存，并设置较短的过期时间。</p><p>示例</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-csharp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">var</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> user</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> _cache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">GetOrCreate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;user716&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, (</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) =&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    //就算查询不到，那么就把null存到缓存，防止缓存穿透</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    var</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> bb</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> Summaries</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">FirstOrDefault</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> =&gt; </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">t</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;716&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> bb</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>优点：在过期时间内直接通过缓存返回空值，从而避免数据库压力。<br> 缺点：<br> 1.消耗redis内存，如果攻击者每次都换非常规的键请求，每次都缓存大redis中，大量的空数据占用内存；<br> 2.数据不一致，如果是正常数据，起初没有数据，然后将空值缓存，并设置短暂的过期时间；如果在过期时间内正常维护了对应的数据，这个时候取到的还是空值，并没有去数据库获取维护后新的数据，导致数据不一致。</p><h4 id="布隆过滤器" tabindex="-1"><a class="header-anchor" href="#布隆过滤器"><span>布隆过滤器</span></a></h4><p>加一层过滤器进行拦截，判断请求对应都键是否iu在过滤器中，如果不在就直接返回，不去请求数据库，也不用缓存控制。而布隆过滤器采用bit位都形式标识对应键是否存在，可以用极少都空间标识超大量都数据。<br> 缺点：<br> 布隆过滤器可以盘单数据一定不在过滤器中，而对于存在的判断有误判率，因为Hash算法存在冲突的情况。</p><h2 id="缓存雪崩" tabindex="-1"><a class="header-anchor" href="#缓存雪崩"><span>缓存雪崩</span></a></h2><h3 id="简要描述" tabindex="-1"><a class="header-anchor" href="#简要描述"><span>简要描述</span></a></h3><p>缓存雪崩指突然缓存层不可用，导致大量请求直接到数据库，最终数据库压力过大可能导致系统崩溃，缓存层不可用指以下两方面：</p><ul><li>缓存服务器宕机，系统将请求打到数据库。</li><li>缓存数据突然大范围集中过期失效，导致大量请求打到数据库重新加载数据；原有缓存失效，新缓存未到。</li></ul><figure><img src="`+e+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>绿色块代表有缓存数据，粉色块代表缓存中没有数据，白色块代表大范围失效的缓存数据，绿色箭头代表直接从缓存中获取数据，黄色箭头代表穿过缓存从数据库中查数据。</p></blockquote><h3 id="常用解决措施" tabindex="-1"><a class="header-anchor" href="#常用解决措施"><span>常用解决措施</span></a></h3><ul><li>缓存预热：在高峰期还没到来时候，提前将热数据加载到缓存中，避免高峰期来临数据库压力过大。</li><li>均匀设置过期时间：针对不同的热点数据，将过期时间加上一个随机值，让过期时间不集中在一个点，从而减少很大一部分数据库压力</li><li>多级缓存：除了使用redis缓存，还可以根据业务增加一些热点数据的其他缓存，比如内存缓存，可以将各级的缓存有效期分开，缓解数据库压力。</li><li>限流、降级：如果压力过大，避免将系统搞崩，可以增加一些限流手段，不管是中间件还是消息队列等，主要保证系统的可用。</li><li>对于缓存层整体崩掉的情况：使用高可用架构，比如之前说的主从服务、哨兵、集群，根据需要进行对应架构，保证缓存层不崩溃。</li></ul><h2 id="缓存击穿" tabindex="-1"><a class="header-anchor" href="#缓存击穿"><span>缓存击穿</span></a></h2><h3 id="简要描述-1" tabindex="-1"><a class="header-anchor" href="#简要描述-1"><span>简要描述</span></a></h3><p>击穿是针对某一个key缓存，雪崩是很多key。某个key失效时候，正好有大量的并发请求访问该key。<br> 通常使用缓存 + 过期时间的策略来帮助我们加速接口的访问速度，减少了后端负载，同时保证功能的更新，一般情况下这种模式已经基本满足要求了。<br> 但如下问题若同时出现，可能对系统致命：</p><ul><li>为热点key，访问量非常大</li><li>缓存的构建是需要时间（可能是个复杂过程，例如复杂SQL、多次I/O、多个接口依赖）</li></ul><h3 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案"><span>解决方案</span></a></h3><p>在缓存失效时候(判断拿出来的值为空)，不是立即去数据库查询加载db，而是先去set一个互斥值。当操作返回成功时候，再去查询数据库的操作并返回设置缓存，否则就重试整个get缓存的方法。</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-csharp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key) {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">      String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">      if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) { </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 缓存已过期</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">          // 设置超时，防止del失败时，下次缓存过期一直不能load db</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">		  if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setnx</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">key_mutex</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 60</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) { </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 设置成功</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">               value</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> db</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">                      redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">expire_secs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">                      redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">del</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">key_mutex</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">          } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            		// 其他线程已load db并回设缓存，重试获取缓存即可</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">                    sleep</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">50</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">                    get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//重试</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">          }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 缓存未过期</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            return</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;      </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="缓存预热" tabindex="-1"><a class="header-anchor" href="#缓存预热"><span>缓存预热</span></a></h2><p>系统上线后，将相关的缓存数据直接加载到缓存系统中，这样子就避免在用户请求的时候，先查询数据库然后将数据缓存的问题。</p><h3 id="解决思路" tabindex="-1"><a class="header-anchor" href="#解决思路"><span>解决思路</span></a></h3><p>1.写一个缓存刷新页面，上线时候手动操作下<br> 2.数据量不大，可以现在项目启动的时候自动进行加载。<br> 3.定时刷新缓存。</p><blockquote><p>参考文档：<a href="https://mp.weixin.qq.com/s/42DEZm0TMBR6a75LtpgVIw" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/42DEZm0TMBR6a75LtpgVIw</a></p></blockquote>`,32)]))}const g=i(l,[["render",k]]),c=JSON.parse('{"path":"/dotnet/base/huancun/changjiangainian.html","title":"常见概念","lang":"zh-CN","frontmatter":{"title":"常见概念","lang":"zh-CN","date":"2023-08-20T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["dotNET"],"tag":["无"],"filename":"changjiangainian","slug":"nv39ny","docsId":"32068992","description":"缓存穿透 描述 大并发查询不存在的key，导致每一次请求数据都从缓存中获取不到，结果请求到了数据库服务器，可是数据库服务器也没有数据，这就导致每次请求都会到数据库服务器。如果在高并发场景下，会导致数据库服务器压力增大，最终系统可能崩溃。 绿色块代表有缓存数据，粉色块代表缓存中没有数据；绿色箭头代表直接从缓存中获取数据，黄色箭头代表穿过缓存从数据库中获取...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"常见概念\\",\\"image\\":[\\"https://azrng.gitee.io/kbms/kbms/common/1614502329036-0e01cbf5-313b-46c5-ae32-0b8c26ba1a6a.png\\",\\"https://azrng.gitee.io/kbms/kbms/common/1614503448828-88fe6191-1c89-48e7-8c20-f83417caace2.png\\"],\\"datePublished\\":\\"2023-08-20T00:00:00.000Z\\",\\"dateModified\\":\\"2023-10-25T13:23:37.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"],["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dotnet/base/huancun/changjiangainian.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"常见概念"}],["meta",{"property":"og:description","content":"缓存穿透 描述 大并发查询不存在的key，导致每一次请求数据都从缓存中获取不到，结果请求到了数据库服务器，可是数据库服务器也没有数据，这就导致每次请求都会到数据库服务器。如果在高并发场景下，会导致数据库服务器压力增大，最终系统可能崩溃。 绿色块代表有缓存数据，粉色块代表缓存中没有数据；绿色箭头代表直接从缓存中获取数据，黄色箭头代表穿过缓存从数据库中获取..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://azrng.gitee.io/kbms/kbms/common/1614502329036-0e01cbf5-313b-46c5-ae32-0b8c26ba1a6a.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-10-25T13:23:37.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-08-20T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-10-25T13:23:37.000Z"}]]},"git":{"createdTime":1697962303000,"updatedTime":1698240217000,"contributors":[{"name":"azrng","username":"","email":"itzhangyunpeng@163.com","commits":2}]},"readingTime":{"minutes":5.02,"words":1507},"filePathRelative":"dotnet/base/huancun/changjiangainian.md","excerpt":"<h2>缓存穿透</h2>\\n<h3>描述</h3>\\n<p>大并发查询不存在的key，导致每一次请求数据都从缓存中获取不到，结果请求到了数据库服务器，可是数据库服务器也没有数据，这就导致每次请求都会到数据库服务器。如果在高并发场景下，会导致数据库服务器压力增大，最终系统可能崩溃。<br>\\n<img src=\\"/common/1614502329036-0e01cbf5-313b-46c5-ae32-0b8c26ba1a6a.png\\" alt=\\"\\" loading=\\"lazy\\"></p>\\n<blockquote>\\n<p>绿色块代表有缓存数据，粉色块代表缓存中没有数据；绿色箭头代表直接从缓存中获取数据，黄色箭头代表穿过缓存从数据库中获取数据，但是不一定有。</p>\\n</blockquote>","autoDesc":true}');export{g as comp,c as data};
