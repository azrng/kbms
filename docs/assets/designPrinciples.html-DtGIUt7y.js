import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,o as n,e as a}from"./app-BY9DQv5u.js";const i={},s=a('<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h2><p>设计原则是指导我们代码设计的一些经验总结。 特点：听起来比较抽象，定义描述比较模糊，不同的人会有不同的解读，所以需要掌握设计的初衷，能够解决哪些编程问题，有哪些应用场景。 难点：<strong>掌握设计的初衷，能够解决哪些编程问题，有哪些应用场景。</strong></p><p>对于设计而言，这些原则就是纲领性的标准，你必须灵活准遵守，原则是不变的，而方法是灵活的，在不同的应用中协调和权衡，是面向对象设计的精髓，而这些智慧在逐步的实践和探索中形成。</p><h2 id="常用设计原则" tabindex="-1"><a class="header-anchor" href="#常用设计原则"><span>常用设计原则</span></a></h2><ul><li>SOLID原则-SRP单一职责原则 <ul><li>一个模块应该一个类行为负责</li></ul></li><li>SOLID原则-OCP开闭原则 <ul><li>软件实体应该对扩展开发，对修改封闭</li></ul></li><li>SOLID原则-LSP里式替换原则 <ul><li>子类必须能够替换父类型</li></ul></li><li>SOLID原则-接口隔离原则 <ul><li>高层与底层之间通过接口关联</li></ul></li><li>SOLID原则-DIP依赖反转原则 <ul><li>高层模块不应该依赖于底层模块，二者应该都依赖于抽象。</li></ul></li><li>Kiss原则 <ul><li>尽量保持简单</li></ul></li><li>YNGNI原则 <ul><li>不需要的不要去设计</li></ul></li><li>DRY原则 <ul><li>不要编写重复代码</li></ul></li><li>LOG(迪米特)原则 <ul><li>最小知识原则，高内聚低耦合。</li></ul></li></ul><h3 id="单一职责原则-s" tabindex="-1"><a class="header-anchor" href="#单一职责原则-s"><span>单一职责原则(S)</span></a></h3><h4 id="解释" tabindex="-1"><a class="header-anchor" href="#解释"><span>解释</span></a></h4><p>一个类或者模块只负责完成一个职责(或者功能)。 站在类的角度：不要设计大而全的类，要设计粒度小、功能单一的类。也就是说一个类中不建议包含两个或者两个以上业务不相干的功能，因为它的职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。</p><h4 id="举例" tabindex="-1"><a class="header-anchor" href="#举例"><span>举例</span></a></h4><p>一个类既包含了订单的操作又包含了用户的操作，但是订单和用户是两个独立的业务领域模型，将两个不相干的东西放到一个类中就违反了单一职责原则。</p><p>比如一个计算各种各种形状面积总和的方法，求总和和各种输出不应该写到一个类中，而应该拆开，A类只负责计算年纪，B类只负责封装不同的输出格式，A B各司其职，符合单一职责原则。</p><h4 id="如何判断是否满足" tabindex="-1"><a class="header-anchor" href="#如何判断是否满足"><span>如何判断是否满足</span></a></h4><p>比如用户表里面是否应该存储用户的省市县区等信息，这个根据不同的场景会有不同的答案。所以判断是否符合单一职责原则应该要具体场景里面判断，比如用户的地址只是用来展示，只会保存一个地址，那么就放用户表中就合适了，如果后续发展电商物流等，那么就最好将地址信息从用户表拆分开来，独立成收货信息表等。</p><p>从这个例子可以看出，在不同的场景、不同阶段下，对同一个类的职责是否单一的判定可能是不同的。并没有一个明确的、可以量化的标准。所以可以<strong>先设计一个粗粒度的类，满足业务需求。随着业务发展，如果粗粒度类越来越大、代码越来越多，这时候我们可以考虑将其拆分，这就是持续重构。</strong></p><p><strong>总结一些小技巧帮助判断类是否职责单一</strong></p><ul><li><strong>类中代码行数、函数或者属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分</strong></li><li><strong>类依赖其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分</strong></li><li><strong>私有方法过多，我们就要考虑是否可以将私有方法独立到新类中，设置为公共方法，代码复用。</strong></li><li><strong>比较难给类起名字，很难用一个名词去概括，这就说明类的职责定义的不够清晰。</strong></li><li><strong>类中大量的方法就是集中操作类中的某几个属性。那么就可以考虑将这几个属性和对应的方法拆分出来。</strong></li></ul><p><strong>一个比较宽泛的、可以量化的标准是，一个类的代码行数最好不超过200行，函数个数以及属性个数最好不要超过10个。</strong></p><h4 id="是否越单一越好" tabindex="-1"><a class="header-anchor" href="#是否越单一越好"><span>是否越单一越好</span></a></h4><p>比如说加密和解密的方法，两个本来都是紧密连接的，比如还存在密钥，那么你将加密和解密拆分到不同的类中，还需要维护两个类的密钥，导致代码的可维护性变差了。</p><h3 id="开闭原则-o" tabindex="-1"><a class="header-anchor" href="#开闭原则-o"><span>开闭原则(O)</span></a></h3><h4 id="解释-1" tabindex="-1"><a class="header-anchor" href="#解释-1"><span>解释</span></a></h4><p>软件实体(模块、类、方法等)应该“对扩展开放、对修改关闭”。 添加一个新功能应该是，在已有的代码基础上进行扩展(新增模块、类、方法等)，而非修改已有的代码(修改模块、类、方法等)。</p><h4 id="如何灵活应用开闭原则" tabindex="-1"><a class="header-anchor" href="#如何灵活应用开闭原则"><span>如何灵活应用开闭原则</span></a></h4><p>代码关键点就是预留扩展点。时刻具备扩展意识、抽象意思、封装意识。</p><p>如何才能识别出所有可能的扩展点？ 如果开发的是业务导向的系统，那么就需要对业务足够了解，知道当下以及未来可能要支持的业务需求。 如果跟业务无光、通用的、偏底层的系统，需要了解他们会被如何使用，今后打算添加哪些功能？使用者未来会有哪些功能需求。</p><p>不过也没有必要为一些遥远的、不一定发生的需求去提前买单，做过度设计。最合理的做法是对一些比较确定的、短期可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候，我们就可以实现做一些扩展性设计，对一些不确定未来是否要支持的需求，可以等到有需求驱动的时候，再通过重构代码的方式来支持扩展的需求。</p><h3 id="里式替换原则-l" tabindex="-1"><a class="header-anchor" href="#里式替换原则-l"><span>里式替换原则(L)</span></a></h3><h4 id="解释-2" tabindex="-1"><a class="header-anchor" href="#解释-2"><span>解释</span></a></h4><p>派生类(子类)对象可以在程序中代替其基类(超类)对象。 也就是说：程序中的对象不管在出现在什么地方，都应该可以使用其派生类(子类)的对象进行替换，而不影响程序运行的正确性。</p><p>子类在设计的时候，要遵守父类的行为约定。父类定义了函数的行为约定，那子类可以改变函数的内部逻辑，但是不能改变函数原有的行为约定。这个约定包括：函数声明要实现的功能；对输入、输出、异常的约定；设置包括注释中所罗列的任何特殊说明。实际上，定义父类和子类之间的关系，也可以替换成接口和实现类之间的关系。</p><h4 id="常见违反示例" tabindex="-1"><a class="header-anchor" href="#常见违反示例"><span>常见违反示例</span></a></h4><h5 id="子类违背父类声明要实现的功能" tabindex="-1"><a class="header-anchor" href="#子类违背父类声明要实现的功能"><span>子类违背父类声明要实现的功能</span></a></h5><p>比如父类的排序是时间排序，而子类重写后是按照金额进行排序，这个就违背了原则</p><h5 id="子类违背父类对输入、输出、异常的约定" tabindex="-1"><a class="header-anchor" href="#子类违背父类对输入、输出、异常的约定"><span>子类违背父类对输入、输出、异常的约定</span></a></h5><ul><li>在父类中，运行出错返回null，数据为空返回空集合，而在子类中，运算出错返回异常，获取不到数据返回null，这就违背。</li><li>在父类中，输入的数据可以是任意整数，但是在子类实现的时候，只允许输入正整数，负数就抛出异常，这就违背</li><li>在父类中，某个函数约定，只会抛出ArgumentNullException异常，那子类的设计就只允许抛出该异常，任何其他异常的抛出，都会违背。</li></ul><h5 id="子类违背父类注释中的特殊说明" tabindex="-1"><a class="header-anchor" href="#子类违背父类注释中的特殊说明"><span>子类违背父类注释中的特殊说明</span></a></h5><p>在父类中，注释说，用户余额不能为负数，而在子类重写的时候，vip用户可以欠费，那么就不符合原则。</p><p>拿着父类的单元测试去验证子类的代码，如果测试失败，就很有可能子类的设计实现没有完全遵守父类的约定。</p><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h4><p>子类完美继承父类的设计初衷，并做了增强。</p><h3 id="接口隔离原则-i" tabindex="-1"><a class="header-anchor" href="#接口隔离原则-i"><span>接口隔离原则(I)</span></a></h3><h4 id="解释-3" tabindex="-1"><a class="header-anchor" href="#解释-3"><span>解释</span></a></h4><p>接口的调用者或者使用者不应该强迫依赖它不需要的接口。</p><p>函数的设计功能要单一，不要将多个不同的功能逻辑在一个函数中实现。</p><h4 id="区别" tabindex="-1"><a class="header-anchor" href="#区别"><span>区别</span></a></h4><p>单一职责原则针对的是模块、类、接口的设计。 接口隔离原则侧重于接口的设计，它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接判定。如果调用者只使用部分接口或者接口部分功能，那么接口的设计就不够职责单一。</p><h4 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1"><span>总结</span></a></h4><p>定义接口的时候粒度尽可能小，如果一个接口里面部分方法只是给部分调用者使用，那么这部分内容就应该被单独隔离出来，单独提供给调用者。</p><h3 id="依赖反转原则-d" tabindex="-1"><a class="header-anchor" href="#依赖反转原则-d"><span>依赖反转原则(D)</span></a></h3><h4 id="解释-4" tabindex="-1"><a class="header-anchor" href="#解释-4"><span>解释</span></a></h4><p>英文翻译是Denpendency Inversion Principle，缩写为DIP，中文翻译有时候也叫做依赖倒置原则。 高层模块不要依赖底层模块。高层模块和底层模块之间应该通过抽象来互相依赖。除此之外，抽象不要依赖具体的实现细节，具体实现细节依赖抽象。</p><p>在调用链上，调用者属于高层，被调用者属于低层。</p><h4 id="总结-2" tabindex="-1"><a class="header-anchor" href="#总结-2"><span>总结</span></a></h4><p>有点类似控制反转，主要是用来指导框架层面的设计。</p><h3 id="kiss原则" tabindex="-1"><a class="header-anchor" href="#kiss原则"><span>KISS原则</span></a></h3><h4 id="解释-5" tabindex="-1"><a class="header-anchor" href="#解释-5"><span>解释</span></a></h4><p>英文描述：keep it simple and stupid，翻译中文是尽量保持简单。</p><p>并不只是代码越简单越好，还要考虑逻辑复杂度、实现难度、代码的可读性等。</p><h4 id="场景" tabindex="-1"><a class="header-anchor" href="#场景"><span>场景</span></a></h4><p>用来指导软件开发、知道更加广泛的系统设计、产品设计。</p><h4 id="总结-3" tabindex="-1"><a class="header-anchor" href="#总结-3"><span>总结</span></a></h4><ul><li>不要使用同事可能不懂的技术来实现代码，比如复杂的正则表达式，还有一些编程语言中过于高级的语法。</li><li>不要重复造轮子，善于使用已经有的工具类库。</li><li>不要多度优化。不要过度使用一些奇技淫巧。</li></ul><p>直观评判：如果在code review的时候，同事对你的代码有很多疑问，那就是说明你的代码有可能不够“简单”，需要优化。</p><h3 id="yagni原则" tabindex="-1"><a class="header-anchor" href="#yagni原则"><span>YAGNI原则</span></a></h3><h4 id="解释-6" tabindex="-1"><a class="header-anchor" href="#解释-6"><span>解释</span></a></h4><p>英文全称是 You Ain&#39;t Gonna Need It。中文就是你不会需要它。 意思就是不要去设计当前用不到的功能；不要去编写当前用不到的代码。核心思想就是：不要过度设计。</p><p>比如以后可能会用到某一个功能，但是在未用到之前，没必要去提前编写这部分代码，但是这不意味着我们不需要考虑代码的扩展性。</p><p>YAGNI原则跟KISS原则并非是一回事，KISS原则讲的是如何做的问题(尽量保持简单)，而YAGNI原则说的是要不要做的问题(当前不需要的就不要做)。</p><h3 id="dry原则" tabindex="-1"><a class="header-anchor" href="#dry原则"><span>DRY原则</span></a></h3><h4 id="解释-7" tabindex="-1"><a class="header-anchor" href="#解释-7"><span>解释</span></a></h4><p>英文描述：Don&#39;t Repeat Yourself。中文：不要重复自己。可以理解为不要写重复的代码。</p><h4 id="典型的代码重复情况" tabindex="-1"><a class="header-anchor" href="#典型的代码重复情况"><span>典型的代码重复情况</span></a></h4><ul><li>逻辑重复：不同含义的代码里面逻辑相同，不违背原则</li><li>代码不同，语义相同：相同功能的代码应该只写一次。</li><li>代码执行重复：某一些方法或被重复执行了多次</li></ul><h4 id="dry-vs-代码复用-vs-代码复用性" tabindex="-1"><a class="header-anchor" href="#dry-vs-代码复用-vs-代码复用性"><span>DRY vs 代码复用 vs 代码复用性</span></a></h4><p>代码复用是一种行为：开发新功能的时候尽可能复用已经存在的代码。关注角度是代码使用者角度 代码可复用性表示这一段diamante可被复用的能力。关注角度是代码开发者角度。 DRY表示的是不要写重复的代码。 <strong>不重复不代表可复用</strong>。一个项目代码中，可能不存在任何重复的代码，但是这不表示里面有可复用的代码。不重复和可复用是两个概念。</p><p>目的相同：都是为了减少代码量。提高代码可读性、可维护性。</p><h4 id="总结-4" tabindex="-1"><a class="header-anchor" href="#总结-4"><span>总结</span></a></h4><p>第一次编写代码的时候，我们不考虑复用性，第二次遇到复用场景的时候，再进行重构使其复用。</p><h3 id="迪米特-lod-法则" tabindex="-1"><a class="header-anchor" href="#迪米特-lod-法则"><span>迪米特(LOD)法则</span></a></h3><h4 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景</span></a></h4><p>可以帮我们实现代码的高内聚、低耦合。这是一个比较通用的设计思想，可以用来知道不同粒度代码的设计与开发，比如系统、模块、类，甚至是函数。将类作为这个设计思想的应用对象来说，高内聚指的是类本身的设计，低耦合指的是类与类之间的依赖关系。</p><p>高内聚：相近的功能应该被放在同一个类中，不想近的功能不要放到同一个类中，因为相近的功能往往会被同时修改，放在同一个类中，修改会比较居中，代码容易维护。 低耦合：类与类之间的依赖关系简单清洗。即时两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。</p><h4 id="解释-8" tabindex="-1"><a class="header-anchor" href="#解释-8"><span>解释</span></a></h4><p>英文翻译是Law of Demeter，缩写是LOD，还有另外一个名字叫做<strong>最小知识原则</strong>。</p><p>通俗理解：<strong>不应该有直接依赖关系的类，不要有依赖；有依赖关系的类，尽量只依赖必要的接口。</strong></p><p>示例：比如我们有一个序列化和反序列化的类，我们有的用序列化有的用反序列化，如果将他们放在一个地方会不符合迪米特原则，所以我们需要将其抽离出来两个接口，一个接口只负责序列化另一个接口只负责反序列化，然后我们创建一个实现类，这个实现类去继承这两个接口，然后再需要用到序列化的地方去注入系列化接口，需要反序列化的地方去注入反序列化接口。</p><h4 id="总结-5" tabindex="-1"><a class="header-anchor" href="#总结-5"><span>总结</span></a></h4><p>减少类之间的耦合，让类越独立越好，每个类都应该少了解系统其他部分，这样子一旦发生变化，需要跟随者变化的类就会比较少。</p><h2 id="资料" tabindex="-1"><a class="header-anchor" href="#资料"><span>资料</span></a></h2><p><a href="https://mp.weixin.qq.com/s/JWtxdJVLcQU_n4FNVX0_Ew" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/JWtxdJVLcQU_n4FNVX0_Ew</a> | C## 实例解释面向对象编程中的里氏替换原则</p>',90),t=[s];function r(h,p){return n(),l("div",null,t)}const o=e(i,[["render",r],["__file","designPrinciples.html.vue"]]),u=JSON.parse('{"path":"/softwareDesign/highQualityCode/designPrinciples.html","title":"设计原则","lang":"zh-CN","frontmatter":{"title":"设计原则","lang":"zh-CN","date":"2023-09-05T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["软件设计"],"tag":["无"],"filename":"shuiming","slug":"oea7vt","docsId":"67090619","description":"概述 设计原则是指导我们代码设计的一些经验总结。 特点：听起来比较抽象，定义描述比较模糊，不同的人会有不同的解读，所以需要掌握设计的初衷，能够解决哪些编程问题，有哪些应用场景。 难点：掌握设计的初衷，能够解决哪些编程问题，有哪些应用场景。 对于设计而言，这些原则就是纲领性的标准，你必须灵活准遵守，原则是不变的，而方法是灵活的，在不同的应用中协调和权衡，...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/softwareDesign/highQualityCode/designPrinciples.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"设计原则"}],["meta",{"property":"og:description","content":"概述 设计原则是指导我们代码设计的一些经验总结。 特点：听起来比较抽象，定义描述比较模糊，不同的人会有不同的解读，所以需要掌握设计的初衷，能够解决哪些编程问题，有哪些应用场景。 难点：掌握设计的初衷，能够解决哪些编程问题，有哪些应用场景。 对于设计而言，这些原则就是纲领性的标准，你必须灵活准遵守，原则是不变的，而方法是灵活的，在不同的应用中协调和权衡，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-10-23T01:45:31.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-09-05T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-10-23T01:45:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"设计原则\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-09-05T00:00:00.000Z\\",\\"dateModified\\":\\"2023-10-23T01:45:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[]},{"level":2,"title":"常用设计原则","slug":"常用设计原则","link":"#常用设计原则","children":[{"level":3,"title":"单一职责原则(S)","slug":"单一职责原则-s","link":"#单一职责原则-s","children":[{"level":4,"title":"解释","slug":"解释","link":"#解释","children":[]},{"level":4,"title":"举例","slug":"举例","link":"#举例","children":[]},{"level":4,"title":"如何判断是否满足","slug":"如何判断是否满足","link":"#如何判断是否满足","children":[]},{"level":4,"title":"是否越单一越好","slug":"是否越单一越好","link":"#是否越单一越好","children":[]}]},{"level":3,"title":"开闭原则(O)","slug":"开闭原则-o","link":"#开闭原则-o","children":[{"level":4,"title":"解释","slug":"解释-1","link":"#解释-1","children":[]},{"level":4,"title":"如何灵活应用开闭原则","slug":"如何灵活应用开闭原则","link":"#如何灵活应用开闭原则","children":[]}]},{"level":3,"title":"里式替换原则(L)","slug":"里式替换原则-l","link":"#里式替换原则-l","children":[{"level":4,"title":"解释","slug":"解释-2","link":"#解释-2","children":[]},{"level":4,"title":"常见违反示例","slug":"常见违反示例","link":"#常见违反示例","children":[{"level":5,"title":"子类违背父类声明要实现的功能","slug":"子类违背父类声明要实现的功能","link":"#子类违背父类声明要实现的功能","children":[]},{"level":5,"title":"子类违背父类对输入、输出、异常的约定","slug":"子类违背父类对输入、输出、异常的约定","link":"#子类违背父类对输入、输出、异常的约定","children":[]},{"level":5,"title":"子类违背父类注释中的特殊说明","slug":"子类违背父类注释中的特殊说明","link":"#子类违背父类注释中的特殊说明","children":[]}]},{"level":4,"title":"总结","slug":"总结","link":"#总结","children":[]}]},{"level":3,"title":"接口隔离原则(I)","slug":"接口隔离原则-i","link":"#接口隔离原则-i","children":[{"level":4,"title":"解释","slug":"解释-3","link":"#解释-3","children":[]},{"level":4,"title":"区别","slug":"区别","link":"#区别","children":[]},{"level":4,"title":"总结","slug":"总结-1","link":"#总结-1","children":[]}]},{"level":3,"title":"依赖反转原则(D)","slug":"依赖反转原则-d","link":"#依赖反转原则-d","children":[{"level":4,"title":"解释","slug":"解释-4","link":"#解释-4","children":[]},{"level":4,"title":"总结","slug":"总结-2","link":"#总结-2","children":[]}]},{"level":3,"title":"KISS原则","slug":"kiss原则","link":"#kiss原则","children":[{"level":4,"title":"解释","slug":"解释-5","link":"#解释-5","children":[]},{"level":4,"title":"场景","slug":"场景","link":"#场景","children":[]},{"level":4,"title":"总结","slug":"总结-3","link":"#总结-3","children":[]}]},{"level":3,"title":"YAGNI原则","slug":"yagni原则","link":"#yagni原则","children":[{"level":4,"title":"解释","slug":"解释-6","link":"#解释-6","children":[]}]},{"level":3,"title":"DRY原则","slug":"dry原则","link":"#dry原则","children":[{"level":4,"title":"解释","slug":"解释-7","link":"#解释-7","children":[]},{"level":4,"title":"典型的代码重复情况","slug":"典型的代码重复情况","link":"#典型的代码重复情况","children":[]},{"level":4,"title":"DRY vs 代码复用 vs 代码复用性","slug":"dry-vs-代码复用-vs-代码复用性","link":"#dry-vs-代码复用-vs-代码复用性","children":[]},{"level":4,"title":"总结","slug":"总结-4","link":"#总结-4","children":[]}]},{"level":3,"title":"迪米特(LOD)法则","slug":"迪米特-lod-法则","link":"#迪米特-lod-法则","children":[{"level":4,"title":"使用场景","slug":"使用场景","link":"#使用场景","children":[]},{"level":4,"title":"解释","slug":"解释-8","link":"#解释-8","children":[]},{"level":4,"title":"总结","slug":"总结-5","link":"#总结-5","children":[]}]}]},{"level":2,"title":"资料","slug":"资料","link":"#资料","children":[]}],"git":{"createdTime":1693926838000,"updatedTime":1698025531000,"contributors":[{"name":"zhangyunpeng","email":"zhang.yunpeng@synyi.com","commits":1}]},"readingTime":{"minutes":12.62,"words":3786},"filePathRelative":"softwareDesign/highQualityCode/designPrinciples.md","localizedDate":"2023年9月5日","excerpt":"<h2>概述</h2>\\n<p>设计原则是指导我们代码设计的一些经验总结。\\n特点：听起来比较抽象，定义描述比较模糊，不同的人会有不同的解读，所以需要掌握设计的初衷，能够解决哪些编程问题，有哪些应用场景。\\n难点：<strong>掌握设计的初衷，能够解决哪些编程问题，有哪些应用场景。</strong></p>\\n<p>对于设计而言，这些原则就是纲领性的标准，你必须灵活准遵守，原则是不变的，而方法是灵活的，在不同的应用中协调和权衡，是面向对象设计的精髓，而这些智慧在逐步的实践和探索中形成。</p>\\n<h2>常用设计原则</h2>\\n<ul>\\n<li>SOLID原则-SRP单一职责原则\\n<ul>\\n<li>一个模块应该一个类行为负责</li>\\n</ul>\\n</li>\\n<li>SOLID原则-OCP开闭原则\\n<ul>\\n<li>软件实体应该对扩展开发，对修改封闭</li>\\n</ul>\\n</li>\\n<li>SOLID原则-LSP里式替换原则\\n<ul>\\n<li>子类必须能够替换父类型</li>\\n</ul>\\n</li>\\n<li>SOLID原则-接口隔离原则\\n<ul>\\n<li>高层与底层之间通过接口关联</li>\\n</ul>\\n</li>\\n<li>SOLID原则-DIP依赖反转原则\\n<ul>\\n<li>高层模块不应该依赖于底层模块，二者应该都依赖于抽象。</li>\\n</ul>\\n</li>\\n<li>Kiss原则\\n<ul>\\n<li>尽量保持简单</li>\\n</ul>\\n</li>\\n<li>YNGNI原则\\n<ul>\\n<li>不需要的不要去设计</li>\\n</ul>\\n</li>\\n<li>DRY原则\\n<ul>\\n<li>不要编写重复代码</li>\\n</ul>\\n</li>\\n<li>LOG(迪米特)原则\\n<ul>\\n<li>最小知识原则，高内聚低耦合。</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{o as comp,u as data};
