import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as p,a as n,d as e}from"./app-DMmdIwn0.js";const a="/kbms/common/1613566425572-63c08e76-8ab9-4fcb-8dc1-537a925313c3.png",r="/kbms/common/1613566425574-a98ff84d-8a08-49d5-88d6-4f1f7cbd4ef8.png",b={},i=n("p",null,[e('.NET Framework中的线程分为两类：1.前台线程；2.后台线程。 1.前台线程： class Program {     static void Main(string[] args)     {        Console.WriteLine("='),n("mark",null,[n("mark",null,"Thread")]),e('=");         TestThread();        Console.WriteLine("主线程执行完毕");       }     public static void TestThread()     {         Thread thread = new Thread(PrintNum);         thread.Start();     }       public static void PrintNum()     {         Thread.Sleep(3000);         for (int i = 0; i < 10; i++)             Console.WriteLine(i);     } } 主线程虽然执行完毕了，但是并没有退出程序，而是等待子线程执行完毕后，退出程序。 '),n("img",{src:a,alt:"image.png",loading:"lazy"}),e('   2.后台线程 class Program {     static void Main(string[] args)     {        Console.WriteLine("='),n("mark",null,[n("mark",null,"ThreadPool")]),e('=");     　　ThreadPool.QueueUserWorkItem(new WaitCallback(PrintNum));     　　Console.WriteLine("主线程执行完毕");         }     public static void PrintNum(object obj)     {         Thread.Sleep(3000);         for (int i = 0; i < 10; i++)             Console.WriteLine(i);     } } '),n("img",{src:r,alt:"image.png",loading:"lazy"}),e(" 主线程运行完毕后，就直接退出了程序，没有等待子线程。 总结： 1.前台线程：主线程执行完毕后，会等待所有子线程执行完毕后，才退出程序。 2.后台线程：主线程执行完毕后，直接退出程序，不论子线程是否执行完毕。 3.推荐：多线程的操作，推荐使用线程池线程而非新建线程。因为就算只是单纯的新建一个线程，这个线程什么事情也不做，都大约需要1M的内存空间来存储执行上下文数据结构，并且线程的创建与回收也需要消耗资源，耗费时间。而线程池的优势在于线程池中的线程是根据需要创建与销毁，是最优的存在。但是这也有个问题，那就是线程池线程都是后台线程，主线程执行完毕后，不会等待后台线程而直接结束程序。所以下面就要引出.NET Framework4.0提供的Task，来解决此类问题。     如果一个应用程序接收到很多请求，且处理每个请求都非常耗时。在这种情况下，我们就必须指定一个点来结束请求，当有新的请求进入状态时，没有worker 线程可使用，这种现象称为线程饥饿。")],-1),o=[i];function c(m,d){return t(),p("div",null,o)}const h=s(b,[["render",c],["__file","xianchengthreadhetask.html.vue"]]),T=JSON.parse('{"path":"/dotnet/webyingyong/webform/xiancheng/xianchengthreadhetask.html","title":"线程thread和 Task","lang":"zh-CN","frontmatter":{"title":"线程thread和 Task","lang":"zh-CN","date":"2021-02-17T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["dotNET"],"tag":["无"],"filename":"xianchengthreadhetask","slug":"lfgvws","docsId":"31541465","description":".NET Framework中的线程分为两类：1.前台线程；2.后台线程。 1.前台线程： class Program { static void Main(string[] args) { Console.WriteLine(\\"=Thread=\\"); TestThread(); Console.WriteLine(\\"主线程执行完毕\\"); } publ...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dotnet/webyingyong/webform/xiancheng/xianchengthreadhetask.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"线程thread和 Task"}],["meta",{"property":"og:description","content":".NET Framework中的线程分为两类：1.前台线程；2.后台线程。 1.前台线程： class Program { static void Main(string[] args) { Console.WriteLine(\\"=Thread=\\"); TestThread(); Console.WriteLine(\\"主线程执行完毕\\"); } publ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://azrng.gitee.io/kbms/kbms/common/1613566425572-63c08e76-8ab9-4fcb-8dc1-537a925313c3.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-10-22T08:11:43.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2021-02-17T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-10-22T08:11:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"线程thread和 Task\\",\\"image\\":[\\"https://azrng.gitee.io/kbms/kbms/common/1613566425572-63c08e76-8ab9-4fcb-8dc1-537a925313c3.png\\",\\"https://azrng.gitee.io/kbms/kbms/common/1613566425574-a98ff84d-8a08-49d5-88d6-4f1f7cbd4ef8.png\\"],\\"datePublished\\":\\"2021-02-17T00:00:00.000Z\\",\\"dateModified\\":\\"2023-10-22T08:11:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[],"git":{"createdTime":1697962303000,"updatedTime":1697962303000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":1}]},"readingTime":{"minutes":1.81,"words":544},"filePathRelative":"dotnet/webyingyong/webform/xiancheng/xianchengthreadhetask.md","localizedDate":"2021年2月17日","excerpt":"<p>.NET Framework中的线程分为两类：1.前台线程；2.后台线程。\\n1.前台线程：\\nclass Program\\n{\\n&nbsp;&nbsp;&nbsp; static void Main(string[] args)\\n&nbsp;&nbsp;&nbsp; {\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\\"=<mark><mark>Thread</mark></mark>=\\");\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TestThread();\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\\"主线程执行完毕\\");&nbsp;&nbsp;\\n&nbsp;&nbsp;&nbsp; }\\n&nbsp;&nbsp;&nbsp; public static void TestThread()\\n&nbsp;&nbsp;&nbsp; {\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread thread = new Thread(PrintNum);\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; thread.Start();\\n&nbsp;&nbsp;&nbsp; }\\n&nbsp;\\n&nbsp;&nbsp;&nbsp; public static void PrintNum()\\n&nbsp;&nbsp;&nbsp; {\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread.Sleep(3000);\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 10; i++)\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(i);\\n&nbsp;&nbsp;&nbsp; }\\n}\\n主线程虽然执行完毕了，但是并没有退出程序，而是等待子线程执行完毕后，退出程序。\\n<img src=\\"/common/1613566425572-63c08e76-8ab9-4fcb-8dc1-537a925313c3.png\\" alt=\\"image.png\\" loading=\\"lazy\\">\\n&nbsp;\\n2.后台线程\\nclass Program\\n{\\n&nbsp;&nbsp;&nbsp; static void Main(string[] args)\\n&nbsp;&nbsp;&nbsp; {\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\\"=<mark><mark>ThreadPool</mark></mark>=\\");\\n&nbsp;&nbsp;&nbsp; 　　ThreadPool.QueueUserWorkItem(new WaitCallback(PrintNum));\\n&nbsp;&nbsp;&nbsp; 　　Console.WriteLine(\\"主线程执行完毕\\");&nbsp;&nbsp;&nbsp;&nbsp;\\n&nbsp;&nbsp;&nbsp; }\\n&nbsp;&nbsp;&nbsp; public static void PrintNum(object obj)\\n&nbsp;&nbsp;&nbsp; {\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread.Sleep(3000);\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 10; i++)\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(i);\\n&nbsp;&nbsp;&nbsp; }\\n}\\n<img src=\\"/common/1613566425574-a98ff84d-8a08-49d5-88d6-4f1f7cbd4ef8.png\\" alt=\\"image.png\\" loading=\\"lazy\\">\\n主线程运行完毕后，就直接退出了程序，没有等待子线程。\\n总结：\\n1.前台线程：主线程执行完毕后，会等待所有子线程执行完毕后，才退出程序。\\n2.后台线程：主线程执行完毕后，直接退出程序，不论子线程是否执行完毕。\\n3.推荐：多线程的操作，推荐使用线程池线程而非新建线程。因为就算只是单纯的新建一个线程，这个线程什么事情也不做，都大约需要1M的内存空间来存储执行上下文数据结构，并且线程的创建与回收也需要消耗资源，耗费时间。而线程池的优势在于线程池中的线程是根据需要创建与销毁，是最优的存在。但是这也有个问题，那就是线程池线程都是后台线程，主线程执行完毕后，不会等待后台线程而直接结束程序。所以下面就要引出.NET Framework4.0提供的Task，来解决此类问题。\\n&nbsp;\\n&nbsp;\\n如果一个应用程序接收到很多请求，且处理每个请求都非常耗时。在这种情况下，我们就必须指定一个点来结束请求，当有新的请求进入状态时，没有worker 线程可使用，这种现象称为线程饥饿。</p>","autoDesc":true}');export{h as comp,T as data};
