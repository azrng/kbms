import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as n,o as r}from"./app-B3EhLA94.js";const l="/kbms/common/1639234924585-34e35001-2681-48c4-8d5b-bd338ae34c68.png",o={};function i(s,e){return r(),a("div",null,e[0]||(e[0]=[n('<h2 id="_1-概述" tabindex="-1"><a class="header-anchor" href="#_1-概述"><span>1. 概述</span></a></h2><p>标准CLR使用<strong>分代式标记-压缩GC</strong>对托管堆上的对象进行自动内存管理，这是追踪型垃圾回收器，不会干涉每一次对象的访问，而是会直接激活并追踪存储在托管堆上的对象引用图，来决定哪些对象应该作为垃圾进行回收。</p><h3 id="什么时候开始垃圾回收" tabindex="-1"><a class="header-anchor" href="#什么时候开始垃圾回收"><span>什么时候开始垃圾回收？</span></a></h3><p>当内存分配量超过特定的阈值，或者需要降低应用程序内存使用量时候，垃圾回收器就会在进行内存分配时(通过new关键字)触发一次垃圾回收，这个过程还可以通过System.GC.Collect方法来手动触发。在垃圾回收的时候，所有线程都可能冻结。</p><h3 id="如何回收" tabindex="-1"><a class="header-anchor" href="#如何回收"><span>如何回收？</span></a></h3><p>GC会从跟对象开始按照对象引用遍历对象图，将所有遍历到的对象标记为可达对象。当这个过程完成后，所有没有被标记的对象(即未被使用的对象)将会作为垃圾进行回收。未被使用的对象若没有终结器，则会被立即回收，有终结器的对象将会被放到终结队列，并在GC完成之后由终结器线程处理。这些对象将在下一次对该代对象的垃圾回收中被回收(除非该对象复活)。剩余存储的对象将移动到堆的起始位置(压缩)，释放出更多的对象空间来容纳更多的对象，目的是：<strong>可以防止内存碎片化；GC可以用简单的策略来分配新的对象，将新的对象分配在堆的尾部即可</strong>。同时还避免了耗时淡定内存片段列表的维护开销。</p><p>如果垃圾回收后还没有足够的内存来分配新的对象，并且操作系统也无法分配更多的内存，这个时候就会抛出OutOfMemoryException。</p><h2 id="_2-优化技术" tabindex="-1"><a class="header-anchor" href="#_2-优化技术"><span>2. 优化技术</span></a></h2><p>使用多种优化技术来减少垃圾回收的时间。</p><h3 id="_2-1-分代回收-最重要的优化措施" tabindex="-1"><a class="header-anchor" href="#_2-1-分代回收-最重要的优化措施"><span>2.1 分代回收(最重要的优化措施)</span></a></h3><h4 id="目的" tabindex="-1"><a class="header-anchor" href="#目的"><span>目的</span></a></h4><p>尽管许多对象的分配和释放非常频繁，但是某些对象会长时间存活，并不需要在每次回收的时候都追踪它。使得存活周期短的对象非常有效地被垃圾回收器回收。</p><h4 id="实现" tabindex="-1"><a class="header-anchor" href="#实现"><span>实现</span></a></h4><p>垃圾回收器将堆上的内存分为三代：<br><strong>0代：刚刚分配的对象。(短生存期代，回收会频繁发生)</strong><br> CLR将0代控制在一个相对娇小的空间(最大256mb，通常只有几百kb到几mb)，当0代被填满的时候，GC就会触发0代的垃圾回收。<br><strong>1代：在第一轮回收中存活的对象。(短生存期代)</strong><br> GC对1代应用了相似的空间限制，内存回收相对快速而频繁。<br><strong>2代：其他所有对象</strong><br> 没有空间限制，回收时间较长，因此并不是那么频繁。<br><img src="'+l+'" alt="image.png" loading="lazy"></p><blockquote><p>一次完整回收的效果</p></blockquote><h3 id="_2-2-大对象堆" tabindex="-1"><a class="header-anchor" href="#_2-2-大对象堆"><span>2.2 大对象堆</span></a></h3><p>垃圾回收器将大于某一个阈值的对象(目前是85000字节)存放在一个独立的堆中，称为大对象堆(Large Object Heap，<strong>LOH</strong>)，可以避免过量的第0代回收。如果没有LOH，分配大于16mb对象的几乎每次分配就会触发一次第0代回收。<strong>默认情况下，大对象堆是不会被压缩的，因为在垃圾回收时候移动大块的内存开销比较大。</strong></p><blockquote><p><strong>大对象堆并不分代，上面所有的对象都会按照第2代处理。</strong></p></blockquote><h4 id="_2-2-1-缺点" tabindex="-1"><a class="header-anchor" href="#_2-2-1-缺点"><span>2.2.1 缺点</span></a></h4><ul><li>分配缓慢，无法简单地在堆的末尾分配对象，需要考虑中间的空袭，所以就需要维护空闲内存快链表。</li><li>大对象堆有可能碎片化。</li></ul><h3 id="_2-3-并发和后台回收" tabindex="-1"><a class="header-anchor" href="#_2-3-并发和后台回收"><span>2.3 并发和后台回收</span></a></h3><p>垃圾回收器在回收的时候需要在一段时间内冻结(阻塞)执行线程，这包含0代和1代回收的整个时间。在回收第2代的时候，垃圾回收器会进行一些特殊的尝试，来允许线程运行，因为我们并不希望长时间冻结应用程序的执行。</p><h3 id="_2-4-垃圾回收通知" tabindex="-1"><a class="header-anchor" href="#_2-4-垃圾回收通知"><span>2.4 垃圾回收通知</span></a></h3><p>在进行完全回收之前发送通知。将请求转转发到其他服务器上，然后立即开始回收，在回收完毕之后在重新开始将请求路由到这台服务器上。</p><h2 id="_3-强制垃圾回收" tabindex="-1"><a class="header-anchor" href="#_3-强制垃圾回收"><span>3. 强制垃圾回收</span></a></h2><p>我们可以在任何时刻调用GC.Collect方法来强制进行垃圾回收，调用GC.Collect无参数的方法将会发起一次完整的回收，如果传入一个整数，那么就只回收那一代。</p><blockquote><p>尽可能让GC来决定何时进行垃圾回收会得到最佳的性能。</p></blockquote><h2 id="_4-垃圾回收过程的调整" tabindex="-1"><a class="header-anchor" href="#_4-垃圾回收过程的调整"><span>4. 垃圾回收过程的调整</span></a></h2><p>GCSettings.LatencyMode静态属性可以决定如何在延迟和整体效率上进行权衡。将默认值Interactive更改为LowLatency将使CLR更多（更频繁）地进行快速回收。</p>',29)]))}const h=t(o,[["render",i],["__file","workingMethod.html.vue"]]),d=JSON.parse('{"path":"/dotnet/csharp/garbageCollection/workingMethod.html","title":"垃圾回收器工作方式","lang":"zh-CN","frontmatter":{"title":"垃圾回收器工作方式","lang":"zh-CN","date":"2023-10-22T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["csharp"],"tag":["无"],"filename":"lajihuishouqigongzuofangshi","slug":"nvtk5d","docsId":"62059122","description":"1. 概述 标准CLR使用分代式标记-压缩GC对托管堆上的对象进行自动内存管理，这是追踪型垃圾回收器，不会干涉每一次对象的访问，而是会直接激活并追踪存储在托管堆上的对象引用图，来决定哪些对象应该作为垃圾进行回收。 什么时候开始垃圾回收？ 当内存分配量超过特定的阈值，或者需要降低应用程序内存使用量时候，垃圾回收器就会在进行内存分配时(通过new关键字)触...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dotnet/csharp/garbageCollection/workingMethod.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"垃圾回收器工作方式"}],["meta",{"property":"og:description","content":"1. 概述 标准CLR使用分代式标记-压缩GC对托管堆上的对象进行自动内存管理，这是追踪型垃圾回收器，不会干涉每一次对象的访问，而是会直接激活并追踪存储在托管堆上的对象引用图，来决定哪些对象应该作为垃圾进行回收。 什么时候开始垃圾回收？ 当内存分配量超过特定的阈值，或者需要降低应用程序内存使用量时候，垃圾回收器就会在进行内存分配时(通过new关键字)触..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://azrng.gitee.io/kbms/kbms/common/1639234924585-34e35001-2681-48c4-8d5b-bd338ae34c68.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-01-28T14:08:42.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-10-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-01-28T14:08:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"垃圾回收器工作方式\\",\\"image\\":[\\"https://azrng.gitee.io/kbms/kbms/common/1639234924585-34e35001-2681-48c4-8d5b-bd338ae34c68.png\\"],\\"datePublished\\":\\"2023-10-22T00:00:00.000Z\\",\\"dateModified\\":\\"2024-01-28T14:08:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"1. 概述","slug":"_1-概述","link":"#_1-概述","children":[{"level":3,"title":"什么时候开始垃圾回收？","slug":"什么时候开始垃圾回收","link":"#什么时候开始垃圾回收","children":[]},{"level":3,"title":"如何回收？","slug":"如何回收","link":"#如何回收","children":[]}]},{"level":2,"title":"2. 优化技术","slug":"_2-优化技术","link":"#_2-优化技术","children":[{"level":3,"title":"2.1 分代回收(最重要的优化措施)","slug":"_2-1-分代回收-最重要的优化措施","link":"#_2-1-分代回收-最重要的优化措施","children":[{"level":4,"title":"目的","slug":"目的","link":"#目的","children":[]},{"level":4,"title":"实现","slug":"实现","link":"#实现","children":[]}]},{"level":3,"title":"2.2 大对象堆","slug":"_2-2-大对象堆","link":"#_2-2-大对象堆","children":[{"level":4,"title":"2.2.1 缺点","slug":"_2-2-1-缺点","link":"#_2-2-1-缺点","children":[]}]},{"level":3,"title":"2.3 并发和后台回收","slug":"_2-3-并发和后台回收","link":"#_2-3-并发和后台回收","children":[]},{"level":3,"title":"2.4 垃圾回收通知","slug":"_2-4-垃圾回收通知","link":"#_2-4-垃圾回收通知","children":[]}]},{"level":2,"title":"3. 强制垃圾回收","slug":"_3-强制垃圾回收","link":"#_3-强制垃圾回收","children":[]},{"level":2,"title":"4. 垃圾回收过程的调整","slug":"_4-垃圾回收过程的调整","link":"#_4-垃圾回收过程的调整","children":[]}],"git":{"createdTime":1700232644000,"updatedTime":1706450922000,"contributors":[{"name":"azrng","username":"azrng","email":"itzhangyunpeng@163.com","commits":3}]},"readingTime":{"minutes":4.45,"words":1334},"filePathRelative":"dotnet/csharp/garbageCollection/workingMethod.md","localizedDate":"2023年10月22日","excerpt":"<h2>1. 概述</h2>\\n<p>标准CLR使用<strong>分代式标记-压缩GC</strong>对托管堆上的对象进行自动内存管理，这是追踪型垃圾回收器，不会干涉每一次对象的访问，而是会直接激活并追踪存储在托管堆上的对象引用图，来决定哪些对象应该作为垃圾进行回收。</p>\\n<h3>什么时候开始垃圾回收？</h3>\\n<p>当内存分配量超过特定的阈值，或者需要降低应用程序内存使用量时候，垃圾回收器就会在进行内存分配时(通过new关键字)触发一次垃圾回收，这个过程还可以通过System.GC.Collect方法来手动触发。在垃圾回收的时候，所有线程都可能冻结。</p>\\n<h3>如何回收？</h3>","autoDesc":true}');export{h as comp,d as data};
