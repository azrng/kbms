import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,e as t,o as e}from"./app-SmdjEsew.js";const n="/kbms/common/1609925669140-4cfa24c6-ff66-488b-9ff1-22d300859a31.png",r="/kbms/common/1609925669117-362f079e-f761-44ef-b29a-caadfaa21998.png",h="/kbms/common/1609925669141-f8475a1e-15ec-4d0c-9afc-943d7a7becd7.png",p="/kbms/common/1609925669134-77f1cbdc-eb16-42e9-919a-f789b8ff3d81.png",o={};function l(c,a){return e(),i("div",null,a[0]||(a[0]=[t('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>分库分表，首先要知道瓶颈在哪里，然后才能合理进行拆开，不可为了分库分表而拆分<br> 只要能满足需求，拆分规则越简单越好。</p><h2 id="需要分库分表的场景" tabindex="-1"><a class="header-anchor" href="#需要分库分表的场景"><span>需要分库分表的场景</span></a></h2><h3 id="io瓶颈" tabindex="-1"><a class="header-anchor" href="#io瓶颈"><span>IO瓶颈</span></a></h3><p>第一种：磁盘读IO瓶颈，热点数据太多，数据库缓存放不下，每次查询时会产生大量的IO，降低查询速度 -&gt; 分库和垂直分表。<br> 第二种：网络IO瓶颈，请求的数据太多，网络带宽不够 -&gt; 分库。</p><h3 id="cpu瓶颈" tabindex="-1"><a class="header-anchor" href="#cpu瓶颈"><span>CPU瓶颈</span></a></h3><p>第一种：SQL问题，如SQL中包含join，group by，order by，非索引字段条件查询等，增加CPU运算的操作 -&gt; SQL优化，建立合适的索引，在业务Service层进行业务计算。<br> 第二种：单表数据量太大，查询时扫描的行太多，SQL效率低，CPU率先出现瓶颈 -&gt; 水平分表。</p><h2 id="操作" tabindex="-1"><a class="header-anchor" href="#操作"><span>操作</span></a></h2><h3 id="水平分库" tabindex="-1"><a class="header-anchor" href="#水平分库"><span>水平分库</span></a></h3><p><img src="'+n+'" alt="image.png" loading="lazy"><br><strong>概念</strong>：以字段为依据，按照一定策略（hash、range等)，将一个库中的数据拆分到多个库中。<br><strong>结果</strong>：<br> 每个库的结构都一样；<br> 每个库的数据都不一样，没有交集；<br> 所有库的并集是全量数据；<br><strong>场景</strong>：系统绝对并发量上来了，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库。<br><strong>分析</strong>：库多了，io和cpu的压力自然可以成倍缓解。</p><h3 id="水平分表" tabindex="-1"><a class="header-anchor" href="#水平分表"><span>水平分表</span></a></h3><p><img src="'+r+`" alt="image.png" loading="lazy"><br><strong>概念</strong>：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。<br><strong>结果</strong>：<br> 每个表的结构都一样；<br> 每个表的数据都不一样，没有交集；<br> 所有表的并集是全量数据；<br><strong>场景</strong>：系统绝对并发量并没有上来，只是单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈。推荐：<a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247491313&amp;idx=2&amp;sn=01d82309c459c7385a2ccf0018bb0d8a&amp;chksm=ebd621dddca1a8cb16f33497c45aeb44e95ca0d5289afee263e047a868cb67f34ada644418b0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">一次SQL查询优化原理分析</a><br><strong>分析</strong>：表的数据量少了，单次SQL执行效率高，自然减轻了CPU的负担。</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-csharp"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 示例分表逻辑</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//- 按患者ID哈希分表（适合按患者查询为主的场景）</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//- 复合分表键（患者ID+其他搜索的场景）</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> string</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> GetTableName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">string</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> patientId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 方法1：按患者ID哈希分16张表</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> hash</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Abs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">patientId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">GetHashCode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">%</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 16</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> $&quot;medical_indicator_{</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">hash</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="垂直分库" tabindex="-1"><a class="header-anchor" href="#垂直分库"><span>垂直分库</span></a></h3><p><img src="`+h+'" alt="image.png" loading="lazy"><br><strong>概念</strong>：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。<br><strong>结果</strong>：<br> 每个库的结构都不一样；<br> 每个库的数据也不一样，没有交集；<br> 所有库的并集是全量数据；<br><strong>场景</strong>：系统绝对并发量上来了，并且可以抽象出单独的业务模块。<br><strong>分析</strong>：到这一步，基本上就可以服务化了。例如，随着业务的发展一些公用的配置表、字典表等越来越多，这时可以将这些表拆到单独的库中，甚至可以服务化。再有，随着业务的发展孵化出了一套业务模式，这时可以将相关的表拆到单独的库中，甚至可以服务化。</p><p></p><h3 id="垂直分表" tabindex="-1"><a class="header-anchor" href="#垂直分表"><span>垂直分表</span></a></h3><p><img src="'+p+'" alt="image.png" loading="lazy"><br><strong>概念</strong>：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。<br><strong>结果</strong>：<br> 每个表的结构都不一样；<br> 每个表的数据也不一样，一般来说，每个表的字段至少有一列交集，一般是主键，用于关联数据；<br> 所有表的并集是全量数据；<br><strong>场景</strong>：系统绝对并发量并没有上来，表的记录并不多，但是字段多，并且热点数据和非热点数据在一起，单行数据所需的存储空间较大。以至于数据库缓存的数据行减少，查询时会去读磁盘数据产生大量的随机读IO，产生IO瓶颈。<br><strong>分析</strong>：可以用列表页和详情页来帮助理解。垂直分表的拆分原则是将热点数据（可能会冗余经常一起查询的数据）放在一起作为主表，非热点数据放在一起作为扩展表。这样更多的热点数据就能被缓存下来，进而减少了随机读IO。拆了之后，要想获得全部数据就需要关联两个表来取数据。<br> 但记住，千万别用join，因为join不仅会增加CPU负担并且会讲两个表耦合在一起（必须在一个数据库实例上）。关联数据，应该在业务Service层做文章，分别获取主表和扩展表数据然后用关联字段关联得到全部数据。</p><h2 id="分库分表工具" tabindex="-1"><a class="header-anchor" href="#分库分表工具"><span>分库分表工具</span></a></h2><p>shardingCore：<a href="https://xuejmnet.github.io/sharding-core-doc/" target="_blank" rel="noopener noreferrer">https://xuejmnet.github.io/sharding-core-doc/</a></p><p>sharding-sphere：jar，前身是sharding-jdbc；<br> TDDL：jar，Taobao Distribute Data Layer；<br> Mycat：中间件。</p><h2 id="其他资料" tabindex="-1"><a class="header-anchor" href="#其他资料"><span>其他资料</span></a></h2><p>示例GitHub地址：<a href="https://github.com/littlecharacter4s/study-sharding" target="_blank" rel="noopener noreferrer">https://github.com/littlecharacter4s/study-sharding</a></p>',23)]))}const k=s(o,[["render",l]]),b=JSON.parse('{"path":"/dataBase/extend/fenkufenbiao.html","title":"分库分表","lang":"zh-CN","frontmatter":{"title":"分库分表","lang":"zh-CN","date":"2023-07-29T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["dataBase"],"tag":["无"],"filename":"fenkufenbiao","slug":"gcwq5f","docsId":"29711508","description":"前言 分库分表，首先要知道瓶颈在哪里，然后才能合理进行拆开，不可为了分库分表而拆分 只要能满足需求，拆分规则越简单越好。 需要分库分表的场景 IO瓶颈 第一种：磁盘读IO瓶颈，热点数据太多，数据库缓存放不下，每次查询时会产生大量的IO，降低查询速度 -> 分库和垂直分表。 第二种：网络IO瓶颈，请求的数据太多，网络带宽不够 -> 分库。 CPU瓶颈 第...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"分库分表\\",\\"image\\":[\\"https://azrng.gitee.io/kbms/kbms/common/1609925669140-4cfa24c6-ff66-488b-9ff1-22d300859a31.png\\",\\"https://azrng.gitee.io/kbms/kbms/common/1609925669117-362f079e-f761-44ef-b29a-caadfaa21998.png\\",\\"https://azrng.gitee.io/kbms/kbms/common/1609925669141-f8475a1e-15ec-4d0c-9afc-943d7a7becd7.png\\",\\"https://azrng.gitee.io/kbms/kbms/common/1609925669134-77f1cbdc-eb16-42e9-919a-f789b8ff3d81.png\\"],\\"datePublished\\":\\"2023-07-29T00:00:00.000Z\\",\\"dateModified\\":\\"2025-07-27T13:46:27.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"],["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dataBase/extend/fenkufenbiao.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"分库分表"}],["meta",{"property":"og:description","content":"前言 分库分表，首先要知道瓶颈在哪里，然后才能合理进行拆开，不可为了分库分表而拆分 只要能满足需求，拆分规则越简单越好。 需要分库分表的场景 IO瓶颈 第一种：磁盘读IO瓶颈，热点数据太多，数据库缓存放不下，每次查询时会产生大量的IO，降低查询速度 -> 分库和垂直分表。 第二种：网络IO瓶颈，请求的数据太多，网络带宽不够 -> 分库。 CPU瓶颈 第..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://azrng.gitee.io/kbms/kbms/common/1609925669140-4cfa24c6-ff66-488b-9ff1-22d300859a31.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-27T13:46:27.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-07-29T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-27T13:46:27.000Z"}]]},"git":{"createdTime":1695484404000,"updatedTime":1753623987000,"contributors":[{"name":"azrng","username":"","email":"itzhangyunpeng@163.com","commits":4}]},"readingTime":{"minutes":4.31,"words":1294},"filePathRelative":"dataBase/extend/fenkufenbiao.md","excerpt":"<h2>前言</h2>\\n<p>分库分表，首先要知道瓶颈在哪里，然后才能合理进行拆开，不可为了分库分表而拆分<br>\\n只要能满足需求，拆分规则越简单越好。</p>\\n<h2>需要分库分表的场景</h2>\\n<h3>IO瓶颈</h3>\\n<p>第一种：磁盘读IO瓶颈，热点数据太多，数据库缓存放不下，每次查询时会产生大量的IO，降低查询速度 -&gt; 分库和垂直分表。<br>\\n第二种：网络IO瓶颈，请求的数据太多，网络带宽不够 -&gt; 分库。</p>\\n<h3>CPU瓶颈</h3>\\n<p>第一种：SQL问题，如SQL中包含join，group by，order by，非索引字段条件查询等，增加CPU运算的操作 -&gt; SQL优化，建立合适的索引，在业务Service层进行业务计算。<br>\\n第二种：单表数据量太大，查询时扫描的行太多，SQL效率低，CPU率先出现瓶颈 -&gt; 水平分表。</p>","autoDesc":true}');export{k as comp,b as data};
