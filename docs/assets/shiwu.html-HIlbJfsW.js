import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,o as a,d as s}from"./app-DZ9bmjCp.js";const t={},n=s(`<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h2><p>数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。 比如，你有2条sql要执行，如果放到一个事务里，要么2个sql都执行成功，要么都失败。都执行成功了就提交事务，有一个失败了就回滚，不存在一个成功一个失败。</p><h2 id="事务原则" tabindex="-1"><a class="header-anchor" href="#事务原则"><span>事务原则</span></a></h2><h5 id="_1-原子性-atomicity" tabindex="-1"><a class="header-anchor" href="#_1-原子性-atomicity"><span>1. 原子性(Atomicity)</span></a></h5><p>比如现在A有800元，B有200元，A给B转账200元。完成此场景有2步，可以当做在一个事务里：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span> A：800-200=600</span></span>
<span class="line"><span> B：200+200=400</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>那么，这2个步骤只能都成功，或者都失败。如果一个成功一个失败了，那么有一个人的钱就不对了。原子性就是表示不能只发生其中一个动作。</p><h5 id="_2-一致性-consistency" tabindex="-1"><a class="header-anchor" href="#_2-一致性-consistency"><span>2. 一致性(Consistency)</span></a></h5><p>针对一个事务操作前与操作后的状态一致。 比如现在A有800元，B有200元，2个人总计是1000元。那么不管这2个人之间怎么转来转去，总和一定还是1000元，钱不会凭空产生或消失。</p><h5 id="_3-持久性-durability" tabindex="-1"><a class="header-anchor" href="#_3-持久性-durability"><span>3. 持久性(Durability)</span></a></h5><p>对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障。 比如现在A有800元，B有200元，此时A要给B转账200，或有2种情况：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>事务还没提交，这时候服务挂了或者断电，那么重启数据库后，数据状态应该为：A有800元，B有200元</span></span>
<span class="line"><span>事务已经提交，这时候服务挂了或者断电，那么重启数据库后，数据状态应该为：A有600元，B有400元</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，事务一旦提交，就会持久化到数据库里，不会因外界原因导致数据丢失。</p><h5 id="_4-隔离性-isolation" tabindex="-1"><a class="header-anchor" href="#_4-隔离性-isolation"><span>4. 隔离性(Isolation)</span></a></h5><p>事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。 比如现在有2个事务同时进行，A和C同时在给B转账：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>事务一：</span></span>
<span class="line"><span>A有800元，B有200元，A给B转账200元</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>事务二：</span></span>
<span class="line"><span>C有1000元，B有200元，C给B转账100元</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这2个事务不会互相影响。隔离性就是针对多用户同时操作的情况下，排除其他事务对本事务的影响。</p><h2 id="数据库事务隔离级别" tabindex="-1"><a class="header-anchor" href="#数据库事务隔离级别"><span>数据库事务隔离级别</span></a></h2><p>数据库的事务隔离级别有4个，强度从低到高依次为： Read uncommitted(读未提交) 、Read committed(读已提交) 、Repeatable read(可重复读)、Serializable(可串行化)</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读取未提交</td><td>√</td><td>√</td><td>√</td></tr><tr><td>读取已提交</td><td>×</td><td>√</td><td>√</td></tr><tr><td>可重复读</td><td>×</td><td>×</td><td>√</td></tr><tr><td>可串行化</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>而随着隔离级别的不同，会引发一些其他的问题。</p><h2 id="事务引起的问题" tabindex="-1"><a class="header-anchor" href="#事务引起的问题"><span>事务引起的问题</span></a></h2><h5 id="_1-脏读" tabindex="-1"><a class="header-anchor" href="#_1-脏读"><span>1. 脏读</span></a></h5><p>一个事务读取了另外一个事务未提交的数据，就是脏读。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>事务1： A给B转账500，但是事务未提交。</span></span>
<span class="line"><span>事务2： B查看了账户，发现A转过来500，本来只转300过来就好，发现多转了200，心里美滋滋。。。</span></span>
<span class="line"><span>事务1： A及时发现多转了200，修改了转300，提交事务。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最终，B再次查看账户的时候发现还是只多了300块，白高兴一场，这种就是脏读。当隔离级别设置为<code>Read uncommitted</code>时可能会出现该情况。 若避开脏读，可以设置隔离级别为<code>Read committed</code>。</p><h5 id="_2-不可重复读" tabindex="-1"><a class="header-anchor" href="#_2-不可重复读"><span>2. 不可重复读</span></a></h5><p>一个事务先后读取同一条记录，而事务在两次读取之间该数据被其它事务所修改，则两次读取的数据不同，这种就是不可重复读。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>事务1：B去买东西，卡里有500块钱，消费100，还没提交事务。</span></span>
<span class="line"><span>事务2：B的老婆把B的500块钱转出去了，已提交事务。</span></span>
<span class="line"><span>事务1：B此时提交事务，支付不了。再次读取发现卡里没钱支付。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当隔离级别设置为<code>Read committed</code>，可以避免脏读，但是可能会造成不可重复读。 若避开不可重复读，可以设置隔离级别为<code>Repeatable read</code>。</p><h5 id="_3-幻读" tabindex="-1"><a class="header-anchor" href="#_3-幻读"><span>3.幻读</span></a></h5><p>一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>事务1：B的老婆查看B的卡消费记录，目前共消费了500元。</span></span>
<span class="line"><span>事务2：B此时刚在外面请朋友吃完饭，付款了100，事务已提交。</span></span>
<span class="line"><span>B的老婆决定把账单打印出来，晚上跟B对账，却发现打印出来的消费为600元。她刚才明明看到是500，怎么是600，难道是幻觉？</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Mysql的默认隔离级别为<code>Repeatable read</code>，可以避免不可重复读，但是可能出现幻读的情况。</p><h5 id="_4-序列化-serializable" tabindex="-1"><a class="header-anchor" href="#_4-序列化-serializable"><span>4.序列化(Serializable)</span></a></h5><p>如果要继续解决幻读，那么可以将隔离级别设置为最高级的<code>Serializable</code>，这时候事务都是按照顺序执行的，脏读、幻读、不可重复度都可以避免，但是性能很差。非特殊需求，这种级别一般不用。</p><h2 id="参考文档" tabindex="-1"><a class="header-anchor" href="#参考文档"><span>参考文档</span></a></h2><p><a href="https://www.cnblogs.com/pingguo-softwaretesting/p/14802736.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/pingguo-softwaretesting/p/14802736.html</a> 数据库事务的四种隔离级别知识：<a href="https://mp.weixin.qq.com/s/-5-u8e63dk6y_Apqf5B3Lw" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/-5-u8e63dk6y_Apqf5B3Lw</a></p>`,39),l=[n];function d(r,h){return a(),i("div",null,l)}const o=e(t,[["render",d],["__file","shiwu.html.vue"]]),b=JSON.parse('{"path":"/dataBase/commonOperator/shiwu.html","title":"事务","lang":"zh-CN","frontmatter":{"title":"事务","lang":"zh-CN","date":"2023-09-03T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["dataBase"],"tag":["无"],"filename":"shiwu","slug":"pnha3e","docsId":"45964187","description":"概述 数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。 比如，你有2条sql要执行，如果放到一个事务里，要么2个sql都执行成功，要么都失败。都执行成功了就提交事务，有一个失败了就回滚，不存在一个成...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dataBase/commonOperator/shiwu.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"事务"}],["meta",{"property":"og:description","content":"概述 数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。 比如，你有2条sql要执行，如果放到一个事务里，要么2个sql都执行成功，要么都失败。都执行成功了就提交事务，有一个失败了就回滚，不存在一个成..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-19T14:59:33.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-09-03T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-19T14:59:33.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"事务\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-09-03T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-19T14:59:33.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[]},{"level":2,"title":"事务原则","slug":"事务原则","link":"#事务原则","children":[{"level":5,"title":"1. 原子性(Atomicity)","slug":"_1-原子性-atomicity","link":"#_1-原子性-atomicity","children":[]},{"level":5,"title":"2. 一致性(Consistency)","slug":"_2-一致性-consistency","link":"#_2-一致性-consistency","children":[]},{"level":5,"title":"3. 持久性(Durability)","slug":"_3-持久性-durability","link":"#_3-持久性-durability","children":[]},{"level":5,"title":"4. 隔离性(Isolation)","slug":"_4-隔离性-isolation","link":"#_4-隔离性-isolation","children":[]}]},{"level":2,"title":"数据库事务隔离级别","slug":"数据库事务隔离级别","link":"#数据库事务隔离级别","children":[]},{"level":2,"title":"事务引起的问题","slug":"事务引起的问题","link":"#事务引起的问题","children":[{"level":5,"title":"1. 脏读","slug":"_1-脏读","link":"#_1-脏读","children":[]},{"level":5,"title":"2. 不可重复读","slug":"_2-不可重复读","link":"#_2-不可重复读","children":[]},{"level":5,"title":"3.幻读","slug":"_3-幻读","link":"#_3-幻读","children":[]},{"level":5,"title":"4.序列化(Serializable)","slug":"_4-序列化-serializable","link":"#_4-序列化-serializable","children":[]}]},{"level":2,"title":"参考文档","slug":"参考文档","link":"#参考文档","children":[]}],"git":{"createdTime":1695484404000,"updatedTime":1721401173000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":1}]},"readingTime":{"minutes":4.82,"words":1447},"filePathRelative":"dataBase/commonOperator/shiwu.md","localizedDate":"2023年9月3日","excerpt":"<h2>概述</h2>\\n<p>数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。\\n比如，你有2条sql要执行，如果放到一个事务里，要么2个sql都执行成功，要么都失败。都执行成功了就提交事务，有一个失败了就回滚，不存在一个成功一个失败。</p>\\n<h2>事务原则</h2>\\n<h5>1. 原子性(Atomicity)</h5>\\n<p>比如现在A有800元，B有200元，A给B转账200元。完成此场景有2步，可以当做在一个事务里：</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes github-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span> A：800-200=600</span></span>\\n<span class=\\"line\\"><span> B：200+200=400</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{o as comp,b as data};
