import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as a,d as e}from"./app-Bfb6-vFH.js";const s="/kbms/common/1608790052940-26b83198-1ed6-4081-bffa-fdbb57698925.png",o="/kbms/common/1608789935549-2a974a87-ac01-4574-a566-5a69f4f6d1fa.png",i="/kbms/common/1608790161689-10c84523-3d60-4670-a094-fbf945e9aceb.png",p={},c=e('<h2 id="接收者角度分为三种模式" tabindex="-1"><a class="header-anchor" href="#接收者角度分为三种模式"><span>接收者角度分为三种模式</span></a></h2><p>一对一、一对多、发布订阅</p><blockquote><p>一对一：简单队列模式 一对多：worker模式(并不是发布订阅，而是一个发布者对应多个消费者，但是一个消息只能有一个消费者) 发布订阅包括发布订阅模式、路由模式、通配符模式，因为这三种模式都是使用交换机，只不过类型不同而已。</p></blockquote><table><thead><tr><th>模式名</th><th>模式说明</th><th>一个消息是否可以多个消费者消费</th></tr></thead><tbody><tr><td>简单队列模式</td><td>路由键直接和队列进行绑定</td><td>不支持</td></tr><tr><td>worker模式</td><td>和简单队列模式一样，不过接收者变为多个，多个消费者依次接收</td><td>同一个队列中只会有一个消费，多个队列会依次消费</td></tr><tr><td>fanout(广播模式)</td><td>没有路由键，绑定到该交换机的队列都收到消息</td><td>同一个队列中只会有一个消费，多个队列会有同时消费</td></tr><tr><td>direct(路由模式)</td><td>交换机和队列的路由键需要完全匹配，则转发到对应的队列中</td><td>同一个队列中只会有一个消费，多个队列会有同时消费</td></tr><tr><td>topic(通配符模式)</td><td>交换机和队列的路由键进行模式匹配</td><td>同一个队列中只会有一个消费，多个队列会有同时消费</td></tr></tbody></table><h3 id="简单队列模式" tabindex="-1"><a class="header-anchor" href="#简单队列模式"><span>简单队列模式</span></a></h3><p>这个模式里面并没有交换机的概念，我们通过routeKey与queue完全绑定，一对一接受。</p><h3 id="worker模式-一对多模式" tabindex="-1"><a class="header-anchor" href="#worker模式-一对多模式"><span>Worker模式(一对多模式)</span></a></h3><p>写法和简单队列模式一样，只不过接收者变成了多个，多个消息按照顺序传输给每个接收者。 缺点：</p><blockquote><p>1.丢失数据：一旦其中一个宕机，那么另外的接收者无法接受原来这个接收者要接受的数据(a.b两个接收者，如果该发给j接收者a消息msg时候,a宕机了，然后消息msg就没了，没人处理，解决方案采用消息发送确认) 2.无法实现能者多劳，如果其中的接收者接收的慢，那么会浪费性能，所以应该让实现能者多劳。(通过设置BasicQos来实现能者多劳)</p></blockquote><h3 id="发布订阅模式" tabindex="-1"><a class="header-anchor" href="#发布订阅模式"><span>发布订阅模式</span></a></h3><h4 id="说明" tabindex="-1"><a class="header-anchor" href="#说明"><span>说明</span></a></h4><p>Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键，此外 headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了。</p><h4 id="fanout-发布订阅模式-不处理路由键、子网广播" tabindex="-1"><a class="header-anchor" href="#fanout-发布订阅模式-不处理路由键、子网广播"><span>fanout(发布订阅模式)：不处理路由键、子网广播</span></a></h4><p><img src="'+s+'" alt="image.png" loading="lazy"> 向多个使用者传递一个消息，叫做“发布/订阅”,每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。</p><h5 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景</span></a></h5><p>一个生产者发布了消息后，多个消费者去接受这同一个消息进行处理，通过队列名称去订阅消息。比如日志系统中接受所有类型的消息。</p><h5 id="测试结果" tabindex="-1"><a class="header-anchor" href="#测试结果"><span>测试结果</span></a></h5><p>如果一个交换机a去发布消息，只要队列和这个交换机a绑定，那么这几个队列都能收到相同的消息，但是如果将一个队列b启动两份(两个消费者在同一个队列中)，这个时候a去发布消息，两个消费者轮流去接收消息。</p><h4 id="direct-路由模式-完全匹配、单播" tabindex="-1"><a class="header-anchor" href="#direct-路由模式-完全匹配、单播"><span>direct(路由模式)：完全匹配、单播</span></a></h4><p><img src="'+o+`" alt="image.png" loading="lazy"> 消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发 routing key 标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。它是完全匹配、单播的模式(并不是一个消息只能一个队列接受，只要队列和交换机绑定了，并且路由键一样，就可以接收)。</p><h5 id="测试结果-1" tabindex="-1"><a class="header-anchor" href="#测试结果-1"><span>测试结果</span></a></h5><p>交换机a发出来消息，路由键是b，然后不同的队列c和d去绑定到这个交换机，路由键都是b，这个时候a发出来一个消息，c和d都可以收到。</p><h5 id="使用场景-1" tabindex="-1"><a class="header-anchor" href="#使用场景-1"><span>使用场景</span></a></h5><p>一个发多个接收，但是消费者不应该在一个队列，通过路由键完全匹配去订阅消息。比如说日志系统中只接受特定类型的消息。 示例一</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code>一个队列d下绑定了两个路由键j1和j2，
交换机j下绑定了两个路由键j1和j2，
这个时候我发消息到交换机j的j1队列，那么默认配置下队列d下的所有路由键会轮着收到消息，不过事件总线会在接受到消息后根据不同的路由键转到不同的处理器里面，默认rabbitmq下监听该队列的服务器会收到到这个队列的所有消息
consumer<span class="token punctuation">.</span>Received <span class="token operator">+=</span> <span class="token punctuation">(</span>model<span class="token punctuation">,</span> ea<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
<span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ea<span class="token punctuation">.</span>RoutingKey <span class="token operator">==</span> routingKey<span class="token punctuation">)</span><span class="token comment">//增加判断，但是缺点就是这里判断没有收的消息就收不到了</span>
	<span class="token punctuation">{</span>
		<span class="token class-name"><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> message <span class="token operator">=</span> ea<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">ToArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//接收到的消息</span>
		Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;接收到信息为:&quot;</span> <span class="token operator">+</span> Encoding<span class="token punctuation">.</span>UTF8<span class="token punctuation">.</span><span class="token function">GetString</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//返回消息确认  手动确认</span>
		channel<span class="token punctuation">.</span><span class="token function">BasicAck</span><span class="token punctuation">(</span>ea<span class="token punctuation">.</span>DeliveryTag<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="topic-通配符模式-模糊匹配" tabindex="-1"><a class="header-anchor" href="#topic-通配符模式-模糊匹配"><span>topic(通配符模式)：模糊匹配</span></a></h4><p><img src="`+i+'" alt="image.png" loading="lazy"> topic交换器通过模式匹配分配消息的路由键属性，将路由键和某一个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定建的字符串切分成单词，这些单词之间用点隔开(必须使用点分割字符串)。它同样也会识别两个通配符：符号“#”和符号“*”。</p><blockquote><p>符号“#”匹配一个或多个词，符号“<em>”匹配不多不少一个词。因此“log.#”能够匹配到“log.info.oa”，但是“log.</em>” 只会匹配到“log.error”。topic exchange使用非常灵活。</p></blockquote><h5 id="测试结果-2" tabindex="-1"><a class="header-anchor" href="#测试结果-2"><span>测试结果</span></a></h5><p>交换机a发布消息，队列b(路由键是info.#)和c(路由键是info.*)接收消息，如果a发消息时候路由键是info.aa，那么b，c都可以收到消息，如果发送消息的时候路由键是info.aa.bb,那么只有b才能收到消息</p><h5 id="使用场景-2" tabindex="-1"><a class="header-anchor" href="#使用场景-2"><span>使用场景</span></a></h5><p>一个发多个接收，但是消费者不应该在一个队列，通过路由键匹配规则去订阅消息</p><h2 id="注意" tabindex="-1"><a class="header-anchor" href="#注意"><span>注意</span></a></h2><blockquote><p>路由键可以是动态的 一个交换机可以绑定到多个路由键 一个队列可以绑定到多个路由键 两个消费者属于同一个队列是轮流接受消息的 一个消息在同一个队列内只能被消费一次</p></blockquote>',34),r=[c];function l(d,u){return t(),a("div",null,r)}const b=n(p,[["render",l],["__file","rabbitmqmoshi.html.vue"]]),k=JSON.parse('{"path":"/middleware/xiaoxiduilie/rabbitmq/rabbitmqmoshi.html","title":"RabbitMQ模式","lang":"zh-CN","frontmatter":{"title":"RabbitMQ模式","lang":"zh-CN","date":"2023-09-25T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["middleware"],"tag":["无"],"filename":"rabbitmqmoshi","slug":"wvtfut","docsId":"26372177","description":"接收者角度分为三种模式 一对一、一对多、发布订阅 一对一：简单队列模式 一对多：worker模式(并不是发布订阅，而是一个发布者对应多个消费者，但是一个消息只能有一个消费者) 发布订阅包括发布订阅模式、路由模式、通配符模式，因为这三种模式都是使用交换机，只不过类型不同而已。 简单队列模式 这个模式里面并没有交换机的概念，我们通过routeKey与que...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/middleware/xiaoxiduilie/rabbitmq/rabbitmqmoshi.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"RabbitMQ模式"}],["meta",{"property":"og:description","content":"接收者角度分为三种模式 一对一、一对多、发布订阅 一对一：简单队列模式 一对多：worker模式(并不是发布订阅，而是一个发布者对应多个消费者，但是一个消息只能有一个消费者) 发布订阅包括发布订阅模式、路由模式、通配符模式，因为这三种模式都是使用交换机，只不过类型不同而已。 简单队列模式 这个模式里面并没有交换机的概念，我们通过routeKey与que..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://azrng.gitee.io/kbms/kbms/common/1608790052940-26b83198-1ed6-4081-bffa-fdbb57698925.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-10-19T14:00:28.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-09-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-10-19T14:00:28.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RabbitMQ模式\\",\\"image\\":[\\"https://azrng.gitee.io/kbms/kbms/common/1608790052940-26b83198-1ed6-4081-bffa-fdbb57698925.png\\",\\"https://azrng.gitee.io/kbms/kbms/common/1608789935549-2a974a87-ac01-4574-a566-5a69f4f6d1fa.png\\",\\"https://azrng.gitee.io/kbms/kbms/common/1608790161689-10c84523-3d60-4670-a094-fbf945e9aceb.png\\"],\\"datePublished\\":\\"2023-09-25T00:00:00.000Z\\",\\"dateModified\\":\\"2023-10-19T14:00:28.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"接收者角度分为三种模式","slug":"接收者角度分为三种模式","link":"#接收者角度分为三种模式","children":[{"level":3,"title":"简单队列模式","slug":"简单队列模式","link":"#简单队列模式","children":[]},{"level":3,"title":"Worker模式(一对多模式)","slug":"worker模式-一对多模式","link":"#worker模式-一对多模式","children":[]},{"level":3,"title":"发布订阅模式","slug":"发布订阅模式","link":"#发布订阅模式","children":[{"level":4,"title":"说明","slug":"说明","link":"#说明","children":[]},{"level":4,"title":"fanout(发布订阅模式)：不处理路由键、子网广播","slug":"fanout-发布订阅模式-不处理路由键、子网广播","link":"#fanout-发布订阅模式-不处理路由键、子网广播","children":[{"level":5,"title":"使用场景","slug":"使用场景","link":"#使用场景","children":[]},{"level":5,"title":"测试结果","slug":"测试结果","link":"#测试结果","children":[]}]},{"level":4,"title":"direct(路由模式)：完全匹配、单播","slug":"direct-路由模式-完全匹配、单播","link":"#direct-路由模式-完全匹配、单播","children":[{"level":5,"title":"测试结果","slug":"测试结果-1","link":"#测试结果-1","children":[]},{"level":5,"title":"使用场景","slug":"使用场景-1","link":"#使用场景-1","children":[]}]},{"level":4,"title":"topic(通配符模式)：模糊匹配","slug":"topic-通配符模式-模糊匹配","link":"#topic-通配符模式-模糊匹配","children":[{"level":5,"title":"测试结果","slug":"测试结果-2","link":"#测试结果-2","children":[]},{"level":5,"title":"使用场景","slug":"使用场景-2","link":"#使用场景-2","children":[]}]}]}]},{"level":2,"title":"注意","slug":"注意","link":"#注意","children":[]}],"git":{"createdTime":1697724028000,"updatedTime":1697724028000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":1}]},"readingTime":{"minutes":6.14,"words":1843},"filePathRelative":"middleware/xiaoxiduilie/rabbitmq/rabbitmqmoshi.md","localizedDate":"2023年9月25日","excerpt":"<h2>接收者角度分为三种模式</h2>\\n<p>一对一、一对多、发布订阅</p>\\n<blockquote>\\n<p>一对一：简单队列模式\\n一对多：worker模式(并不是发布订阅，而是一个发布者对应多个消费者，但是一个消息只能有一个消费者)\\n发布订阅包括发布订阅模式、路由模式、通配符模式，因为这三种模式都是使用交换机，只不过类型不同而已。</p>\\n</blockquote>\\n<table>\\n<thead>\\n<tr>\\n<th>模式名</th>\\n<th>模式说明</th>\\n<th>一个消息是否可以多个消费者消费</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>简单队列模式</td>\\n<td>路由键直接和队列进行绑定</td>\\n<td>不支持</td>\\n</tr>\\n<tr>\\n<td>worker模式</td>\\n<td>和简单队列模式一样，不过接收者变为多个，多个消费者依次接收</td>\\n<td>同一个队列中只会有一个消费，多个队列会依次消费</td>\\n</tr>\\n<tr>\\n<td>fanout(广播模式)</td>\\n<td>没有路由键，绑定到该交换机的队列都收到消息</td>\\n<td>同一个队列中只会有一个消费，多个队列会有同时消费</td>\\n</tr>\\n<tr>\\n<td>direct(路由模式)</td>\\n<td>交换机和队列的路由键需要完全匹配，则转发到对应的队列中</td>\\n<td>同一个队列中只会有一个消费，多个队列会有同时消费</td>\\n</tr>\\n<tr>\\n<td>topic(通配符模式)</td>\\n<td>交换机和队列的路由键进行模式匹配</td>\\n<td>同一个队列中只会有一个消费，多个队列会有同时消费</td>\\n</tr>\\n</tbody>\\n</table>","autoDesc":true}');export{b as comp,k as data};
