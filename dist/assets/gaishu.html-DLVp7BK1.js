import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o,c,a as n,b as s,d as e,e as l}from"./app-vSdX8vi3.js";const i={},r=l(`<h2 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍"><span>介绍</span></a></h2><p>依赖注入是一种具体的编码技巧(是控制反转思想的一种重要的实现方式)，英文翻译是Dependency Injection，缩写DI。</p><p>不要依赖于具体的实现，应该依赖于抽象，高层模块不应该依赖于底层模块，二者应该依赖于抽象。简单的说就是为了更好的解耦。而控制反转(Ioc)就是这样的原则的其中一个<strong>实现思想</strong>, 这个思路的其中一种实现方式就是依赖注入(DI)。只要是用过new实例化的都是存在依赖的。</p><p>不用过new()的方式在类的内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递(或者注入)给类使用。</p><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点</span></a></h3><p>1.传统的程序，每个对象负责管理与自己需要依赖的对象，导致如果需要切换依赖对象的实现类时候，需要改动比较大。 2.依赖注入把对象的创建交给外部去管理，很好的解决了代码耦合的问题，是一种让代码实现松耦合的机制。 3.松耦合使代码更具有灵活性，能更好的应对需求变动，以及方便单元测试。</p><h3 id="依赖注入vs工厂模式" tabindex="-1"><a class="header-anchor" href="#依赖注入vs工厂模式"><span>依赖注入VS工厂模式</span></a></h3><p>(1)原始社会里，没有社会分工。须要斧子的人(调用者)仅仅能自己去磨一把斧子(被调用者)。相应的情形为:软件程序里的调用者自己创建被调用者。 (2)进入工业社会，工厂出现。斧子不再由普通人完毕，而在工厂里被生产出来，此时须要斧子的人(调用者)找到工厂，购买斧子，无须关心斧子的制造过程。相应软件程序的简单工厂的设计模式。 (3)进入“按需分配”社会，需要斧子的人不需要找到工厂，坐在家里发出一个简单指令:须要斧子。斧子就自然出如今他面前。比如.NetCore的<strong>依赖注入</strong>。</p><h2 id="实现原理" tabindex="-1"><a class="header-anchor" href="#实现原理"><span>实现原理</span></a></h2><p>实现DI，核心在于注入容器（IContainer），该容器具有下面的以下功能 1.容器保存可用的服务集合 2.提供一种方式将各种部件与他们依赖的服务绑定到一起 3.为应用程序提供一种方式来请求已配置的对象：构造函数注入、属性注入， 运行时，框架会一层层通过反射构造事例，最终得到完整的对象。 <strong>利用反射产生对象是依赖注入的核心过程。</strong></p><h2 id="项目中依赖例子" tabindex="-1"><a class="header-anchor" href="#项目中依赖例子"><span>项目中依赖例子</span></a></h2><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">D</span></span>
<span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token class-name">B</span> b<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// do something   </span>
    <span class="token punctuation">}</span>
    <span class="token class-name">C</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>就比如说我们项目中的控制器，只要是通过new实例化的，都是存在依赖的</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span>List<span class="token punctuation">&lt;</span>Advertisement<span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">Get</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> id<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">IAdvertisementServices</span> advertisementServices <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">AdvertisementServices</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">await</span> advertisementServices<span class="token punctuation">.</span><span class="token function">Query</span><span class="token punctuation">(</span>d <span class="token operator">=&gt;</span> d<span class="token punctuation">.</span>Id <span class="token operator">==</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>日志记录：有时需要调试分析，需要记录日志信息，这时可以采用输出到控制台、文件、数据库、远程服务器等；假设最初采用输出到控制台，直接在程序中实例化ILogger logger = new ConsoleLogger()，但有时又需要输出到别的文件中，也许关闭日志输出，就需要更改程序，把ConsoleLogger改成FileLogger或者NoLogger， new FileLogger()或者new SqlLogger() ，此时不断的更改代码，就显得不好了，如果采用依赖注入，就显得特别舒畅。</p><h2 id="依赖注入框架" tabindex="-1"><a class="header-anchor" href="#依赖注入框架"><span>依赖注入框架</span></a></h2><p>通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架自动创建对象、管理对象的生命周期、依赖注入等原来需要程序来做的事情。</p><p>比如：AutoFac、.NetCore默认IOC</p><h2 id="注入方式" tabindex="-1"><a class="header-anchor" href="#注入方式"><span>注入方式</span></a></h2><h3 id="构造函数注入" tabindex="-1"><a class="header-anchor" href="#构造函数注入"><span>构造函数注入</span></a></h3><p>在<code>LoggerServer</code>类中，定义一个私有变量<code>_logger</code>, 然后通过构造函数的方式传递依赖</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoggerServer</span>
<span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">ILogger</span> _logger<span class="token punctuation">;</span> <span class="token comment">//1. 定义私有变量</span>
    <span class="token comment">//2.构造函数</span>
    <span class="token keyword">public</span> <span class="token function">LoggerServer</span><span class="token punctuation">(</span><span class="token class-name">ILogger</span> logger<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">//3.注入 ，传递依赖</span>
     <span class="token keyword">this</span><span class="token punctuation">.</span>_logger <span class="token operator">=</span> logger<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">AddLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      _logger<span class="token punctuation">.</span><span class="token function">AddLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过控制台程序调用，先在外部创建依赖对象，而后通过构造的方式注入依赖</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code>        <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token preprocessor property">#<span class="token directive keyword">region</span> 构造函数注入</span>
            <span class="token comment">// 注入控制台输出方式</span>
            <span class="token comment">// 外部创建依赖的对象 -&gt; ConsoleLogger</span>
            <span class="token class-name">ConsoleLogger</span> console <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ConsoleLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 通过构造函数注入 -&gt; LoggerServer</span>
            <span class="token class-name">LoggerServer</span> loggerServer1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">LoggerServer</span><span class="token punctuation">(</span>console<span class="token punctuation">)</span><span class="token punctuation">;</span>
            loggerServer1<span class="token punctuation">.</span><span class="token function">AddLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


            <span class="token comment">// 注入 文件输出方式</span>
            <span class="token class-name">FileLogger</span> file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">FileLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 通过构造函数注入 -&gt; LoggerServer</span>
            <span class="token class-name">LoggerServer</span> loggerServer2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">LoggerServer</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
            loggerServer2<span class="token punctuation">.</span><span class="token function">AddLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            
            <span class="token preprocessor property">#</span><span class="token return-type class-name">endregion</span>

            Console<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="属性注入" tabindex="-1"><a class="header-anchor" href="#属性注入"><span>属性注入</span></a></h3><p>通过定义一个属性来传递依赖</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token doc-comment comment">/// <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>summary</span><span class="token punctuation">&gt;</span></span></span>
<span class="token doc-comment comment">/// 定义一个输出日志的统一类</span>
<span class="token doc-comment comment">/// <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>summary</span><span class="token punctuation">&gt;</span></span></span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoggerServer</span>
<span class="token punctuation">{</span>
	<span class="token comment">//1.定义一个属性，可接收外部赋值依赖</span>
	<span class="token keyword">public</span> <span class="token return-type class-name">ILogger</span> _logger <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">AddLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		_logger<span class="token punctuation">.</span><span class="token function">AddLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过控制台，定义不同的方式，通过不同依赖赋值，实现不同的验证结果：</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token preprocessor property">#<span class="token directive keyword">region</span> 属性注入</span>
	<span class="token comment">// 注入 控制台输出方式</span>

	<span class="token comment">//外部创建依赖的对象 -&gt; ConsoleLogger</span>
	<span class="token class-name">ConsoleLogger</span> console <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ConsoleLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">LoggerServer</span> loggerServer1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">LoggerServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//给内部的属性赋值</span>
	loggerServer1<span class="token punctuation">.</span>_logger <span class="token operator">=</span> console<span class="token punctuation">;</span>
	loggerServer1<span class="token punctuation">.</span><span class="token function">AddLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 注入 文件输出方式</span>

	<span class="token comment">//外部创建依赖的对象 -&gt; FileLogger</span>
	<span class="token class-name">FileLogger</span> file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">FileLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">LoggerServer</span> loggerServer2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">LoggerServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//给内部的属性赋值</span>
	loggerServer2<span class="token punctuation">.</span>_logger <span class="token operator">=</span> file<span class="token punctuation">;</span>
	loggerServer2<span class="token punctuation">.</span><span class="token function">AddLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token preprocessor property">#</span><span class="token return-type class-name">endregion</span>

	Console<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="接口注入" tabindex="-1"><a class="header-anchor" href="#接口注入"><span>接口注入</span></a></h3><p>先定义一个接口，包含一个设置依赖的方法。</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IDependent</span>
<span class="token punctuation">{</span>
	<span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SetDepend</span><span class="token punctuation">(</span><span class="token class-name">ILogger</span> logger<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置依赖项</span>
<span class="token punctuation">}</span>	
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个与之前的注入方式不一样，而是通过在类中**「继承并实现这个接口」**。</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VerificationServer</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IDependent</span></span>
<span class="token punctuation">{</span>
	<span class="token keyword">private</span> <span class="token class-name">ILogger</span> _logger<span class="token punctuation">;</span>
	<span class="token comment">// 继承接口，并实现依赖项方法，注入依赖</span>
	<span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SetDepend</span><span class="token punctuation">(</span><span class="token class-name">ILogger</span> logger<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		_logger <span class="token operator">=</span> logger<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">AddLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		_logger<span class="token punctuation">.</span><span class="token function">AddLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过调用，直接通过依赖项方法，传递依赖</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token preprocessor property">#<span class="token directive keyword">region</span> 接口注入</span>
	<span class="token comment">// 注入 控制台输出方式</span>
	<span class="token comment">//外部创建依赖的对象 -&gt; ConsoleLogger</span>
	<span class="token class-name">ConsoleLogger</span> console <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ConsoleLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">LoggerServer</span> loggerServer1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">LoggerServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//给内部赋值，通过接口的方式传递</span>
	loggerServer1<span class="token punctuation">.</span><span class="token function">SetDepend</span><span class="token punctuation">(</span>console<span class="token punctuation">)</span><span class="token punctuation">;</span>
	loggerServer1<span class="token punctuation">.</span><span class="token function">AddLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//注入  文件输出方式</span>
	<span class="token comment">//外部创建依赖的对象 -&gt; FileLogger</span>
	<span class="token class-name">FileLogger</span> file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">FileLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">LoggerServer</span> loggerServer2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">LoggerServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
	<span class="token comment">//给内部赋值，通过接口的方式传递</span>
	loggerServer2<span class="token punctuation">.</span><span class="token function">SetDepend</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
	loggerServer2<span class="token punctuation">.</span><span class="token function">AddLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token preprocessor property">#</span><span class="token return-type class-name">endregion</span>

	Console<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="资料" tabindex="-1"><a class="header-anchor" href="#资料"><span>资料</span></a></h2>`,37),u={href:"https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.2",target:"_blank",rel:"noopener noreferrer"},d={href:"https://www.cnblogs.com/jesse2013/p/di-in-aspnetcore.html",target:"_blank",rel:"noopener noreferrer"},k={href:"https://www.cnblogs.com/artech/p/di-asp-net-core-pipeline-2.html",target:"_blank",rel:"noopener noreferrer"},v={href:"https://www.cnblogs.com/viter/p/11085318.html",target:"_blank",rel:"noopener noreferrer"},m={href:"http://www.cnblogs.com/ShenNan/p/10256562.html",target:"_blank",rel:"noopener noreferrer"};function g(b,h){const a=p("ExternalLinkIcon");return o(),c("div",null,[r,n("p",null,[n("a",u,[s("[官方]ASP.NET Core 依赖注入"),e(a)]),n("a",d,[s("全面理解 ASP.NET Core 依赖注入"),e(a)]),s(" 官方推荐通过构造函数，也就是所谓的显示依赖。 "),n("a",k,[s("ASP.NET Core 中依赖注入的N种玩法"),e(a)]),n("a",v,[s("ASP.NET Core 自定义特性实现属性注入"),e(a)]),n("a",m,[s("ASP.NET Core 原生DI实现批量注册"),e(a)])])])}const f=t(i,[["render",g],["__file","gaishu.html.vue"]]),L=JSON.parse('{"path":"/dotnet/base/yilaizhuru/gaishu.html","title":"概述","lang":"zh-CN","frontmatter":{"title":"概述","lang":"zh-CN","date":"2022-11-20T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["dotNET"],"tag":["无"],"filename":"gaishu","slug":"cyrwmb","docsId":"29987940","description":"介绍 依赖注入是一种具体的编码技巧(是控制反转思想的一种重要的实现方式)，英文翻译是Dependency Injection，缩写DI。 不要依赖于具体的实现，应该依赖于抽象，高层模块不应该依赖于底层模块，二者应该依赖于抽象。简单的说就是为了更好的解耦。而控制反转(Ioc)就是这样的原则的其中一个实现思想, 这个思路的其中一种实现方式就是依赖注入(DI...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dotnet/base/yilaizhuru/gaishu.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"概述"}],["meta",{"property":"og:description","content":"介绍 依赖注入是一种具体的编码技巧(是控制反转思想的一种重要的实现方式)，英文翻译是Dependency Injection，缩写DI。 不要依赖于具体的实现，应该依赖于抽象，高层模块不应该依赖于底层模块，二者应该依赖于抽象。简单的说就是为了更好的解耦。而控制反转(Ioc)就是这样的原则的其中一个实现思想, 这个思路的其中一种实现方式就是依赖注入(DI..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-10-25T13:23:37.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2022-11-20T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-10-25T13:23:37.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"概述\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-11-20T00:00:00.000Z\\",\\"dateModified\\":\\"2023-10-25T13:23:37.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"介绍","slug":"介绍","link":"#介绍","children":[{"level":3,"title":"优点","slug":"优点","link":"#优点","children":[]},{"level":3,"title":"依赖注入VS工厂模式","slug":"依赖注入vs工厂模式","link":"#依赖注入vs工厂模式","children":[]}]},{"level":2,"title":"实现原理","slug":"实现原理","link":"#实现原理","children":[]},{"level":2,"title":"项目中依赖例子","slug":"项目中依赖例子","link":"#项目中依赖例子","children":[]},{"level":2,"title":"依赖注入框架","slug":"依赖注入框架","link":"#依赖注入框架","children":[]},{"level":2,"title":"注入方式","slug":"注入方式","link":"#注入方式","children":[{"level":3,"title":"构造函数注入","slug":"构造函数注入","link":"#构造函数注入","children":[]},{"level":3,"title":"属性注入","slug":"属性注入","link":"#属性注入","children":[]},{"level":3,"title":"接口注入","slug":"接口注入","link":"#接口注入","children":[]}]},{"level":2,"title":"资料","slug":"资料","link":"#资料","children":[]}],"git":{"createdTime":1697962303000,"updatedTime":1698240217000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":1}]},"readingTime":{"minutes":5.71,"words":1713},"filePathRelative":"dotnet/base/yilaizhuru/gaishu.md","localizedDate":"2022年11月20日","excerpt":"<h2>介绍</h2>\\n<p>依赖注入是一种具体的编码技巧(是控制反转思想的一种重要的实现方式)，英文翻译是Dependency Injection，缩写DI。</p>\\n<p>不要依赖于具体的实现，应该依赖于抽象，高层模块不应该依赖于底层模块，二者应该依赖于抽象。简单的说就是为了更好的解耦。而控制反转(Ioc)就是这样的原则的其中一个<strong>实现思想</strong>, 这个思路的其中一种实现方式就是依赖注入(DI)。只要是用过new实例化的都是存在依赖的。</p>\\n<p>不用过new()的方式在类的内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递(或者注入)给类使用。</p>","autoDesc":true}');export{f as comp,L as data};
