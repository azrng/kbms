import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as e,d as t}from"./app-BguyEeV-.js";const a={},n=t(`<h2 id="intro" tabindex="-1"><a class="header-anchor" href="#intro"><span>Intro</span></a></h2><blockquote><p>“不会写单元测试的程序员不是合格的程序员，不写单元测试的程序员不是优秀的工程师。” —— 一只想要成为一个优秀程序员的渣逼程序猿。</p></blockquote><p>那么问题来了，什么是单元测试，如何做单元测试。</p><h2 id="单元测试" tabindex="-1"><a class="header-anchor" href="#单元测试"><span>单元测试</span></a></h2><h3 id="单元测试的定义" tabindex="-1"><a class="header-anchor" href="#单元测试的定义"><span>单元测试的定义</span></a></h3><p>对程序员自己编写的代码中的方法或者函数进行测试，并非是端到端的集成测试，不需要依赖外部系统的逻辑正确性。 按照维基百科上的说法，单元测试（Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。 程序单元是应用的最小可测试部件。在面向对象编程中，最小单元就是方法，包括基类、抽象类、或者派生类（子类）中的方法。 按照通俗的理解，一个单元测试判断某个特定场条件下某个特定方法的行为，如斐波那契数列算法，冒泡排序算法。</p><blockquote><p>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。 对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义， 如C语言中单元指一个函数，Java里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。 总的来说，单元就是人为规定的最小的被测功能模块。 单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。 —— 百度百科 <a href="http://baike.baidu.com/view/106237.htm" target="_blank" rel="noopener noreferrer">http://baike.baidu.com/view/106237.htm</a></p></blockquote><h3 id="单元测试的好处" tabindex="-1"><a class="header-anchor" href="#单元测试的好处"><span>单元测试的好处</span></a></h3><ol><li>它是一种验证行为 <ol><li>程序中的每一项功能都是测试来验证它的正确性。</li></ol></li><li>它是一种设计行为 <ol><li>编写单元测试将使我们从调用者观察、思考。 特别是先写测试（test-first），迫使我们把程序设计成易于调用和可测试的，有利于程序的解耦和模块化。</li></ol></li><li>它是一种编写文档的行为 <ol><li>单元测试是一种无价的文档，它是展示函数或类如何使用的最佳文档。这份文档是可编译、可运行的，并且它保持最新，永远与代码同步。</li></ol></li><li>它具有回归性 <ol><li>自动化的单元测试避免了代码出现回归，编写完成之后，可以随时随地的快速运行测试。</li></ol></li><li>高效自动化的 <ol><li>单元测试节省了开发上调试BUG的时间，绝大多数BUG可以通过单元测试测试出来，并且可以减少测试人员的测试时间。有时候通过写单元测试能够更好的完善自己程序的逻辑，让程序变得更加美好。</li></ol></li></ol><p>—— 单元测试的优点 <a href="http://jingyan.baidu.com/article/d713063522ab4e13fdf47533.html" target="_blank" rel="noopener noreferrer">http://jingyan.baidu.com/article/d713063522ab4e13fdf47533.html</a></p><p>1.单元测试能够有效地帮你发现代码中的bug 2.写单元测试能否帮你发现代码设计上的问题</p><blockquote><p>如果写起来比较吃力，需要依赖单元测试框架里面很高级的特性才能完成，往往就意味着代码设计不够合理，比如没有使用单元测试、大量使用静态函数、全局变量、代码高度耦合等。</p></blockquote><p>3.单元测试是对集成测试的有力补充</p><blockquote><p>程序运行的bug往往出现在一些边界的条件、异常的情况下，比如说除数未判空、网络超时，而大部分异常情况都比较难在测试环境中模拟。单元测试可以利用mock的方式，来返回</p></blockquote><p>4.写单元测试的过程本身就是代码重构的过程 编写单元测试的时候就是相当于代码的一次自我code review，在这个过程中，我们可以发现一些设计上的问题(代码设计的不可测试)以及代码编写方面的问题(比如一些边界条件处理不当)，然后针对性进行重构。 5.阅读单元测试能够帮你快速熟悉代码</p><blockquote><p>阅读代码的有效手段就是先去连接业务背景和设计思路，然后再去看代码。但是一般程序员不喜欢写文档和注释，那么这个时候单元测试就是用户用例，反映了代码的功能和如何使用。借助单元测试，我们不需要深入阅读代码，就可以知道代码实现了上面功能，有哪些特殊的情况需要考虑，有哪些边界条件需要处理</p></blockquote><p>6.单元测试是TDD可落地执行的改进方案</p><blockquote><p>测试驱动开发(test-driven development，简称TDD)是一个开发模式，核心思想就是测试用例优先于代码编写。</p></blockquote><blockquote><p>单元测试正好是到TDD的一种改进方案，先写代码，然后紧接着编写单元测试，最后单元测试反馈出来问题，再回过头去重构代码，这个流程更容易被接受。</p></blockquote><h3 id="单元测试的原则" tabindex="-1"><a class="header-anchor" href="#单元测试的原则"><span>单元测试的原则</span></a></h3><ul><li>可重复运行的</li><li>持续长期有效，并且返回一致的结果</li><li>在内存中运行，没有外部依赖组件（比如说真实的数据库，真实的文件存储等）</li><li>快速返回结果</li><li>一个测试方法只测试一个问题</li></ul><h3 id="什么是好的单元测试" tabindex="-1"><a class="header-anchor" href="#什么是好的单元测试"><span>什么是好的单元测试</span></a></h3><p>容易写：容易编写所有的测试例子，而无需付出很大的努力 可读：应该很容易理解正在测试的场景，并且如果测试失败则很容易检测到如何解决问题。通过良好的单元测试，我们可以在不实际调试代码的情况下修复错误 可靠：好的单元测试应该具有可重复性，并且不受外界因素的影响。 快速： 真正的单元测试，而不是集成测试：单元测试和被测系统都不应该访问网络资源，数据库，文件系统等，以消除外部因素的影响。</p><h3 id="对比集成测试" tabindex="-1"><a class="header-anchor" href="#对比集成测试"><span>对比集成测试</span></a></h3><p>相对于集成测试(Integration Testing)来说，单元测试粒度更小一些。集成测试的测试是整个系统或者某个功能模块，比如测试用户注册、登录功能是否这个呢从，是一种端到端的测试。而单元测试测试对象是类或者函数，用来测试一个类或者函数是否都按照预期的逻辑执行，这是代码层级的测试。</p><h3 id="如何编写单元测试" tabindex="-1"><a class="header-anchor" href="#如何编写单元测试"><span>如何编写单元测试</span></a></h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>单元测试主要用于测试领域模型，对于诸如应用服务、Controller以及事件处理器等结构型设施不做单元测试要求，因为这些类并不包含太多的逻辑</p></div><p>针对一个要测试的方法，要编写测试用例。也就是说尽可能全面覆盖各种正常和异常的情况。 比如一个转账的操作，测试用例可以是正常情况操作交易成功、交易过期、交易已经执行，不需要重复执行、钱包转钱失败、交易正在执行。 但是里面涉及到了其他服务，比如说需要redis、或者第三方服务，如果你去搭建这些服务，那么就不满足单元测试的定义。</p><p>单元测试不需要依赖外部系统，如果依赖了，那么我们就需要将被测试的代码与外部的系统解依赖，这种方法就是mock，也就是说模拟一个假的服务去替换真的服务。mock的服务完全在我们的控制之下，模拟输出我们想要的数据。</p><p>最佳实践：<a href="https://learn.microsoft.com/zh-cn/dotnet/core/testing/unit-testing-best-practices" target="_blank" rel="noopener noreferrer">https://learn.microsoft.com/zh-cn/dotnet/core/testing/unit-testing-best-practices</a></p><h2 id="net-中的测试框架" tabindex="-1"><a class="header-anchor" href="#net-中的测试框架"><span>.NET 中的测试框架</span></a></h2><p>现在比较流行的测试框架包括微软的 MS Test(VS Test)、NUnit、XUnit</p><h3 id="ms-test" tabindex="-1"><a class="header-anchor" href="#ms-test"><span>MS Test</span></a></h3><p>VS单元测试的主要类：Assert、StringAssert、CollectionAssert，具体可参照 <a href="https://msdn.microsoft.com/zh-cn/library/Microsoft.VisualStudio.TestTools.UnitTesting.aspx" target="_blank" rel="noopener noreferrer">MSDN</a>介绍 有些时候我们需要对测试的方法用到的数据或配置进行初始化，有几个特殊的测试方法。 如果需要针对测试中的所有虚拟用户迭代仅执行一次初始化操作，请使用 TestInitializeAttribute。 初始化方法的运行顺序如下：</p><ol><li>用 AssemblyInitializeAttribute 标记的方法。</li><li>用 ClassInitializeAttribute 特性标记的方法。</li><li>用 TestInitializeAttribute 特性标记的方法。</li><li>用 TestMethodAttribute 特性标记的方法。</li></ol><p>使用 VS Test 的时候，首先我们需要标记测试方法所在类 TestClass，测试方法标记为 TestMethod</p><h3 id="nunit" tabindex="-1"><a class="header-anchor" href="#nunit"><span>NUnit</span></a></h3><p>NUnit 测试框架使用方法与 MS Test 类似 有一些是 NUnit 中的，但是MS Test框架中是没有的： Assert.IsNaN/Assert.IsEmpty/Assert.IsNotEmpty/Assert.Greater/Assert.GreaterOrEqual 等 想要同时使用 VS Test 和 NUnit 的话可以使用宏来区分不同的测试框架，例如：</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">#</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> !</span><span style="--shiki-light:#6F42C1;--shiki-dark:#ABB2BF;">NUNIT</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Microsoft</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">VisualStudio</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">TestTools</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">UnitTesting</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Category</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Microsoft</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">VisualStudio</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">TestTools</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">UnitTesting</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">DescriptionAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">#</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">else</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> NUnit</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Framework</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> TestClass</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> NUnit</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Framework</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">TestFixtureAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> TestMethod</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> NUnit</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Framework</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">TestAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> TestInitialize</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> NUnit</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Framework</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">SetUpAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> TestCleanup</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> NUnit</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Framework</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">TearDownAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> TestContext</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> System</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> ClassCleanup</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> NUnit</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Framework</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">TestFixtureTearDownAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> ClassInitialize</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> NUnit</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Framework</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">TestFixtureSetUpAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">#</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">endif</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面可以看得出来 nunit 很多东西和 vs test 是很类似的，声明测试类，测试方法，初始化方法等</p><h3 id="xunit" tabindex="-1"><a class="header-anchor" href="#xunit"><span>XUnit</span></a></h3><p>XUnit 是另一个测试框架，个人觉得 XUnit 测试更加简洁一些，初始化和释放资源不需要标记单独的方法，初始化直接放在构造方法里，资源释放实现 IDisposable 接口，在 Dispose 方法中进行测试的清理工作即可，相比 ms test（vs test）和 NUnit，我觉得 Xunit 更方便一些，并且对于 Assert ，xunit 更简洁，例如： 在 ms test 中的 Assert.IsNull(null);/Assert.IsTrue(1 == 1); 在 xunit 中则是 Assert.Null(null);/Assert.True(1 == 1);，虽然看上去差不多，但是写的多了就会觉得 xunit 更简洁一些。 xunit 不需要对测试方法所在类型标记 TestClass ，只需要在测试方法上标记 Fact 或者使用数据驱动的 Theory</p><p>三个A： Arrange ------&gt; Act -----&gt;Assert</p><blockquote><p>断言：<a href="https://www.cnblogs.com/zuiailiuruoying/p/14458648.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/zuiailiuruoying/p/14458648.html</a></p></blockquote><h2 id="more" tabindex="-1"><a class="header-anchor" href="#more"><span>More</span></a></h2><p>我觉得在我们开发过程中测试是非常重要的一部分，高质量项目的一个重要指标就是测试覆盖率，，一个高质量的开源项目一定是有比较完善的测试项目的，所以对于测试非常有必要了解一下，并将它集成到自己的项目中持续保证项目的高质量，同时完善的测试对于项目重构也是非常有好处的，能够很大程度上检测是否有发生一些破坏性的变更。 总而言之，开始写单元测试吧，为成为一个优秀的工程师而努力~~</p><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference"><span>Reference</span></a></h2><ul><li><a href="https://msdn.microsoft.com/zh-cn/library/Microsoft.VisualStudio.TestTools.UnitTesting.aspx" target="_blank" rel="noopener noreferrer">MSDN - Microsoft.VisualStudio.TestTools.UnitTesting</a></li><li><a href="http://www.cnblogs.com/Wddpct/p/5891222.html" target="_blank" rel="noopener noreferrer">单元测试之道</a></li><li><a href="http://www.cnblogs.com/FreeDong/p/3352939.html" target="_blank" rel="noopener noreferrer">VS2012 Unit Test 个人学习汇总（含目录）</a></li><li><a href="http://jingyan.baidu.com/article/d713063522ab4e13fdf47533.html" target="_blank" rel="noopener noreferrer">单元测试的优点</a></li><li><a href="http://www.cnblogs.com/ColdJokeLife/p/3158812.html" target="_blank" rel="noopener noreferrer">对比MS Test与NUnit Test框架</a></li><li><a href="https://stackoverflow.com/questions/261139/nunit-vs-mbunit-vs-mstest-vs-xunit-net" target="_blank" rel="noopener noreferrer">https://stackoverflow.com/questions/261139/nunit-vs-mbunit-vs-mstest-vs-xunit-net</a></li><li><a href="https://docs.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-dotnet-test" target="_blank" rel="noopener noreferrer">https://docs.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-dotnet-test</a></li><li><a href="https://xunit.net/" target="_blank" rel="noopener noreferrer">https://xunit.net</a></li></ul><h2 id="来源" tabindex="-1"><a class="header-anchor" href="#来源"><span>来源</span></a></h2><blockquote><p>作者：WeihanLi 出处：<a href="https://www.cnblogs.com/weihanli/p/14316093.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/weihanli/p/14316093.html</a> 版权：本作品采用「<a href="https://creativecommons.org/licenses/by/4.0" target="_blank" rel="noopener noreferrer">署名-非商业性使用-相同方式共享 4.0 国际</a>」许可协议进行许可。 内容会根据自己理解稍作修改。</p></blockquote>`,50),l=[n];function r(h,p){return e(),s("div",null,l)}const d=i(a,[["render",r],["__file","index.html.vue"]]),c=JSON.parse('{"path":"/middleware/testMange/unitTest/","title":"说明","lang":"zh-CN","frontmatter":{"title":"说明","lang":"zh-CN","date":"2023-09-04T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["middleware"],"tag":["无"],"filename":"readme","slug":"bxe5yv","docsId":"53647181","description":"Intro “不会写单元测试的程序员不是合格的程序员，不写单元测试的程序员不是优秀的工程师。” —— 一只想要成为一个优秀程序员的渣逼程序猿。 那么问题来了，什么是单元测试，如何做单元测试。 单元测试 单元测试的定义 对程序员自己编写的代码中的方法或者函数进行测试，并非是端到端的集成测试，不需要依赖外部系统的逻辑正确性。 按照维基百科上的说法，单元测试...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/middleware/testMange/unitTest/"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"说明"}],["meta",{"property":"og:description","content":"Intro “不会写单元测试的程序员不是合格的程序员，不写单元测试的程序员不是优秀的工程师。” —— 一只想要成为一个优秀程序员的渣逼程序猿。 那么问题来了，什么是单元测试，如何做单元测试。 单元测试 单元测试的定义 对程序员自己编写的代码中的方法或者函数进行测试，并非是端到端的集成测试，不需要依赖外部系统的逻辑正确性。 按照维基百科上的说法，单元测试..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-01T06:24:22.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-09-04T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-01T06:24:22.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"说明\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-09-04T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-01T06:24:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"Intro","slug":"intro","link":"#intro","children":[]},{"level":2,"title":"单元测试","slug":"单元测试","link":"#单元测试","children":[{"level":3,"title":"单元测试的定义","slug":"单元测试的定义","link":"#单元测试的定义","children":[]},{"level":3,"title":"单元测试的好处","slug":"单元测试的好处","link":"#单元测试的好处","children":[]},{"level":3,"title":"单元测试的原则","slug":"单元测试的原则","link":"#单元测试的原则","children":[]},{"level":3,"title":"什么是好的单元测试","slug":"什么是好的单元测试","link":"#什么是好的单元测试","children":[]},{"level":3,"title":"对比集成测试","slug":"对比集成测试","link":"#对比集成测试","children":[]},{"level":3,"title":"如何编写单元测试","slug":"如何编写单元测试","link":"#如何编写单元测试","children":[]}]},{"level":2,"title":".NET 中的测试框架","slug":"net-中的测试框架","link":"#net-中的测试框架","children":[{"level":3,"title":"MS Test","slug":"ms-test","link":"#ms-test","children":[]},{"level":3,"title":"NUnit","slug":"nunit","link":"#nunit","children":[]},{"level":3,"title":"XUnit","slug":"xunit","link":"#xunit","children":[]}]},{"level":2,"title":"More","slug":"more","link":"#more","children":[]},{"level":2,"title":"Reference","slug":"reference","link":"#reference","children":[]},{"level":2,"title":"来源","slug":"来源","link":"#来源","children":[]}],"git":{"createdTime":1697724028000,"updatedTime":1701411862000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":2}]},"readingTime":{"minutes":9.74,"words":2923},"filePathRelative":"middleware/testMange/unitTest/readme.md","localizedDate":"2023年9月4日","excerpt":"<h2>Intro</h2>\\n<blockquote>\\n<p>“不会写单元测试的程序员不是合格的程序员，不写单元测试的程序员不是优秀的工程师。”\\n—— 一只想要成为一个优秀程序员的渣逼程序猿。</p>\\n</blockquote>\\n<p>那么问题来了，什么是单元测试，如何做单元测试。</p>\\n<h2>单元测试</h2>\\n<h3>单元测试的定义</h3>\\n<p>对程序员自己编写的代码中的方法或者函数进行测试，并非是端到端的集成测试，不需要依赖外部系统的逻辑正确性。\\n按照维基百科上的说法，单元测试（Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。 程序单元是应用的最小可测试部件。在面向对象编程中，最小单元就是方法，包括基类、抽象类、或者派生类（子类）中的方法。 按照通俗的理解，一个单元测试判断某个特定场条件下某个特定方法的行为，如斐波那契数列算法，冒泡排序算法。</p>","autoDesc":true}');export{d as comp,c as data};
