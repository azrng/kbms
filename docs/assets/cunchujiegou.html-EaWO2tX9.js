import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,o as a,d as s}from"./app-CVCmcd0Y.js";const t="/kbms/common/1642604879758-7df5ac59-3050-4c50-bba9-60d08993b262.webp",l="/kbms/common/1642604890155-7f829b53-320a-45bc-91cb-57107157c68b.webp",n={},r=s(`<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h2><p>c#中包含三类内存：托管堆、非托管堆、栈，其中运行中的 .NET 应用程序使用两个区域来存储数据：<strong>栈</strong>和<strong>托管堆</strong>，其中<strong>托管堆</strong>简称为<strong>堆</strong>。</p><h3 id="三大内存区域" tabindex="-1"><a class="header-anchor" href="#三大内存区域"><span>三大内存区域</span></a></h3><ul><li>托管堆内存：由GC管理的内存，<code>new</code>一个<code>class</code>，<code>class</code>的本体就在托管堆上，交给GC来管理</li><li>非托管内存：可以通过Marshal.AllocHGlobal 和 Marshal.FreeHGlobal 方法来分配和释放内存，这里得到的内存是非托管堆内存，GC 管不着，自己进行管理</li><li>栈内存：可以进行栈上进行一些内存操作。</li></ul><h2 id="目的" tabindex="-1"><a class="header-anchor" href="#目的"><span>目的</span></a></h2><p>数据的类型不仅决定了数据存储需要的内存大小，还决定了对象在内存中存储的位置（栈或堆）。理解值类型和引用类型的特点和它们在内存中的存储结构，就能了解它们是如何以及何时进行内存分配和回收的，这有助于帮助我们编写更高性能的应用程序。</p><h2 id="操作" tabindex="-1"><a class="header-anchor" href="#操作"><span>操作</span></a></h2><h3 id="栈与值类型" tabindex="-1"><a class="header-anchor" href="#栈与值类型"><span>栈与值类型</span></a></h3><ul><li>值类型一般存储在栈中，但是如果该值类型被包含在引用类型中(如类里面的属性)，那么它会在堆上。</li><li>栈是一个后进先出的数据结构。 <ul><li>数据只能从栈的顶端插入和删除。把数据放入栈中叫做入栈，从栈顶端删除数据叫做出栈。</li><li>栈在内存中可以理解为上图所示的一个个连续的存储单元。</li><li>栈除了存储值类型的变量，还存储传递给方法的值类型的参数，以及程序当前的执行环境等。</li><li>栈中数据的生命周期由 CLR 根据其作用域直接处理的</li></ul></li></ul><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;    </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// a 的作用域开始</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> b</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// b 的作用域开始</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }             </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// b 的作用域结束</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}               </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// a 的作用域结束</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>作用域的生命周期和栈的后进先出逻辑总是一致的。随着代码的执行，程序先进入变量 a 的作用域，再进入 b 的作用域。对应的，变量 a 的值先入栈，b 的值后入栈。b 的作用域先结束，它的值先出栈被销毁，其次是 a 的值出栈被销毁。</p><h3 id="堆与引用类型" tabindex="-1"><a class="header-anchor" href="#堆与引用类型"><span>堆与引用类型</span></a></h3><ul><li>引用类型对应的数据存储在堆中，同时也会在栈中存储一个指向堆中实际数据的引用。</li></ul><figure><img src="`+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>托管堆是一块内存区域</li><li>与栈不同的是，堆中的存储单元能能够以任意顺序存入和移除</li><li>堆中的数据是由 CLR 托管。CLR 中的 GC（垃圾回收器）判断程序将不会再访问某数据项时，会自动销毁无主的堆对象。</li></ul><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>对于引用类型的任何对象，其实例所有成员的数据都存放在堆中，无论它是值类型还是引用类型。</p></blockquote><h2 id="本质区别" tabindex="-1"><a class="header-anchor" href="#本质区别"><span>本质区别</span></a></h2><ul><li>分配内存的时机以及可变性。 <ul><li>值类型从声明开始就分配内存，声明时候它在内存中占用的存储单元就固定了，销毁前不会发生增加或者减少容量，复制只是往已经分配的存储单元中写入数据。</li><li>引用类型是在真正赋值或者初始化的时候才分配空间，而且所分配的内存大小后期可能会根据需要动态发生改变(字符串类型除外)</li></ul></li><li>存储位置的不同。 <ul><li>值类型只存储在栈中，只在栈顶进行插入和删除，遵循后进先出原则</li><li>引用类型分两块存储，实际的数据存储在堆中，数据的引用存储在栈中。</li></ul></li></ul><h2 id="数据结构介绍仓库" tabindex="-1"><a class="header-anchor" href="#数据结构介绍仓库"><span>数据结构介绍仓库</span></a></h2><p>常用的数据结构有：数组（Array）、栈（Stack）、队列（Queue）、链表（Linked List）、树（Tree）、图（Graph）、堆（Heap）、哈希表（Hash）等； 其中在 C# 中常见的数据结构有，Array, ArrayList,List, Dictionary,Queue，已经可以满足大部分的场景了。但是如果对性能要求比较高时，这时就要考虑选择一些高阶的数据结构了，比如红黑树，B树，堆等。</p><p>C-Sharp-Algorithms是使用 C## 编写的数据结构和算法类库项目，Github 上有 5.1k star, 它包含了75 多种数据结构和算法。 最初这个项目只是为学习数据结构，但是随着社区对项目不断的维护，项目现在已经是高效的和稳定的，可以放心在生产环境中使用。 项目中包含的数据结构和算法有： 跳表，链表，堆，优先队列，AVL 树，红黑树，B树，图，深度有限搜索，广度有限搜索等。 文档：<a href="https://github.com/aalhour/C-Sharp-Algorithms" target="_blank" rel="noopener noreferrer">https://github.com/aalhour/C-Sharp-Algorithms</a></p><p>advanced-algorithms 也是使用 C## 编写的开源数据结构类库项目，其中包含了 100 多种的数据结构和算法的实现。 项目中包含的数据结构和算法有： 跳表，链表，哈希表，优先队列，AVL 树，红黑树，B树，布隆过滤器，循环队列，图，加权图，有向图，排序算法，深度优先搜索，广度有限搜索，一致性哈希，LRU 缓存等。 文档：<a href="https://github.com/justcoding121/advanced-algorithms" target="_blank" rel="noopener noreferrer">https://github.com/justcoding121/advanced-algorithms</a></p><h2 id="资料" tabindex="-1"><a class="header-anchor" href="#资料"><span>资料</span></a></h2><p><a href="https://mp.weixin.qq.com/s/McsAOuvj7a7KOPSNh96V8g" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/McsAOuvj7a7KOPSNh96V8g</a> | [018] C#基础：值类型和引用类型的存储结构</p>',25),h=[r];function o(c,p){return a(),e("div",null,h)}const k=i(n,[["render",o],["__file","cunchujiegou.html.vue"]]),u=JSON.parse('{"path":"/dotnet/csharp/cunchujiegou.html","title":"存储结构","lang":"zh-CN","frontmatter":{"title":"存储结构","lang":"zh-CN","date":"2023-10-22T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["csharp"],"tag":["无"],"filename":"cunchujiegou","slug":"rnx246","docsId":"65280795","description":"概述 c#中包含三类内存：托管堆、非托管堆、栈，其中运行中的 .NET 应用程序使用两个区域来存储数据：栈和托管堆，其中托管堆简称为堆。 三大内存区域 托管堆内存：由GC管理的内存，new一个class，class的本体就在托管堆上，交给GC来管理 非托管内存：可以通过Marshal.AllocHGlobal 和 Marshal.FreeHGlobal...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dotnet/csharp/cunchujiegou.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"存储结构"}],["meta",{"property":"og:description","content":"概述 c#中包含三类内存：托管堆、非托管堆、栈，其中运行中的 .NET 应用程序使用两个区域来存储数据：栈和托管堆，其中托管堆简称为堆。 三大内存区域 托管堆内存：由GC管理的内存，new一个class，class的本体就在托管堆上，交给GC来管理 非托管内存：可以通过Marshal.AllocHGlobal 和 Marshal.FreeHGlobal..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://azrng.gitee.io/kbms/kbms/common/1642604879758-7df5ac59-3050-4c50-bba9-60d08993b262.webp"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-13T14:11:27.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-10-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-13T14:11:27.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"存储结构\\",\\"image\\":[\\"https://azrng.gitee.io/kbms/kbms/common/1642604879758-7df5ac59-3050-4c50-bba9-60d08993b262.webp\\",\\"https://azrng.gitee.io/kbms/kbms/common/1642604890155-7f829b53-320a-45bc-91cb-57107157c68b.webp\\"],\\"datePublished\\":\\"2023-10-22T00:00:00.000Z\\",\\"dateModified\\":\\"2024-03-13T14:11:27.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[{"level":3,"title":"三大内存区域","slug":"三大内存区域","link":"#三大内存区域","children":[]}]},{"level":2,"title":"目的","slug":"目的","link":"#目的","children":[]},{"level":2,"title":"操作","slug":"操作","link":"#操作","children":[{"level":3,"title":"栈与值类型","slug":"栈与值类型","link":"#栈与值类型","children":[]},{"level":3,"title":"堆与引用类型","slug":"堆与引用类型","link":"#堆与引用类型","children":[]}]},{"level":2,"title":"本质区别","slug":"本质区别","link":"#本质区别","children":[]},{"level":2,"title":"数据结构介绍仓库","slug":"数据结构介绍仓库","link":"#数据结构介绍仓库","children":[]},{"level":2,"title":"资料","slug":"资料","link":"#资料","children":[]}],"git":{"createdTime":1700232644000,"updatedTime":1710339087000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":2}]},"readingTime":{"minutes":4.63,"words":1390},"filePathRelative":"dotnet/csharp/cunchujiegou.md","localizedDate":"2023年10月22日","excerpt":"<h2>概述</h2>\\n<p>c#中包含三类内存：托管堆、非托管堆、栈，其中运行中的 .NET 应用程序使用两个区域来存储数据：<strong>栈</strong>和<strong>托管堆</strong>，其中<strong>托管堆</strong>简称为<strong>堆</strong>。</p>\\n<h3>三大内存区域</h3>\\n<ul>\\n<li>托管堆内存：由GC管理的内存，<code>new</code>一个<code>class</code>，<code>class</code>的本体就在托管堆上，交给GC来管理</li>\\n<li>非托管内存：可以通过Marshal.AllocHGlobal 和 Marshal.FreeHGlobal 方法来分配和释放内存，这里得到的内存是非托管堆内存，GC 管不着，自己进行管理</li>\\n<li>栈内存：可以进行栈上进行一些内存操作。</li>\\n</ul>","autoDesc":true}');export{k as comp,u as data};
