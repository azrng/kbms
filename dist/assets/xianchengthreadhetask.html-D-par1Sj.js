import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as b,d as e,o as s}from"./app-OPlDaE8U.js";const t="/kbms/common/1613566425572-63c08e76-8ab9-4fcb-8dc1-537a925313c3.png",p="/kbms/common/1613566425574-a98ff84d-8a08-49d5-88d6-4f1f7cbd4ef8.png",a={};function o(i,n){return s(),b("div",null,n[0]||(n[0]=[e('<p>.NET Framework中的线程分为两类：1.前台线程；2.后台线程。<br> 1.前台线程：<br> class Program<br> {<br>     static void Main(string[] args)<br>     {<br>        Console.WriteLine(&quot;=<mark><mark>Thread</mark></mark>=&quot;);<br>         TestThread();<br>        Console.WriteLine(&quot;主线程执行完毕&quot;);  <br>     }<br>     public static void TestThread()<br>     {<br>         Thread thread = new Thread(PrintNum);<br>         thread.Start();<br>     }<br>  <br>     public static void PrintNum()<br>     {<br>         Thread.Sleep(3000);<br>         for (int i = 0; i &lt; 10; i++)<br>             Console.WriteLine(i);<br>     }<br> }<br> 主线程虽然执行完毕了，但是并没有退出程序，而是等待子线程执行完毕后，退出程序。<br><img src="'+t+'" alt="image.png" loading="lazy"><br>  <br> 2.后台线程<br> class Program<br> {<br>     static void Main(string[] args)<br>     {<br>        Console.WriteLine(&quot;=<mark><mark>ThreadPool</mark></mark>=&quot;);<br>     　　ThreadPool.QueueUserWorkItem(new WaitCallback(PrintNum));<br>     　　Console.WriteLine(&quot;主线程执行完毕&quot;);    <br>     }<br>     public static void PrintNum(object obj)<br>     {<br>         Thread.Sleep(3000);<br>         for (int i = 0; i &lt; 10; i++)<br>             Console.WriteLine(i);<br>     }<br> }<br><img src="'+p+'" alt="image.png" loading="lazy"><br> 主线程运行完毕后，就直接退出了程序，没有等待子线程。<br> 总结：<br> 1.前台线程：主线程执行完毕后，会等待所有子线程执行完毕后，才退出程序。<br> 2.后台线程：主线程执行完毕后，直接退出程序，不论子线程是否执行完毕。<br> 3.推荐：多线程的操作，推荐使用线程池线程而非新建线程。因为就算只是单纯的新建一个线程，这个线程什么事情也不做，都大约需要1M的内存空间来存储执行上下文数据结构，并且线程的创建与回收也需要消耗资源，耗费时间。而线程池的优势在于线程池中的线程是根据需要创建与销毁，是最优的存在。但是这也有个问题，那就是线程池线程都是后台线程，主线程执行完毕后，不会等待后台线程而直接结束程序。<a href="http://xn--ghqpu67e36ozsd62f5r7fchxa.NET" target="_blank" rel="noopener noreferrer">所以下面就要引出.NET</a> Framework4.0提供的Task，来解决此类问题。<br>  <br>  <br> 如果一个应用程序接收到很多请求，且处理每个请求都非常耗时。在这种情况下，我们就必须指定一个点来结束请求，当有新的请求进入状态时，没有worker 线程可使用，这种现象称为线程饥饿。</p>',1)]))}const d=r(a,[["render",o]]),l=JSON.parse('{"path":"/dotnet/webyingyong/webform/xiancheng/xianchengthreadhetask.html","title":"线程thread和 Task","lang":"zh-CN","frontmatter":{"title":"线程thread和 Task","lang":"zh-CN","date":"2021-02-17T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["dotNET"],"tag":["无"],"filename":"xianchengthreadhetask","slug":"lfgvws","docsId":"31541465","description":".NET Framework中的线程分为两类：1.前台线程；2.后台线程。 1.前台线程： class Program { static void Main(string[] args) { Console.WriteLine(\\"=Thread=\\"); TestThread(); Console.WriteLine(\\"主线程执行完毕\\"); } publ...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"线程thread和 Task\\",\\"image\\":[\\"https://azrng.gitee.io/kbms/kbms/common/1613566425572-63c08e76-8ab9-4fcb-8dc1-537a925313c3.png\\",\\"https://azrng.gitee.io/kbms/kbms/common/1613566425574-a98ff84d-8a08-49d5-88d6-4f1f7cbd4ef8.png\\"],\\"datePublished\\":\\"2021-02-17T00:00:00.000Z\\",\\"dateModified\\":\\"2023-10-22T08:11:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"],["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dotnet/webyingyong/webform/xiancheng/xianchengthreadhetask.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"线程thread和 Task"}],["meta",{"property":"og:description","content":".NET Framework中的线程分为两类：1.前台线程；2.后台线程。 1.前台线程： class Program { static void Main(string[] args) { Console.WriteLine(\\"=Thread=\\"); TestThread(); Console.WriteLine(\\"主线程执行完毕\\"); } publ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://azrng.gitee.io/kbms/kbms/common/1613566425572-63c08e76-8ab9-4fcb-8dc1-537a925313c3.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-10-22T08:11:43.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2021-02-17T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-10-22T08:11:43.000Z"}]]},"git":{"createdTime":1697962303000,"updatedTime":1697962303000,"contributors":[{"name":"azrng","username":"","email":"itzhangyunpeng@163.com","commits":1}]},"readingTime":{"minutes":1.81,"words":544},"filePathRelative":"dotnet/webyingyong/webform/xiancheng/xianchengthreadhetask.md","excerpt":"<p>.NET Framework中的线程分为两类：1.前台线程；2.后台线程。<br>\\n1.前台线程：<br>\\nclass Program<br>\\n{<br>\\n&nbsp;&nbsp;&nbsp; static void Main(string[] args)<br>\\n&nbsp;&nbsp;&nbsp; {<br>\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\\"=<mark><mark>Thread</mark></mark>=\\");<br>\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TestThread();<br>\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\\"主线程执行完毕\\");&nbsp;&nbsp;<br>\\n&nbsp;&nbsp;&nbsp; }<br>\\n&nbsp;&nbsp;&nbsp; public static void TestThread()<br>\\n&nbsp;&nbsp;&nbsp; {<br>\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread thread = new Thread(PrintNum);<br>\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; thread.Start();<br>\\n&nbsp;&nbsp;&nbsp; }<br>\\n&nbsp;<br>\\n&nbsp;&nbsp;&nbsp; public static void PrintNum()<br>\\n&nbsp;&nbsp;&nbsp; {<br>\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread.Sleep(3000);<br>\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 10; i++)<br>\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(i);<br>\\n&nbsp;&nbsp;&nbsp; }<br>\\n}<br>\\n主线程虽然执行完毕了，但是并没有退出程序，而是等待子线程执行完毕后，退出程序。<br>\\n<img src=\\"/common/1613566425572-63c08e76-8ab9-4fcb-8dc1-537a925313c3.png\\" alt=\\"image.png\\" loading=\\"lazy\\"><br>\\n&nbsp;<br>\\n2.后台线程<br>\\nclass Program<br>\\n{<br>\\n&nbsp;&nbsp;&nbsp; static void Main(string[] args)<br>\\n&nbsp;&nbsp;&nbsp; {<br>\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\\"=<mark><mark>ThreadPool</mark></mark>=\\");<br>\\n&nbsp;&nbsp;&nbsp; 　　ThreadPool.QueueUserWorkItem(new WaitCallback(PrintNum));<br>\\n&nbsp;&nbsp;&nbsp; 　　Console.WriteLine(\\"主线程执行完毕\\");&nbsp;&nbsp;&nbsp;&nbsp;<br>\\n&nbsp;&nbsp;&nbsp; }<br>\\n&nbsp;&nbsp;&nbsp; public static void PrintNum(object obj)<br>\\n&nbsp;&nbsp;&nbsp; {<br>\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread.Sleep(3000);<br>\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 10; i++)<br>\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(i);<br>\\n&nbsp;&nbsp;&nbsp; }<br>\\n}<br>\\n<img src=\\"/common/1613566425574-a98ff84d-8a08-49d5-88d6-4f1f7cbd4ef8.png\\" alt=\\"image.png\\" loading=\\"lazy\\"><br>\\n主线程运行完毕后，就直接退出了程序，没有等待子线程。<br>\\n总结：<br>\\n1.前台线程：主线程执行完毕后，会等待所有子线程执行完毕后，才退出程序。<br>\\n2.后台线程：主线程执行完毕后，直接退出程序，不论子线程是否执行完毕。<br>\\n3.推荐：多线程的操作，推荐使用线程池线程而非新建线程。因为就算只是单纯的新建一个线程，这个线程什么事情也不做，都大约需要1M的内存空间来存储执行上下文数据结构，并且线程的创建与回收也需要消耗资源，耗费时间。而线程池的优势在于线程池中的线程是根据需要创建与销毁，是最优的存在。但是这也有个问题，那就是线程池线程都是后台线程，主线程执行完毕后，不会等待后台线程而直接结束程序。<a href=\\"http://xn--ghqpu67e36ozsd62f5r7fchxa.NET\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">所以下面就要引出.NET</a> Framework4.0提供的Task，来解决此类问题。<br>\\n&nbsp;<br>\\n&nbsp;<br>\\n如果一个应用程序接收到很多请求，且处理每个请求都非常耗时。在这种情况下，我们就必须指定一个点来结束请求，当有新的请求进入状态时，没有worker 线程可使用，这种现象称为线程饥饿。</p>","autoDesc":true}');export{d as comp,l as data};
