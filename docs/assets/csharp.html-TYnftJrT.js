import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,o as s,d as t}from"./app-HmxoaDfj.js";const a={},n=t(`<h2 id="简述-private、-protected、-public、-internal-修饰符的访问权限。" tabindex="-1"><a class="header-anchor" href="#简述-private、-protected、-public、-internal-修饰符的访问权限。"><span>简述 private、 protected、 public、 internal 修饰符的访问权限。</span></a></h2><p>private : 私有成员, 在类的内部才可以访问。</p><p>protected : 保护成员，该类内部和继承类中可以访问。</p><p>public : 公共成员，完全公开，没有访问限制。</p><p>internal: 当前程序集内可以访问。</p><h2 id="面向对象的三个特性" tabindex="-1"><a class="header-anchor" href="#面向对象的三个特性"><span>面向对象的三个特性？</span></a></h2><p>继承性：就是让一个类型的对象拥有另一个类型的对象的属性的方法。继承后，子类拥有父类的属性和方法。</p><p>封装性：就是将数据和代码捆绑在一起，防止外界干扰。</p><p>多态性：就是一个事物拥有不同形式的能力。</p><h2 id="元组可以容纳多少个元素" tabindex="-1"><a class="header-anchor" href="#元组可以容纳多少个元素"><span>元组可以容纳多少个元素</span></a></h2><p>答：一个元组可以容纳1到8个元素。如果元素多于8个, 则可以将第8个元素定义为另一个元组。元组可以指定为参数或方法的返回类型。</p><h2 id="override与重载的区别" tabindex="-1"><a class="header-anchor" href="#override与重载的区别"><span>override与重载的区别</span></a></h2><p>重载是方法的名称相同，参数或参数类型不同，进行多次重载以适应不同的需要。</p><p>Override是进行基类中函数的重写，为了适应需要，实现多态。</p><p>重载：是方法的名称相同，参数或参数类型不同；重载是面向过程的概念。</p><p>重写：是对基类中的虚方法进行重写。重写是面向对象的概念</p><h2 id="什么是装箱-boxing-和拆箱-unboxing" tabindex="-1"><a class="header-anchor" href="#什么是装箱-boxing-和拆箱-unboxing"><span>什么是装箱(boxing)和拆箱(unboxing)？</span></a></h2><p>装箱：从值类型接口转换到引用类型。</p><p>拆箱：从引用类型转换到值类型。</p><p>object obj = null;//引用类型</p><p>obj = 1;//装箱，boxing。把值类型包装为引用类型。</p><p>int i1 = (int)obj;//拆箱。Unboxing</p><h2 id="在-net中类-class-与结构-struct-的异同" tabindex="-1"><a class="header-anchor" href="#在-net中类-class-与结构-struct-的异同"><span>在.NET中类(class)与结构(struct)的异同？</span></a></h2><p>Class可以被实例化,属于引用类型,是分配在内存的堆上的。类是引用传递的。</p><p>Struct属于值类型,是分配在内存的栈上的。结构体是复制传递的。</p><h2 id="c-中的接口和类有什么异同" tabindex="-1"><a class="header-anchor" href="#c-中的接口和类有什么异同"><span>C#中的接口和类有什么异同？</span></a></h2><p>不同点：</p><p>不能直接实例化接口。</p><p>接口不包含方法的实现。</p><p>接口可以多继承，类只能单继承。</p><p>类定义可在不同的源文件之间进行拆分。</p><p>相同点：</p><p>接口、类和结构都可以从多个接口继承。</p><p>接口类似于抽象基类：继承接口的任何非抽象类型都必须实现接口的所有成员。</p><p>接口和类都可以包含事件、索引器、方法和属性。</p><p>基础知识：接口只能定义方法（只能定义行为，不能定义实现也就是字段），因为事件、索引器、属性本质上都是方法，所以接口中也可以定义事件、索引器、属性。</p><h2 id="abstract-class-抽象类-和interface-接口-有什么区别" tabindex="-1"><a class="header-anchor" href="#abstract-class-抽象类-和interface-接口-有什么区别"><span>abstract class(抽象类)和interface(接口)有什么区别？</span></a></h2><p>相同点：</p><p>都不能被直接实例化，都可以通过继承实现其抽象方法。</p><p>不同点：</p><p>接口支持多继承；抽象类不能实现多继承。</p><p>接口只能定义行为；抽象类既可以定义行为，还可能提供实现。</p><p>接口只包含方法(Method)、属性(Property)、索引器(Index)、事件(Event)的签名，但不能定义字段和包含实现的方法；</p><p>抽象类可以定义字段、属性、包含有实现的方法。</p><p>接口可以作用于值类型(Struct)和引用类型(Class)；抽象类只能作用于引用类型。例如，Struct就可以继承接口，而不能继承类。</p><h2 id="在什么情况下会用到虚方法-它与接口有什么不同" tabindex="-1"><a class="header-anchor" href="#在什么情况下会用到虚方法-它与接口有什么不同"><span>在什么情况下会用到虚方法？它与接口有什么不同？</span></a></h2><p>子类重新定义父类的某一个方法时，必须把父类的方法定义为virtual</p><p>在定义接口中不能有方法体，虚方法可以。</p><p>实现时，子类可以不重新定义虚方法，但如果一个类继承接口，那必须实现这个接口。</p><h2 id="说出一些常用的类、接口-请各举5个" tabindex="-1"><a class="header-anchor" href="#说出一些常用的类、接口-请各举5个"><span>说出一些常用的类、接口，请各举5个？</span></a></h2><p>要让人家感觉你对.Net开发很熟，所以，不能仅仅只列谁都能想到的那些东西，要多列你在做项目中涉及的那些东西。就写你最近写的那些程序中涉及的那些类。</p><p>常用的类：StreamReader、HttpClient、Dictionary&lt;K,V&gt;、StringBuilder、SqlConnection、FileStream、File、Regex、List&lt;T&gt;</p><p>常用的接口：IDisposable、IEnumerable、IDbConnection、IComparable、ICollection、IList、IDictionary</p><h2 id="linq-常用的方法以及-iqueryable-是什么" tabindex="-1"><a class="header-anchor" href="#linq-常用的方法以及-iqueryable-是什么"><span><strong>LINQ 常用的方法以及 IQueryable 是什么？</strong></span></a></h2><p>常用的 LINQ 方法包括：Where、Select、OrderBy、GroupBy、Join 等。IQueryable接口代表一个可查询的数据源，它允许构建查询，将查询延迟到实际执行。在数据库查询中，使用 IQueryable 可以在数据库中生成更有效的查询语句。</p><h2 id="编写一个单例-singleton-类" tabindex="-1"><a class="header-anchor" href="#编写一个单例-singleton-类"><span>编写一个单例（Singleton）类</span></a></h2><p>把构造函数设置为private，设置一个public、static的对象实例</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">public FileManager</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  private</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> FileManager(){}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  public </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">readonly</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> FileManager Instance </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> new FileManager();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="在-c-中如何声明一个类不能被继承" tabindex="-1"><a class="header-anchor" href="#在-c-中如何声明一个类不能被继承"><span>在 C# 中如何声明一个类不能被继承</span></a></h2><p>密封类不能被继承，密封方法可以重写基类中的方法，但其本身不能在任何派生类（子类）中进一步重写。当应用于属性或者方法时，sealed 修饰符必须始终和override一同使用。例如：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>sealed class MySealedClass { }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="是否可以继承string类" tabindex="-1"><a class="header-anchor" href="#是否可以继承string类"><span>是否可以继承String类？</span></a></h2><p>String类是sealed类(密封类)故不可以继承。</p><h2 id="stringbuilder-和-string-的区别" tabindex="-1"><a class="header-anchor" href="#stringbuilder-和-string-的区别"><span>StringBuilder 和 String 的区别？</span></a></h2><p>String 在进行运算时（如赋值、拼接等）会产生一个新的实例，而 StringBuilder 则不会。所以在大量字符串拼接或频繁对某一字符串进行操作时最好使用 StringBuilder，不要使用 String。</p><p>如果要操作一个不断增长的字符串，尽量不用String类，改用StringBuilder类。两个类的工作原理不同：String类是一种传统的修改字符串的方式，它确实可以完成把一个字符串添加到另一个字符串上的工作没错,但是在.NET框架下，这个操作实在是划不来。因为系统先是把两个字符串写入内存，接着删除原来的String对象，然后创建一个String对象，并读取内存中的数据赋给该对象。这一来二去的，耗了不少时间。而使用System.Text命名空间下面的StringBuilder类就不是这样了，它提供的Append方法，能够在已有对象的原地进行字符串的修改，简单而且直接。当然，一般情况下觉察不到这二者效率的差异，但如果你要对某个字符串进行大量的添加操作，那么StringBuilder类所耗费的时间和String类简直不是一个数量级的。</p><h2 id="c-中的委托是什么-事件是不是一种委托" tabindex="-1"><a class="header-anchor" href="#c-中的委托是什么-事件是不是一种委托"><span>C#中的委托是什么？事件是不是一种委托？</span></a></h2><p>委托是一种引用类型，表示对具有特定参数列表和返回类型的方法的引用。</p><p>委托用于将方法作为参数传递给其他方法。事件就是通过委托调用的方法。</p><p>委托可以把一个方法作为参数代入另一个方法。</p><p>委托可以理解为指向一个函数的指针。</p><p>委托和事件没有可比性，因为委托是类型，事件是对象，下面说的是委托的对象（用委托方式实现的事件）和（标准的event方式实现）事件的区别。事件的内部是用委托实现的。因为对于事件来讲，外部只能“注册自己+=、注销自己-=”，外界不可以注销其他的注册者，外界不可以主动触发事件，因此如果用Delegate就没法进行上面的控制，因此诞生了事件这种语法。事件是用来阉割委托实例的，类比用一个自定义类阉割List。事件只能add、remove自己，不能赋值。事件只能+=、-=，不能= 。加分的补充回答：事件内部就是一个private的委托和add、remove两个方法。</p><p>C#中委托这篇文章，对委托有更多的介绍。Fun和Action是微软封装的委托，一个有返回值，一个没有</p><h2 id="值类型和引用类型的区别" tabindex="-1"><a class="header-anchor" href="#值类型和引用类型的区别"><span>值类型和引用类型的区别</span></a></h2><p>值类型存储其实际数据值，引用类型存储指向实际数据的引用。</p><p>值类型直接存储在栈上，引用类型的对象存储在堆上，而引用则存储在栈上或堆上的某个位置。</p><p>值类型的赋值是将实际值复制到新变量，而引用类型的赋值是复制引用，指向相同的对象。</p><p>值类型的传递是按值传递，引用类型的传递是按引用传递。</p><p>值类型的每一次赋值都会执行一次逐字段的复制，引用类型的赋值只是指针的传递，其实也是生成新的指针实例。</p><h2 id="int-是引用类型还是值类型" tabindex="-1"><a class="header-anchor" href="#int-是引用类型还是值类型"><span>int[]是引用类型还是值类型</span></a></h2><p>int[] 是引用类型，因为它是数组类型，存储在堆上，而数组变量本身存储在栈上，指向堆中的数据。</p><h2 id="c-中-string-和-string-有什么区别" tabindex="-1"><a class="header-anchor" href="#c-中-string-和-string-有什么区别"><span>C# 中 string 和 String 有什么区别</span></a></h2><p>C# 中的 string 是 .NET 中的内置关键字，表示字符串类型。</p><p>String 是 System.String 类的别名，即 string 是 String 的别名，没有实质性区别。String 是来自 .NET Framework 的旧名称。它在 C# 1.0 中引入，在 C# 2.0 中被 string 替换。</p><h2 id="解释泛型的基本原理" tabindex="-1"><a class="header-anchor" href="#解释泛型的基本原理"><span>解释泛型的基本原理</span></a></h2><p>泛型允许编写能够与不同数据类型一起工作的代码，而不必针对每个类型编写不同的代码。</p><p>在使用泛型时，可以定义一种模板（类、接口、方法等），其中的某些类型可以由实际使用时指定。</p><h2 id="如何使用-iformattable-接口实现格式化输出" tabindex="-1"><a class="header-anchor" href="#如何使用-iformattable-接口实现格式化输出"><span>如何使用 IFormattable 接口实现格式化输出</span></a></h2><p>答：IFormattable接口帮助类型实现了多样式的格式化输出。IFormattable 的ToString方法接受一个代表格式的字符串参数，通过对这个参数的分析来进行格式化输出。另外，IFormattable.ToString方法接受一个IFormatProvider类型的参数，以允许类型的使用者提供格式化的方法。</p><h2 id="请解释委托的基本原理" tabindex="-1"><a class="header-anchor" href="#请解释委托的基本原理"><span>请解释委托的基本原理</span></a></h2><p>答：委托是一类继承自System.Delegate 的类型，每个委托对象至少包含了一个指向某个方法的指针，该方法可以是实例方法，也可以是静态方法。委托实现了回调方法的机制，能够帮助程序员设计更加简洁优美的面向对象程序。</p><p>委托（Delegate） 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。它本质上也是一个类。它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法。</p><p>委托是一种引用类型，用于封装对方法的调用，允许以类似于函数指针的方式传递方法作为参数。 委托包含一个方法的引用和一个可选的目标对象，调用委托时实际调用的是委托所引用的方法。</p><h2 id="不是说字符串是不可变的吗-string-s-abc-s-123-不就是变了吗" tabindex="-1"><a class="header-anchor" href="#不是说字符串是不可变的吗-string-s-abc-s-123-不就是变了吗"><span>不是说字符串是不可变的吗？string s=&quot;abc&quot;;s=&quot;123&quot;不就是变了吗？</span></a></h2><p>String是不可变的在这段代码中，s原先指向一个String对象，内容是 &quot;abc&quot;，然后我们将s指向&quot;123&quot;，那么s所指向的那个对象是否发生了改变呢？答案是没有。这时，s不指向原来那个对象了，而指向了另一个 String对象，内容为&quot;123&quot;，原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。</p><h2 id="什么是链式委托" tabindex="-1"><a class="header-anchor" href="#什么是链式委托"><span>什么是链式委托</span></a></h2><p>答：链式委托是指一个由委托串成的链表，当链表上的一个委托被回调时，所有链表上该委托的后续委托将会被顺序执行。</p><h2 id="请解释反射的基本原理和其实现的基石" tabindex="-1"><a class="header-anchor" href="#请解释反射的基本原理和其实现的基石"><span>请解释反射的基本原理和其实现的基石</span></a></h2><p>反射是 .NET 平台的一个重要特性，允许在运行时获取和操作程序集、类型、成员等信息。</p><p>反射的基本原理是通过元数据来描述类型的结构，运行时可以访问这些元数据，从而获取有关类型信息的详细内容。</p><p>反射的基石是元数据（metadata），它是程序集的一部分，包含有关类型、成员、方法等的描述信息。这使得程序可以在运行时了解其自身的结构和组成。</p><h2 id="如何利用反射来实现工厂模式" tabindex="-1"><a class="header-anchor" href="#如何利用反射来实现工厂模式"><span>如何利用反射来实现工厂模式</span></a></h2><p>答：使用反射可以实现灵活性较高的工厂模式，其关键在于动态地查找产品所包含的所有零件，而不需要通过代码来逐一分析使用者的需求。反射工厂模式具有灵活性高，运行效率相对较低的特点。</p><h2 id="如何以较小的内存代价保存-type、field-和-method-信息" tabindex="-1"><a class="header-anchor" href="#如何以较小的内存代价保存-type、field-和-method-信息"><span>如何以较小的内存代价保存 Type、Field 和 Method 信息</span></a></h2><p>答：System.RuntimeTypeHandle、System.RuntimeMethodHandle 和 System.RuntimeFieldHandle 三个类型，分别包含了一个指向类型、方法和字段描述的指针，用保存指针的方式来代替保存整个类型、方法和字段的信息描述对象，可以有效地减少内存的消耗。而在实际需要用到这些信息时，又可以通过这三个句柄类型对象，分别得到System.Type、System.Reflection.MethodInfo 和System.Reflection.FieldInfo 类型对象。</p><h2 id="哈希表和数组列表有什么区别" tabindex="-1"><a class="header-anchor" href="#哈希表和数组列表有什么区别"><span>哈希表和数组列表有什么区别？</span></a></h2><p>答：哈希表以值对和名称的形式存储数据, 而数组列表仅存储值。</p><p>你需要将名称传递给哈希表中的值, 而在数组中, 则需要传递索引号来访问值。</p><p>在数组中, 你只能存储类似类型的数据类型, 而在哈希表中, 你可以存储不同类型的数据类型。例如整数, 字符串等</p><h2 id="进程和线程的区别" tabindex="-1"><a class="header-anchor" href="#进程和线程的区别"><span>进程和线程的区别？</span></a></h2><p>进程是系统进行资源分配和调度的单位；线程是CPU调度和分派的单位，一个进程可以有多个线程，这些线程共享这个进程的资源。</p><h2 id="是否可以从一个static方法内部发出对非static方法的调用" tabindex="-1"><a class="header-anchor" href="#是否可以从一个static方法内部发出对非static方法的调用"><span>是否可以从一个static方法内部发出对非static方法的调用？</span></a></h2><p>不可以。因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个static方法内部不能发出对非static方法的调用。</p><h2 id="using关键字有什么用-什么是idisposable" tabindex="-1"><a class="header-anchor" href="#using关键字有什么用-什么是idisposable"><span>using关键字有什么用？什么是IDisposable？</span></a></h2><p>using可以声明namespace的引入，还可以实现非托管资源的释放，实现了IDisposiable的类在using中创建，using结束后会自动调用该对象的Dispose方法，释放资源。加分的补充回答：using其实等价于try……finally，用起来更方便。</p><h2 id="string-str-null-与-string-str-说明其中的区别" tabindex="-1"><a class="header-anchor" href="#string-str-null-与-string-str-说明其中的区别"><span>string str = null 与 string str = “”说明其中的区别？</span></a></h2><p>string str = null 是不给他分配内存空间,而string str = “” 给它分配长度为空字符串的内存空间。 string str = null没有string对象，string str = “”有一个字符串对象。</p><h2 id="gc是什么-为什么要有gc" tabindex="-1"><a class="header-anchor" href="#gc是什么-为什么要有gc"><span>GC是什么? 为什么要有GC?</span></a></h2><p>C/C++中由程序员进行对象的回收像学校食堂中由学生收盘子，.Net中由GC进行垃圾回收像餐馆中店员去回收。</p><p>GC是垃圾收集器（Garbage Collection）。程序员不用担心内存管理，因为垃圾收集器会自动进行管理。GC只能处理托管内存资源的释放，对于非托管资源则不能使用GC进行回收，必须由程序员手工回收，一个例子就是FileStream或者SqlConnection需要程序员调用Dispose进行资源的回收。</p><p>要请求垃圾收集，可以调用下面的方法：GC.Collect()一般不需要手动调用GC.Collect()。当一个对象没有任何变量指向（不再能使用）的时候就可以被回收了。</p><p>基础知识：当没有任何变量指向一个对象的时候对象就可以被回收掉了，但不一定会立即被回收。</p><h2 id="堆和栈的区别" tabindex="-1"><a class="header-anchor" href="#堆和栈的区别"><span>堆和栈的区别？</span></a></h2><p>栈是编译期间就分配好的内存空间，因此你的代码中必须就栈的大小有明确的定义；局部值类型变量、值类型参数等都在栈内存中。</p><p>堆是程序运行期间动态分配的内存空间，你可以根据程序的运行情况确定要分配的堆内存的大小。</p><h2 id="cts、cls、clr分别作何解释" tabindex="-1"><a class="header-anchor" href="#cts、cls、clr分别作何解释"><span>CTS、CLS、CLR分别作何解释？</span></a></h2><p>CTS：Common Type System 通用类型系统。Int32、Int16→int、String→string、Boolean→bool。每种语言都定义了自己的类型，.Net通过CTS提供了公共的类型，然后翻译生成对应的.Net类型。</p><p>CLS：Common Language Specification 通用语言规范。不同语言语法的不同。每种语言都有自己的语法，.Net通过CLS提供了公共的语法，然后不同语言翻译生成对应的.Net语法。</p><p>CLR：Common Language Runtime 公共语言运行时，就是GC、JIT等这些。有不同的CLR，比如服务器CLR、Linux CLR（Mono）、Silverlight CLR(CoreCLR)。相当于一个发动机，负责执行IL。</p><h2 id="jit-是如何工作的" tabindex="-1"><a class="header-anchor" href="#jit-是如何工作的"><span>JIT 是如何工作的</span></a></h2><p>JIT：即时编译（Just In-Time compile），这是.NET运行可执行程序的基本方式，也就是在需要运行的时候，才将对应的IL代码编译为本机指令。传入JIT的是IL代码，输出的是本机代码，所以部分加密软件通过挂钩JIT来进行IL加密，同时又保证程序正常运行。同解释执行的代码相比，JIT的执行效率要高很多。</p><p>当 .NET 程序启动时，IL 代码首先由 CLR 解释执行。但为了提高执行效率，CLR 会将 IL 代码逐段编译成本机代码，然后缓存起来，供后续使用。</p><p>JIT 编译是延迟编译的一种形式，只有在实际需要执行某段 IL 代码时才会进行编译。</p><h2 id="三层架构" tabindex="-1"><a class="header-anchor" href="#三层架构"><span>三层架构</span></a></h2><p>通常意义上的三层架构就是将整个业务应用划分为：表现层（UI）、业务逻辑层（BLL）、数据访问层（DAL）。</p><p>区分层次的目的即为了“高内聚，低耦合”的思想。</p><p>表现层（UI）：通俗讲就是展现给用户的界面，即用户在使用一个系统的时候的所见所得。</p><p>业务逻辑层（BLL）：针对具体问题的操作，也可以说是对数据层的操作，对数据业务逻辑处理。</p><p>数据访问层（DAL）：该层所做事务直接操作数据库，针对数据的增添、删除、修改、更新、查找等每层之间是一种垂直的关系。</p><p>三层结构是N层结构的一种，一般来说，层次之间是向下依赖的，下层代码未确定其接口（契约）前，上层代码是无法开发的，下层代码接口（契约）的变化将使上层的代码一起变化。</p><p>优点： 分工明确，条理清晰，易于调试，而且具有可扩展性。</p><p>缺点： 增加成本。</p><h2 id="属性和public字段的区别是什么-调用set方法为一个属性设值-然后用get方法读取出来的值一定是set进去的值吗" tabindex="-1"><a class="header-anchor" href="#属性和public字段的区别是什么-调用set方法为一个属性设值-然后用get方法读取出来的值一定是set进去的值吗"><span>属性和public字段的区别是什么？调用set方法为一个属性设值，然后用get方法读取出来的值一定是set进去的值吗？</span></a></h2><p>属性可以对设值、取值的过程进行非法值控制，比如年龄禁止设值负数，而字段则不能进行这样的设置。虽然一般情况下get读取的值就是set设置的值，但是可以让get读取的值不是set设置的值的，极端的例子：Public Age{get{return 100;}set{}}。</p><h2 id="在-system-object-中定义的三个比较方法有何异同" tabindex="-1"><a class="header-anchor" href="#在-system-object-中定义的三个比较方法有何异同"><span>在 System.Object 中定义的三个比较方法有何异同</span></a></h2><p>他们是Equals(object)，Equals(object, object)</p><p>ReferenceEquals(object, object)</p><p>这三个方法都用于比较两个对象是否相等。但是，它们的比较方式不同。</p><p>Equals(object) 方法是虚拟方法，可以被子类重写。它比较两个对象的值是否相等。</p><p>Equals(object, object) 方法是静态方法，不能被子类重写。它比较两个对象的引用是否相等。</p><p>ReferenceEquals(object, object) 方法是静态方法，不能被子类重写。它比较两个对象的引用是否指向同一对象。</p><h2 id="什么是链式委托-1" tabindex="-1"><a class="header-anchor" href="#什么是链式委托-1"><span>什么是链式委托</span></a></h2><p>链式委托是指将多个委托链接在一起。当链式委托被调用时，将依次调用链上的每个委托。链式委托可以用于实现事件处理程序链、异步操作链和其他复杂的任务。</p><p>在 C# 中，可以使用 <code>+</code> 运算符来链接委托。例如，以下代码将两个委托链接在一起：</p><div class="language-c# line-numbers-mode" data-highlighter="shiki" data-ext="c#" data-title="c#" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Action</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;">myAction1</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">WriteLine</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Action</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;">myAction2</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">WriteLine</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">x</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> x</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Action</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;">myChainedAction</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> myAction1</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> myAction2</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">myChainedAction</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出：10 100</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,155),l=[n];function p(r,h){return s(),e("div",null,l)}const g=i(a,[["render",p],["__file","csharp.html.vue"]]),o=JSON.parse('{"path":"/interview/csharp.html","title":"CSharp面试题","lang":"zh-CN","frontmatter":{"title":"CSharp面试题","date":"2023-09-02T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":false,"order":201,"category":["面试"],"tag":["面试题"],"article":false,"description":"简述 private、 protected、 public、 internal 修饰符的访问权限。 private : 私有成员, 在类的内部才可以访问。 protected : 保护成员，该类内部和继承类中可以访问。 public : 公共成员，完全公开，没有访问限制。 internal: 当前程序集内可以访问。 面向对象的三个特性？ 继承性：就是让...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/interview/csharp.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"CSharp面试题"}],["meta",{"property":"og:description","content":"简述 private、 protected、 public、 internal 修饰符的访问权限。 private : 私有成员, 在类的内部才可以访问。 protected : 保护成员，该类内部和继承类中可以访问。 public : 公共成员，完全公开，没有访问限制。 internal: 当前程序集内可以访问。 面向对象的三个特性？ 继承性：就是让..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-09-09T15:10:09.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"面试题"}],["meta",{"property":"article:published_time","content":"2023-09-02T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-09-09T15:10:09.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"CSharp面试题\\",\\"description\\":\\"简述 private、 protected、 public、 internal 修饰符的访问权限。 private : 私有成员, 在类的内部才可以访问。 protected : 保护成员，该类内部和继承类中可以访问。 public : 公共成员，完全公开，没有访问限制。 internal: 当前程序集内可以访问。 面向对象的三个特性？ 继承性：就是让...\\"}"]]},"headers":[{"level":2,"title":"简述 private、 protected、 public、 internal 修饰符的访问权限。","slug":"简述-private、-protected、-public、-internal-修饰符的访问权限。","link":"#简述-private、-protected、-public、-internal-修饰符的访问权限。","children":[]},{"level":2,"title":"面向对象的三个特性？","slug":"面向对象的三个特性","link":"#面向对象的三个特性","children":[]},{"level":2,"title":"元组可以容纳多少个元素","slug":"元组可以容纳多少个元素","link":"#元组可以容纳多少个元素","children":[]},{"level":2,"title":"override与重载的区别","slug":"override与重载的区别","link":"#override与重载的区别","children":[]},{"level":2,"title":"什么是装箱(boxing)和拆箱(unboxing)？","slug":"什么是装箱-boxing-和拆箱-unboxing","link":"#什么是装箱-boxing-和拆箱-unboxing","children":[]},{"level":2,"title":"在.NET中类(class)与结构(struct)的异同？","slug":"在-net中类-class-与结构-struct-的异同","link":"#在-net中类-class-与结构-struct-的异同","children":[]},{"level":2,"title":"C#中的接口和类有什么异同？","slug":"c-中的接口和类有什么异同","link":"#c-中的接口和类有什么异同","children":[]},{"level":2,"title":"abstract class(抽象类)和interface(接口)有什么区别？","slug":"abstract-class-抽象类-和interface-接口-有什么区别","link":"#abstract-class-抽象类-和interface-接口-有什么区别","children":[]},{"level":2,"title":"在什么情况下会用到虚方法？它与接口有什么不同？","slug":"在什么情况下会用到虚方法-它与接口有什么不同","link":"#在什么情况下会用到虚方法-它与接口有什么不同","children":[]},{"level":2,"title":"说出一些常用的类、接口，请各举5个？","slug":"说出一些常用的类、接口-请各举5个","link":"#说出一些常用的类、接口-请各举5个","children":[]},{"level":2,"title":"LINQ 常用的方法以及 IQueryable 是什么？","slug":"linq-常用的方法以及-iqueryable-是什么","link":"#linq-常用的方法以及-iqueryable-是什么","children":[]},{"level":2,"title":"编写一个单例（Singleton）类","slug":"编写一个单例-singleton-类","link":"#编写一个单例-singleton-类","children":[]},{"level":2,"title":"在 C# 中如何声明一个类不能被继承","slug":"在-c-中如何声明一个类不能被继承","link":"#在-c-中如何声明一个类不能被继承","children":[]},{"level":2,"title":"是否可以继承String类？","slug":"是否可以继承string类","link":"#是否可以继承string类","children":[]},{"level":2,"title":"StringBuilder 和 String 的区别？","slug":"stringbuilder-和-string-的区别","link":"#stringbuilder-和-string-的区别","children":[]},{"level":2,"title":"C#中的委托是什么？事件是不是一种委托？","slug":"c-中的委托是什么-事件是不是一种委托","link":"#c-中的委托是什么-事件是不是一种委托","children":[]},{"level":2,"title":"值类型和引用类型的区别","slug":"值类型和引用类型的区别","link":"#值类型和引用类型的区别","children":[]},{"level":2,"title":"int[]是引用类型还是值类型","slug":"int-是引用类型还是值类型","link":"#int-是引用类型还是值类型","children":[]},{"level":2,"title":"C# 中 string 和 String 有什么区别","slug":"c-中-string-和-string-有什么区别","link":"#c-中-string-和-string-有什么区别","children":[]},{"level":2,"title":"解释泛型的基本原理","slug":"解释泛型的基本原理","link":"#解释泛型的基本原理","children":[]},{"level":2,"title":"如何使用 IFormattable 接口实现格式化输出","slug":"如何使用-iformattable-接口实现格式化输出","link":"#如何使用-iformattable-接口实现格式化输出","children":[]},{"level":2,"title":"请解释委托的基本原理","slug":"请解释委托的基本原理","link":"#请解释委托的基本原理","children":[]},{"level":2,"title":"不是说字符串是不可变的吗？string s=\\"abc\\";s=\\"123\\"不就是变了吗？","slug":"不是说字符串是不可变的吗-string-s-abc-s-123-不就是变了吗","link":"#不是说字符串是不可变的吗-string-s-abc-s-123-不就是变了吗","children":[]},{"level":2,"title":"什么是链式委托","slug":"什么是链式委托","link":"#什么是链式委托","children":[]},{"level":2,"title":"请解释反射的基本原理和其实现的基石","slug":"请解释反射的基本原理和其实现的基石","link":"#请解释反射的基本原理和其实现的基石","children":[]},{"level":2,"title":"如何利用反射来实现工厂模式","slug":"如何利用反射来实现工厂模式","link":"#如何利用反射来实现工厂模式","children":[]},{"level":2,"title":"如何以较小的内存代价保存 Type、Field 和 Method 信息","slug":"如何以较小的内存代价保存-type、field-和-method-信息","link":"#如何以较小的内存代价保存-type、field-和-method-信息","children":[]},{"level":2,"title":"哈希表和数组列表有什么区别？","slug":"哈希表和数组列表有什么区别","link":"#哈希表和数组列表有什么区别","children":[]},{"level":2,"title":"进程和线程的区别？","slug":"进程和线程的区别","link":"#进程和线程的区别","children":[]},{"level":2,"title":"是否可以从一个static方法内部发出对非static方法的调用？","slug":"是否可以从一个static方法内部发出对非static方法的调用","link":"#是否可以从一个static方法内部发出对非static方法的调用","children":[]},{"level":2,"title":"using关键字有什么用？什么是IDisposable？","slug":"using关键字有什么用-什么是idisposable","link":"#using关键字有什么用-什么是idisposable","children":[]},{"level":2,"title":"string str = null 与 string str = “”说明其中的区别？","slug":"string-str-null-与-string-str-说明其中的区别","link":"#string-str-null-与-string-str-说明其中的区别","children":[]},{"level":2,"title":"GC是什么? 为什么要有GC?","slug":"gc是什么-为什么要有gc","link":"#gc是什么-为什么要有gc","children":[]},{"level":2,"title":"堆和栈的区别？","slug":"堆和栈的区别","link":"#堆和栈的区别","children":[]},{"level":2,"title":"CTS、CLS、CLR分别作何解释？","slug":"cts、cls、clr分别作何解释","link":"#cts、cls、clr分别作何解释","children":[]},{"level":2,"title":"JIT 是如何工作的","slug":"jit-是如何工作的","link":"#jit-是如何工作的","children":[]},{"level":2,"title":"三层架构","slug":"三层架构","link":"#三层架构","children":[]},{"level":2,"title":"属性和public字段的区别是什么？调用set方法为一个属性设值，然后用get方法读取出来的值一定是set进去的值吗？","slug":"属性和public字段的区别是什么-调用set方法为一个属性设值-然后用get方法读取出来的值一定是set进去的值吗","link":"#属性和public字段的区别是什么-调用set方法为一个属性设值-然后用get方法读取出来的值一定是set进去的值吗","children":[]},{"level":2,"title":"在 System.Object 中定义的三个比较方法有何异同","slug":"在-system-object-中定义的三个比较方法有何异同","link":"#在-system-object-中定义的三个比较方法有何异同","children":[]},{"level":2,"title":"什么是链式委托","slug":"什么是链式委托-1","link":"#什么是链式委托-1","children":[]}],"git":{"createdTime":1693671207000,"updatedTime":1694272209000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":2}]},"readingTime":{"minutes":17.68,"words":5305},"filePathRelative":"interview/csharp.md","localizedDate":"2023年9月2日","excerpt":"<h2>简述 private、 protected、 public、 internal 修饰符的访问权限。</h2>\\n<p>private : 私有成员, 在类的内部才可以访问。</p>\\n<p>protected : 保护成员，该类内部和继承类中可以访问。</p>\\n<p>public : 公共成员，完全公开，没有访问限制。</p>\\n<p>internal: 当前程序集内可以访问。</p>\\n<h2>面向对象的三个特性？</h2>\\n<p>继承性：就是让一个类型的对象拥有另一个类型的对象的属性的方法。继承后，子类拥有父类的属性和方法。</p>\\n<p>封装性：就是将数据和代码捆绑在一起，防止外界干扰。</p>","autoDesc":true}');export{g as comp,o as data};
