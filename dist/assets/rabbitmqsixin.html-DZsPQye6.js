import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as r,o as n}from"./app-DhDWGI3C.js";const i="/kbms/common/1609400134093-42c4d987-18cf-4d59-82e0-732efed0c75b.png",o="/kbms/common/1609400134139-7ef0cc81-84a6-4978-bed8-42e25eab7955.png",s={};function p(c,e){return n(),a("div",null,e[0]||(e[0]=[r('<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h2><p>没有消费的消息叫做死信队列<br> 生产者 --&gt; 消息 --&gt; 交换机 --&gt; 队列 --&gt; 变成死信 --&gt; DLX交换机 --&gt;队列 --&gt; 消费者</p><h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h2><h3 id="dlx" tabindex="-1"><a class="header-anchor" href="#dlx"><span>DLX</span></a></h3><p>Dead Letter Exchange 的缩写<br> DLX（Dead Letter Exchanges）死信交换，死信队列本身也是一个普通的消息队列，在创建队列的时候，通过设置一些关键参数，可以将一个普通的消息队列设置为死信队列，与其它消息队列不同的是，其入栈的消息根据入栈时指定的过期时间/被拒绝/超出队列长度被移除，依次被转发到指定的消息队列中进行二次处理。这样说法比较拗口，其原理就是死信队列内位于顶部的消息过期时，该消息将被马上发送到另外一个订阅者（消息队列）中。</p><h3 id="什么是死信" tabindex="-1"><a class="header-anchor" href="#什么是死信"><span>什么是死信</span></a></h3><p>当一条消息满足下列条件之一那么它会成为死信：</p><ul><li>消息被否定确认（如 channel.basicNack）并且此时 requeue 属性被设置为 false。</li><li>消息在队列的存活时间超过设置的 TTL 时间</li><li>消息队列的消息数量已经超过最大队列长度</li></ul><p>若配置了死信队列，死信会被 RabbitMQ 投到死信队列中。</p><h3 id="什么是死信交换机" tabindex="-1"><a class="header-anchor" href="#什么是死信交换机"><span>什么是死信交换机</span></a></h3><p>在定义业务队列的时候，要考虑指定一个死信交换机，死信交换机可以和任何一个普通的队列进行绑定，然后在业务队列出现死信的时候就会将数据发送到死信队列。</p><h3 id="什么是死信队列" tabindex="-1"><a class="header-anchor" href="#什么是死信队列"><span>什么是死信队列</span></a></h3><p>死信队列实际上就是一个普通的队列，只是这个队列跟死信交换机进行了绑定，用来存放死信而已</p><p><strong>如何使用死信交换机</strong><br> 定义业务（普通）队列的时候指定参数<br> x-dead-letter-exchange: 用来设置死信后发送的交换机<br> x-dead-letter-routing-key：用来设置死信的routingKey<br> 死信交换机图解<br><img src="'+i+'" alt="image.png" loading="lazy"></p><figure><img src="'+o+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p><strong>生产者:</strong><br> (1)生产者连接到RabbitMQ Broker，建立一个连接( Connection)开启一个信道(Channel)<br> (2)生产者声明一个交换器，并设置相关属性，比如交换机类型、是否持久化等<br> (3)生产者声明一个队列井设置相关属性，比如是否排他、是否持久化、是否自动删除等<br> (4)生产者通过路由键将交换器和队列绑定起来<br> (5)生产者发送消息至RabbitMQ Broker，其中包含路由键、交换器等信息。<br> (6)相应的交换器根据接收到的路由键查找相匹配的队列。<br> (7)如果找到，则将从生产者发送过来的消息存入相应的队列中。<br> (8)如果没有找到，则根据生产者配置的属性选择丢弃还是回退给生产者<br> (9)关闭信道。<br> (10)关闭连接。</p><p><strong>消费者:</strong><br> (1)消费者连接到RabbitMQ Broker ，建立一个连接(Connection)，开启一个信道(Channel) 。<br> (2)消费者向RabbitMQ Broker 请求消费相应队列中的消息，可能会设置相应的回调函数，<br> (3)等待RabbitMQ Broker 回应并投递相应队列中的消息，消费者接收消息。<br> (4)消费者确认(ack) 接收到的消息。<br> (5)RabbitMQ 从队列中删除相应己经被确认的消息。<br> (6)关闭信道。<br> (7)关闭连接。</p><h2 id="操作" tabindex="-1"><a class="header-anchor" href="#操作"><span>操作</span></a></h2><h3 id="创建死信队列" tabindex="-1"><a class="header-anchor" href="#创建死信队列"><span>创建死信队列</span></a></h3><p>在 RabbitMQ 中创建死信队列的操作流程大概是：</p><ul><li>创建一个交换机作为死信交换机</li><li>在业务队列中配置 x-dead-letter-exchange 和 x-dead-letter-routing-key，将第一步的交换机设为业务队列的死信交换机</li><li>在死信交换机上创建队列，并监听此队列</li></ul>',21)]))}const g=t(s,[["render",p]]),m=JSON.parse('{"path":"/middleware/messageQueue/rabbitmq/kuozhan/rabbitmqsixin.html","title":"RabbitMQ死信","lang":"zh-CN","frontmatter":{"title":"RabbitMQ死信","lang":"zh-CN","date":"2023-04-01T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["middleware"],"tag":["无"],"filename":"rabbitmqsixin","slug":"mx8bo5","docsId":"29412087","description":"概述 没有消费的消息叫做死信队列 生产者 --> 消息 --> 交换机 --> 队列 --> 变成死信 --> DLX交换机 -->队列 --> 消费者 概念 DLX Dead Letter Exchange 的缩写 DLX（Dead Letter Exchanges）死信交换，死信队列本身也是一个普通的消息队列，在创建队列的时候，通过设置一些关键参数...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RabbitMQ死信\\",\\"image\\":[\\"https://azrng.gitee.io/kbms/kbms/common/1609400134093-42c4d987-18cf-4d59-82e0-732efed0c75b.png\\",\\"https://azrng.gitee.io/kbms/kbms/common/1609400134139-7ef0cc81-84a6-4978-bed8-42e25eab7955.png\\"],\\"datePublished\\":\\"2023-04-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-18T08:07:34.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"],["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/middleware/messageQueue/rabbitmq/kuozhan/rabbitmqsixin.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"RabbitMQ死信"}],["meta",{"property":"og:description","content":"概述 没有消费的消息叫做死信队列 生产者 --> 消息 --> 交换机 --> 队列 --> 变成死信 --> DLX交换机 -->队列 --> 消费者 概念 DLX Dead Letter Exchange 的缩写 DLX（Dead Letter Exchanges）死信交换，死信队列本身也是一个普通的消息队列，在创建队列的时候，通过设置一些关键参数..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://azrng.gitee.io/kbms/kbms/common/1609400134093-42c4d987-18cf-4d59-82e0-732efed0c75b.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-18T08:07:34.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-04-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-18T08:07:34.000Z"}]]},"git":{"createdTime":1697724028000,"updatedTime":1723968454000,"contributors":[{"name":"azrng","username":"","email":"itzhangyunpeng@163.com","commits":3}]},"readingTime":{"minutes":3.32,"words":996},"filePathRelative":"middleware/messageQueue/rabbitmq/kuozhan/rabbitmqsixin.md","excerpt":"<h2>概述</h2>\\n<p>没有消费的消息叫做死信队列<br>\\n生产者   --&gt;  消息 --&gt; 交换机  --&gt; 队列  --&gt; 变成死信  --&gt; DLX交换机 --&gt;队列 --&gt; 消费者</p>\\n<h2>概念</h2>\\n<h3>DLX</h3>\\n<p>Dead Letter Exchange 的缩写<br>\\nDLX（Dead Letter Exchanges）死信交换，死信队列本身也是一个普通的消息队列，在创建队列的时候，通过设置一些关键参数，可以将一个普通的消息队列设置为死信队列，与其它消息队列不同的是，其入栈的消息根据入栈时指定的过期时间/被拒绝/超出队列长度被移除，依次被转发到指定的消息队列中进行二次处理。这样说法比较拗口，其原理就是死信队列内位于顶部的消息过期时，该消息将被马上发送到另外一个订阅者（消息队列）中。</p>","autoDesc":true}');export{g as comp,m as data};
