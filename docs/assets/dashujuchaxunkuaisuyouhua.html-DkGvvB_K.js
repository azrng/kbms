import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,o as t,d as s}from"./app-CHE8a282.js";const r={},a=s('<h2 id="汇总" tabindex="-1"><a class="header-anchor" href="#汇总"><span>汇总</span></a></h2><ul><li>增加索引</li><li>修改SQL语句</li><li>换用不同的函数让走索引</li><li>修改表结构</li></ul><h2 id="操作" tabindex="-1"><a class="header-anchor" href="#操作"><span>操作</span></a></h2><p>1.应尽量避免在where子句中使用！=或&lt;&gt;操作符，避免在where后面进行表达式操作会导致索引失效 2.应尽量避免在where子句中使用or来连接条件 如：select Id from t where num=10 or num=20 可以这样查询 Select id from t where num=10 Union all Select id from t where num=20 3. in 和not in 也要慎用，否则会导致全表扫描 如：select id from t where num in(1,2,3) 对于连续的数值，能用between就不要用in了 如：select id from t where num between 1 and 3 4.下面的查询也将导致全表扫描 如：select id from t where name like ‘%abc%’ 若提高效率，可以考虑全文检索 5. 如果在where子句中使用参数，也会导致全表扫描。因为sql只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时，它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描： Select id from t where num=@num 可以改为强制查询使用索引： Select id from t with(index(索引名)) where num=@num 6.应尽量避免在where子句中对字段进行表达式操作，这将导致引擎放弃使用而进行全表扫描。 如：select if from t where num/2=100 应改为：select id from t where num=100<em>2 7.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。 如：select id from t where substring(name,1,3)=’abc’ ----name以abc开头的id Select id from t where datadiff(day,createdate.’2005-11-30’)=0 ----‘2005-11-30’生成的id 应改为: Select id from t where name like ‘abc%’ Select id from t where createdate&gt;=’2005-11-30’ and createdate&lt;’2005-12-1’ 8.不要在where子句中的”=”左边进行函数，算术运算或其他表达式运算，否则系统将可能无法正确使用索引 9.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引不会被使用，并且应尽可能的让字段顺序与索引顺序相一致 10. 不要写一些没有意义的查询，如需要生成一个空表结构： Create table #t(…) 11.很多时候用exist代替in是一个好的选择 如:select num from a where num in (select num from b) 用下面的语句替换： Select num from a where exists(select 1 from b where num=a.num ) 12.并不是所有索引对查询都有效，sql是根据表中数据来进行优化查询的，当索引列有大量数据重复时，sql查询可能不会利用索引，如一表中有字段sex,male,female几乎各一半，那么即使在Sex上建了索引也对查询效率起不了作用 13.索引并不是越多越好，索引固然可以提高相应的select 的效率，但同时也降低了insert及uodate的效率，因为insert或update时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常用到的列上建的索引是否愚必要 14.尽量使用数字型字段，若只含数值信息的字段尽量不要涉及为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了 15.尽可以的使用varchar/nvarchar代替char/nchar，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显高些 16.任何地方都不要使用select * from t,用具体的字段列表代替“</em>”，不要返回用不到的任何字段 17.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引） 18.避免频繁创建和删除临时表，以减少系统表资源的消耗 19.在新建临时表时，如果一次性插入数据量很大，那么可以使用select into代替create table,避免造成大量log,以提高速度，如果数据量不大，为了缓和系统表的资源，应先create table，然后insert 20.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先truncate table,然后drop table,这样可以避免系统表的较长时间锁定 21.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写 22.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效 23.与临时表一样，游标并不是不可使用。对小型数据集使用FAST_FORWARD游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好 24.在所有的存储过程和触发器的开始处设置SET NOCOUNT ON ,在结束时设置SET NOCOUNT OFF。无需在执行存储过程和触发器的每个语句后在客户端发送DONE_IN_PROC消息 25.尽量避免大事务操作，提高系统并发能力 26.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理 27.效率Union all》or=in Like &#39;%123&#39;  不走索引   Like &#39;123%&#39;  走索引</p><h2 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项"><span>注意事项</span></a></h2><ol><li>考虑在where及order by涉及的列上建立索引</li><li>应该尽量避免在where子句中进行函数操作</li><li>当在sql语句中连接多个表时候，尽可能的使用表的别名前缀用于每个列上，这样子，就可以减少解析的时间。</li><li>少用or，可以使用union去连接多个查询，因为or处理并没有用到索引</li></ol><h2 id="资料" tabindex="-1"><a class="header-anchor" href="#资料"><span>资料</span></a></h2><p><a href="https://www.cnblogs.com/yunfeifei/p/3850440.html" target="_blank" rel="noopener noreferrer">数据库百万数据优化</a></p>',8),p=[a];function i(l,b){return t(),n("div",null,p)}const m=e(r,[["render",i],["__file","dashujuchaxunkuaisuyouhua.html.vue"]]),h=JSON.parse(`{"path":"/dataBase/commonOperator/dashujuchaxunkuaisuyouhua.html","title":"大数据查询快速优化","lang":"zh-CN","frontmatter":{"title":"大数据查询快速优化","lang":"zh-CN","date":"2023-09-23T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["dataBase"],"tag":["无"],"filename":"dashujuchaxunkuaisuyouhua","slug":"hmu4r6","docsId":"31787455","description":"汇总 增加索引 修改SQL语句 换用不同的函数让走索引 修改表结构 操作 1.应尽量避免在where子句中使用！=或<>操作符，避免在where后面进行表达式操作会导致索引失效 2.应尽量避免在where子句中使用or来连接条件 如：select Id from t where num=10 or num=20 可以这样查询 Select id fro...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dataBase/commonOperator/dashujuchaxunkuaisuyouhua.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"大数据查询快速优化"}],["meta",{"property":"og:description","content":"汇总 增加索引 修改SQL语句 换用不同的函数让走索引 修改表结构 操作 1.应尽量避免在where子句中使用！=或<>操作符，避免在where后面进行表达式操作会导致索引失效 2.应尽量避免在where子句中使用or来连接条件 如：select Id from t where num=10 or num=20 可以这样查询 Select id fro..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-19T14:59:33.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-09-23T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-19T14:59:33.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"大数据查询快速优化\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-09-23T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-19T14:59:33.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"汇总","slug":"汇总","link":"#汇总","children":[]},{"level":2,"title":"操作","slug":"操作","link":"#操作","children":[]},{"level":2,"title":"注意事项","slug":"注意事项","link":"#注意事项","children":[]},{"level":2,"title":"资料","slug":"资料","link":"#资料","children":[]}],"git":{"createdTime":1695484404000,"updatedTime":1721401173000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":1}]},"readingTime":{"minutes":6,"words":1800},"filePathRelative":"dataBase/commonOperator/dashujuchaxunkuaisuyouhua.md","localizedDate":"2023年9月23日","excerpt":"<h2>汇总</h2>\\n<ul>\\n<li>增加索引</li>\\n<li>修改SQL语句</li>\\n<li>换用不同的函数让走索引</li>\\n<li>修改表结构</li>\\n</ul>\\n<h2>操作</h2>\\n<p>1.应尽量避免在where子句中使用！=或&lt;&gt;操作符，避免在where后面进行表达式操作会导致索引失效\\n2.应尽量避免在where子句中使用or来连接条件\\n如：select&nbsp;Id&nbsp;from&nbsp;t&nbsp;where&nbsp;num=10&nbsp;or&nbsp;num=20\\n可以这样查询\\nSelect&nbsp;id&nbsp;from&nbsp;t&nbsp;where&nbsp;num=10\\nUnion&nbsp;all\\nSelect&nbsp;id&nbsp;from&nbsp;t&nbsp;where&nbsp;num=20\\n3.&nbsp;in&nbsp;和not&nbsp;in&nbsp;也要慎用，否则会导致全表扫描\\n如：select&nbsp;id&nbsp;from&nbsp;t&nbsp;where&nbsp;num&nbsp;in(1,2,3)\\n对于连续的数值，能用between就不要用in了\\n如：select&nbsp;id&nbsp;from&nbsp;t&nbsp;where&nbsp;num&nbsp;between&nbsp;1&nbsp;and&nbsp;3\\n4.下面的查询也将导致全表扫描\\n如：select&nbsp;id&nbsp;from&nbsp;t&nbsp;where&nbsp;name&nbsp;like&nbsp;‘%abc%’\\n若提高效率，可以考虑全文检索\\n5.&nbsp;如果在where子句中使用参数，也会导致全表扫描。因为sql只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时，它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：\\nSelect&nbsp;id&nbsp;from&nbsp;t&nbsp;where&nbsp;num=@num\\n可以改为强制查询使用索引：\\nSelect&nbsp;id&nbsp;from&nbsp;t&nbsp;with(index(索引名))&nbsp;where&nbsp;num=@num\\n6.应尽量避免在where子句中对字段进行表达式操作，这将导致引擎放弃使用而进行全表扫描。\\n如：select&nbsp;if&nbsp;from&nbsp;t&nbsp;where&nbsp;num/2=100\\n应改为：select&nbsp;id&nbsp;from&nbsp;t&nbsp;where&nbsp;num=100<em>2\\n7.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。\\n如：select&nbsp;id&nbsp;from&nbsp;t&nbsp;where&nbsp;substring(name,1,3)=’abc’&nbsp;----name以abc开头的id\\nSelect&nbsp;id&nbsp;from&nbsp;t&nbsp;where&nbsp;datadiff(day,createdate.’2005-11-30’)=0&nbsp;----‘2005-11-30’生成的id\\n应改为:\\nSelect&nbsp;id&nbsp;from&nbsp;t&nbsp;where&nbsp;name&nbsp;like&nbsp;‘abc%’\\nSelect&nbsp;id&nbsp;from&nbsp;t&nbsp;where&nbsp;createdate&gt;=’2005-11-30’&nbsp;and&nbsp;createdate&lt;’2005-12-1’\\n8.不要在where子句中的”=”左边进行函数，算术运算或其他表达式运算，否则系统将可能无法正确使用索引\\n9.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引不会被使用，并且应尽可能的让字段顺序与索引顺序相一致\\n10.&nbsp;不要写一些没有意义的查询，如需要生成一个空表结构：\\nCreate&nbsp;table&nbsp;#t(…)\\n11.很多时候用exist代替in是一个好的选择\\n如:select&nbsp;num&nbsp;from&nbsp;a&nbsp;where&nbsp;num&nbsp;in&nbsp;(select&nbsp;num&nbsp;from&nbsp;b)\\n用下面的语句替换：\\nSelect&nbsp;num&nbsp;from&nbsp;a&nbsp;where&nbsp;exists(select&nbsp;1&nbsp;from&nbsp;b&nbsp;where&nbsp;num=a.num&nbsp;)\\n12.并不是所有索引对查询都有效，sql是根据表中数据来进行优化查询的，当索引列有大量数据重复时，sql查询可能不会利用索引，如一表中有字段sex,male,female几乎各一半，那么即使在Sex上建了索引也对查询效率起不了作用\\n13.索引并不是越多越好，索引固然可以提高相应的select&nbsp;的效率，但同时也降低了insert及uodate的效率，因为insert或update时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常用到的列上建的索引是否愚必要\\n14.尽量使用数字型字段，若只含数值信息的字段尽量不要涉及为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了\\n15.尽可以的使用varchar/nvarchar代替char/nchar，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显高些\\n16.任何地方都不要使用select&nbsp;*&nbsp;from&nbsp;t,用具体的字段列表代替“</em>”，不要返回用不到的任何字段\\n17.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）\\n18.避免频繁创建和删除临时表，以减少系统表资源的消耗\\n19.在新建临时表时，如果一次性插入数据量很大，那么可以使用select&nbsp;into代替create&nbsp;table,避免造成大量log,以提高速度，如果数据量不大，为了缓和系统表的资源，应先create&nbsp;table，然后insert\\n20.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先truncate&nbsp;table,然后drop&nbsp;table,这样可以避免系统表的较长时间锁定\\n21.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写\\n22.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效\\n23.与临时表一样，游标并不是不可使用。对小型数据集使用FAST_FORWARD游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好\\n24.在所有的存储过程和触发器的开始处设置SET&nbsp;NOCOUNT&nbsp;ON&nbsp;,在结束时设置SET&nbsp;NOCOUNT&nbsp;OFF。无需在执行存储过程和触发器的每个语句后在客户端发送DONE_IN_PROC消息\\n25.尽量避免大事务操作，提高系统并发能力\\n26.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理\\n27.效率Union all》or=in\\nLike '%123'&nbsp; 不走索引\\n&nbsp;\\nLike '123%'&nbsp; 走索引</p>","autoDesc":true}`);export{m as comp,h as data};
