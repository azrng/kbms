import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,o as n,d as i}from"./app-Dg7YJ3hy.js";const a={},r=i('<h2 id="需求" tabindex="-1"><a class="header-anchor" href="#需求"><span>需求</span></a></h2><p>当我们遇到这种数据处理场景：我们需要一个组件实时性收集外部给它的数据，并且将它交给另外一个程序进行处理。考虑到性能，它会将数据存储到本地缓冲区，然后等累积到一定数量的时候最后统一打包发送，并且考虑到实时性，数据不能再缓冲区保存太长的时间，必须设置一个延时时间，一旦超过这个时间，缓冲的数据就必须立即发送出去。</p><p>这种还不同于使用MQ、Channel这种用来进行削锋的操作，上面的场景实时性没有那么高，但是又不想数据发送的那么频繁。</p><p>要做到上面的哪种需求，如果要综合考虑性能、线程安全、内存分配，要实现起来还真有点麻烦，不过蒋老师的文章已经给出来了实现方案，本文是对老师文章的一种学习汇总。</p><h2 id="功能" tabindex="-1"><a class="header-anchor" href="#功能"><span>功能</span></a></h2><p>使用一个对象来接受应用分发给它的资源，并且该对象会在适当的时机去处理数据(当保存的数据阈值达到一定数量后就立即处理或者两次处理的间隔超过时间时间就立即处理)。</p><h2 id="操作" tabindex="-1"><a class="header-anchor" href="#操作"><span>操作</span></a></h2><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><p><a href="https://mp.weixin.qq.com/s/RuINy1PMsx8WBJF1ZMqVQA" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/RuINy1PMsx8WBJF1ZMqVQA</a> | 如何兼顾性能+实时性处理缓冲数据？</p>',9),h=[r];function o(s,p){return n(),t("div",null,h)}const g=e(a,[["render",o],["__file","xingnengheshishixingchuli.html.vue"]]),d=JSON.parse('{"path":"/dotnet/csharp/dingzhishujujiegou/xingnengheshishixingchuli.html","title":"性能和实时性处理","lang":"zh-CN","frontmatter":{"title":"性能和实时性处理","lang":"zh-CN","date":"2023-10-22T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["csharp"],"tag":["无"],"filename":"xingnengheshishixingchuli","slug":"ahi99nqlxkgvxmgq","docsId":"133480147","description":"需求 当我们遇到这种数据处理场景：我们需要一个组件实时性收集外部给它的数据，并且将它交给另外一个程序进行处理。考虑到性能，它会将数据存储到本地缓冲区，然后等累积到一定数量的时候最后统一打包发送，并且考虑到实时性，数据不能再缓冲区保存太长的时间，必须设置一个延时时间，一旦超过这个时间，缓冲的数据就必须立即发送出去。 这种还不同于使用MQ、Channel这...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dotnet/csharp/dingzhishujujiegou/xingnengheshishixingchuli.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"性能和实时性处理"}],["meta",{"property":"og:description","content":"需求 当我们遇到这种数据处理场景：我们需要一个组件实时性收集外部给它的数据，并且将它交给另外一个程序进行处理。考虑到性能，它会将数据存储到本地缓冲区，然后等累积到一定数量的时候最后统一打包发送，并且考虑到实时性，数据不能再缓冲区保存太长的时间，必须设置一个延时时间，一旦超过这个时间，缓冲的数据就必须立即发送出去。 这种还不同于使用MQ、Channel这..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-11-17T14:50:44.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-10-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-11-17T14:50:44.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"性能和实时性处理\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-10-22T00:00:00.000Z\\",\\"dateModified\\":\\"2023-11-17T14:50:44.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"需求","slug":"需求","link":"#需求","children":[]},{"level":2,"title":"功能","slug":"功能","link":"#功能","children":[]},{"level":2,"title":"操作","slug":"操作","link":"#操作","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1700232644000,"updatedTime":1700232644000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":1}]},"readingTime":{"minutes":1.33,"words":398},"filePathRelative":"dotnet/csharp/dingzhishujujiegou/xingnengheshishixingchuli.md","localizedDate":"2023年10月22日","excerpt":"<h2>需求</h2>\\n<p>当我们遇到这种数据处理场景：我们需要一个组件实时性收集外部给它的数据，并且将它交给另外一个程序进行处理。考虑到性能，它会将数据存储到本地缓冲区，然后等累积到一定数量的时候最后统一打包发送，并且考虑到实时性，数据不能再缓冲区保存太长的时间，必须设置一个延时时间，一旦超过这个时间，缓冲的数据就必须立即发送出去。</p>\\n<p>这种还不同于使用MQ、Channel这种用来进行削锋的操作，上面的场景实时性没有那么高，但是又不想数据发送的那么频繁。</p>\\n<p>要做到上面的哪种需求，如果要综合考虑性能、线程安全、内存分配，要实现起来还真有点麻烦，不过蒋老师的文章已经给出来了实现方案，本文是对老师文章的一种学习汇总。</p>","autoDesc":true}');export{g as comp,d as data};
