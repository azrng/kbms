import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,d as t}from"./app-D8HBJYTp.js";const e={},p=t(`<h2 id="开篇语" tabindex="-1"><a class="header-anchor" href="#开篇语"><span>开篇语</span></a></h2><p>本文是读书笔记</p><h2 id="值类型" tabindex="-1"><a class="header-anchor" href="#值类型"><span>值类型</span></a></h2><p>占用空间：byte ：1字节 bool：1 chat：2   short：2   int：4 float：4 double：8  long ：8</p><h3 id="整型" tabindex="-1"><a class="header-anchor" href="#整型"><span>整型</span></a></h3><p>C#支持8个预定义的整型类型，如下表所示：</p><table><thead><tr><th>关键字</th><th>.NET struct</th><th>描述</th></tr></thead><tbody><tr><td>sbyte</td><td>System.SByte</td><td>8位有符号整数</td></tr><tr><td>short</td><td>System.Int16</td><td>16位有符号整数</td></tr><tr><td>int</td><td>System.Int32</td><td>32位有符号整数</td></tr><tr><td>long</td><td>System.Int64</td><td>64位有符号整数</td></tr><tr><td>byte</td><td>System.Byte</td><td>8位无符号整数</td></tr><tr><td>ushort</td><td>System.Int16</td><td>16位无符号整数</td></tr><tr><td>uint</td><td>System.Int32</td><td>32位无符号整数</td></tr><tr><td>ulong</td><td>System.Int64</td><td>64位无符号整数</td></tr></tbody></table><h3 id="实数" tabindex="-1"><a class="header-anchor" href="#实数"><span>实数</span></a></h3><table><thead><tr><th>类型</th><th>.NET struct</th><th>描述</th><th>小数位</th><th>示例</th></tr></thead><tbody><tr><td>float</td><td>System.Single</td><td>32位，单精度浮点数</td><td>7</td><td>float f=1.0f;</td></tr><tr><td>double</td><td>System.Double</td><td>64位，双精度浮点数</td><td>15/16</td><td>double d=1D;</td></tr><tr><td>decimal</td><td>System.Decimal</td><td>128位，高精度浮点数</td><td>28</td><td>decimal d=1.0M;</td></tr></tbody></table><blockquote><p>由于浮点型类型可以存储高精度的大额数字，因此可以使用“E 表示法”来表示该类型的值，这是一种科学记数法，表示“乘以 10 的 n 次幂”。因此，5E+2 之类的值将是 500 值，因为它相当于 5 * 10^2 或 5 * 10 * 10。</p></blockquote><h3 id="逻辑值-bool" tabindex="-1"><a class="header-anchor" href="#逻辑值-bool"><span>逻辑值(bool)</span></a></h3><p>c#里面的bool类型，对应.net类型为struct system.boolean，仅包含两个值：false和true。 对于引用类型，默认情况下相等是基于引用的，而不是底层对象的实际值。但是string是一个例外，它是引用类型，但是她的相等运算法却遵守值类型的语义。</p><h3 id="字符-char" tabindex="-1"><a class="header-anchor" href="#字符-char"><span>字符(char)</span></a></h3><p>为了表示单个字符，c#提供了char类型，对应的是struct system.char,char的赋值通常是用单括号括起来，例如 char c=&#39;A&#39;;</p><h2 id="引用类型" tabindex="-1"><a class="header-anchor" href="#引用类型"><span>引用类型</span></a></h2><h3 id="字符串-string" tabindex="-1"><a class="header-anchor" href="#字符串-string"><span>字符串(string)</span></a></h3><p>c#中字符串类型标识不可变的Unicode字符序列。字符串字面量应位于两个双引号(&quot;&quot;)之间。</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">string</span></span> name <span class="token operator">=</span> <span class="token string">&quot;张三&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>string类型的相等运算法遵守值类型的语义</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">string</span></span> a <span class="token operator">=</span> <span class="token string">&quot;ceshi&quot;</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">string</span></span> b <span class="token operator">=</span> <span class="token string">&quot;ceshi&quot;</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// True</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="类" tabindex="-1"><a class="header-anchor" href="#类"><span>类</span></a></h3><p>会有其他文章单独说明</p><h3 id="数组" tabindex="-1"><a class="header-anchor" href="#数组"><span>数组</span></a></h3><p>数组是固定长度的特定类型的变量集合。为了实现高效访问，数组中的元素总是存储在连续的内存块中。</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name"><span class="token keyword">int</span></span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0  默认值初始化  </span>

<span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> names1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> <span class="token punctuation">{</span> <span class="token string">&quot;张三&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;李四&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> names2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> <span class="token punctuation">{</span> <span class="token string">&quot;张三&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;李四&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>names1 <span class="token operator">==</span> names2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// False</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>names1<span class="token punctuation">.</span><span class="token function">Equals</span><span class="token punctuation">(</span>names2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//False</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>数组通过索引从0开始获取数组中的元素</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> names1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> <span class="token punctuation">{</span> <span class="token string">&quot;张三&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;李四&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">var</span></span> name <span class="token operator">=</span> names1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 张三</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>数组一旦创建完毕，长度将不能更改。如果使用到可变集合需要使用List或者字典。</p><h3 id="接口" tabindex="-1"><a class="header-anchor" href="#接口"><span>接口</span></a></h3><p>接口和类相似，不过接口只能为成员提供定义而不能提供实现(除了C#8后的默认接口方法)，接口可以多继承而类只能单继承.</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IUserService</span> 
<span class="token punctuation">{</span>
    <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Sum</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> x<span class="token punctuation">,</span><span class="token class-name"><span class="token keyword">int</span></span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>继承接口必须实现接口的所有成员。</p><h3 id="委托" tabindex="-1"><a class="header-anchor" href="#委托"><span>委托</span></a></h3><p>委托是一种知道如何调用方法的对象。</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code>    <span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Program</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">delegate</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">mydelegate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token class-name">mydelegate</span> de <span class="token operator">=</span> Test<span class="token punctuation">;</span>
            <span class="token class-name"><span class="token keyword">var</span></span> result <span class="token operator">=</span> de<span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token string">&quot;测试&quot;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>委托实例字面上就是调用者的代理：调用者调用委托，然后委托调用目标方法，这种间接调用方式可以将调用者和目标方法解耦。</p>`,36),o=[p];function c(l,i){return s(),a("div",null,o)}const u=n(e,[["render",c],["__file","yudingyileixing.html.vue"]]),k=JSON.parse('{"path":"/dotnet/csharp/hexincsharp/yudingyileixing.html","title":"预定义类型","lang":"zh-CN","frontmatter":{"title":"预定义类型","lang":"zh-CN","date":"2023-10-22T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["csharp"],"tag":["无"],"filename":"yudingyileixing","slug":"ixq1r9","docsId":"30760648","description":"开篇语 本文是读书笔记 值类型 占用空间：byte ：1字节 bool：1 chat：2 short：2 int：4 float：4 double：8 long ：8 整型 C#支持8个预定义的整型类型，如下表所示： 实数 由于浮点型类型可以存储高精度的大额数字，因此可以使用“E 表示法”来表示该类型的值，这是一种科学记数法，表示“乘以 10 的 n ...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dotnet/csharp/hexincsharp/yudingyileixing.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"预定义类型"}],["meta",{"property":"og:description","content":"开篇语 本文是读书笔记 值类型 占用空间：byte ：1字节 bool：1 chat：2 short：2 int：4 float：4 double：8 long ：8 整型 C#支持8个预定义的整型类型，如下表所示： 实数 由于浮点型类型可以存储高精度的大额数字，因此可以使用“E 表示法”来表示该类型的值，这是一种科学记数法，表示“乘以 10 的 n ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-11-17T14:50:44.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-10-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-11-17T14:50:44.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"预定义类型\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-10-22T00:00:00.000Z\\",\\"dateModified\\":\\"2023-11-17T14:50:44.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"开篇语","slug":"开篇语","link":"#开篇语","children":[]},{"level":2,"title":"值类型","slug":"值类型","link":"#值类型","children":[{"level":3,"title":"整型","slug":"整型","link":"#整型","children":[]},{"level":3,"title":"实数","slug":"实数","link":"#实数","children":[]},{"level":3,"title":"逻辑值(bool)","slug":"逻辑值-bool","link":"#逻辑值-bool","children":[]},{"level":3,"title":"字符(char)","slug":"字符-char","link":"#字符-char","children":[]}]},{"level":2,"title":"引用类型","slug":"引用类型","link":"#引用类型","children":[{"level":3,"title":"字符串(string)","slug":"字符串-string","link":"#字符串-string","children":[]},{"level":3,"title":"类","slug":"类","link":"#类","children":[]},{"level":3,"title":"数组","slug":"数组","link":"#数组","children":[]},{"level":3,"title":"接口","slug":"接口","link":"#接口","children":[]},{"level":3,"title":"委托","slug":"委托","link":"#委托","children":[]}]}],"git":{"createdTime":1700232644000,"updatedTime":1700232644000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":1}]},"readingTime":{"minutes":2.84,"words":851},"filePathRelative":"dotnet/csharp/hexincsharp/yudingyileixing.md","localizedDate":"2023年10月22日","excerpt":"<h2>开篇语</h2>\\n<p>本文是读书笔记</p>\\n<h2>值类型</h2>\\n<p>占用空间：byte ：1字节  bool：1  chat：2 &nbsp; short：2 &nbsp; int：4  float：4  double：8&nbsp; long ：8</p>\\n<h3>整型</h3>\\n<p>C#支持8个预定义的整型类型，如下表所示：</p>\\n<table>\\n<thead>\\n<tr>\\n<th>关键字</th>\\n<th>.NET struct</th>\\n<th>描述</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>sbyte</td>\\n<td>System.SByte</td>\\n<td>8位有符号整数</td>\\n</tr>\\n<tr>\\n<td>short</td>\\n<td>System.Int16</td>\\n<td>16位有符号整数</td>\\n</tr>\\n<tr>\\n<td>int</td>\\n<td>System.Int32</td>\\n<td>32位有符号整数</td>\\n</tr>\\n<tr>\\n<td>long</td>\\n<td>System.Int64</td>\\n<td>64位有符号整数</td>\\n</tr>\\n<tr>\\n<td>byte</td>\\n<td>System.Byte</td>\\n<td>8位无符号整数</td>\\n</tr>\\n<tr>\\n<td>ushort</td>\\n<td>System.Int16</td>\\n<td>16位无符号整数</td>\\n</tr>\\n<tr>\\n<td>uint</td>\\n<td>System.Int32</td>\\n<td>32位无符号整数</td>\\n</tr>\\n<tr>\\n<td>ulong</td>\\n<td>System.Int64</td>\\n<td>64位无符号整数</td>\\n</tr>\\n</tbody>\\n</table>","autoDesc":true}');export{u as comp,k as data};
