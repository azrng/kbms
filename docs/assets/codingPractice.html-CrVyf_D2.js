import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,o as a,d as r}from"./app-2OrQE2Jp.js";const i={},n=r('<h2 id="ddd中的写操作" tabindex="-1"><a class="header-anchor" href="#ddd中的写操作"><span>DDD中的写操作</span></a></h2><p>在写的操作中，我们需要严格地按照应用服务-&gt;聚合根-&gt;资源库的结构进行编码，写的操作又三种场景</p><ul><li>通过聚合根完成业务请求，这是DDD完成业务请求的典型方式</li><li>通过Factory完成聚合跟单创建</li><li>通过DomainService去完成业务请求，当业务放在聚合根中不合适的时候才考虑放在DomainService中</li></ul><p>资料来自：https://www.cnblogs.com/davenkin/p/ddd-coding-practices.html</p><h2 id="ddd中的读操作" tabindex="-1"><a class="header-anchor" href="#ddd中的读操作"><span>DDD中的读操作</span></a></h2><p>介绍三种读操作的方式</p><ul><li>基于领域模型的读操作：如果涉及到表关联的，需要先查询第一个，在查询第二个，然后在内存中进行处理</li><li>基于数据模型的读操作：直接另外编写一个新的领域服务，然后通过数据库读取客户端所需要的数据，然后直接返回对应的数据</li><li>CQRS：命令查询职责分离，读和写操作分别使用了不同的数据库，数据从写的模型中同步到的读的模型库中，通过领域事件的形式同步变更信息。</li></ul><p>遵循的原则是：领域中的对象不能直接返回给客户端，因为这样子领域模型的内部便暴漏给了外界，这样子如果对领域模型的修改也是直接影响到客户端，所以通常我们会对读操作专门创建用于数据展示的模型。</p><p>资料来自：https://www.cnblogs.com/davenkin/p/ddd-coding-practices.html</p><h2 id="开源项目" tabindex="-1"><a class="header-anchor" href="#开源项目"><span>开源项目</span></a></h2><h3 id="jasontaylordev-cleanarchitecture" tabindex="-1"><a class="header-anchor" href="#jasontaylordev-cleanarchitecture"><span>jasontaylordev/CleanArchitecture</span></a></h3><p>jasontaylordev/CleanArchitecture:Jason Taylor的CleanArchitecture项目是一个使用ASP.NET Core的范例应用，以演示Clean Architecture的实际应用为目的。它包含一个简单的任务管理应用程序，展示了如何使用Clean Architecture的思想和ASP.NET Core技术栈构建应用。该项目的代码结构和组织方式符合Clean Architecture的原则，分为实体（Entities）、用例（Use Cases）、接口适配器（Interface Adapters）和框架和驱动（Frameworks and Drivers）等层次。</p><p>仓库地址：<a href="https://github.com/jasontaylordev/CleanArchitecture" target="_blank" rel="noopener noreferrer">https://github.com/jasontaylordev/CleanArchitecture</a></p><h3 id="ardalis-cleanarchitecture" tabindex="-1"><a class="header-anchor" href="#ardalis-cleanarchitecture"><span>ardalis/CleanArchitecture</span></a></h3><p>ardalis/CleanArchitecture:Steve &quot;ardalis&quot; Smith的CleanArchitecture项目也是一个使用ASP.NET Core的Clean Architecture实现，旨在为开发者提供一个可用于实际项目的模板。与Taylor的项目类似，ardalis的项目也包含了一些实用的工具和模板代码，以帮助开发者更轻松地构建符合Clean Architecture的应用。</p><p>仓库地址：<a href="https://github.com/ardalis/CleanArchitecture" target="_blank" rel="noopener noreferrer">https://github.com/ardalis/CleanArchitecture</a></p>',16),c=[n];function l(o,d){return a(),t("div",null,c)}const p=e(i,[["render",l],["__file","codingPractice.html.vue"]]),m=JSON.parse('{"path":"/softwareDesign/domainDrivenDesign/codingPractice.html","title":"编码实践","lang":"zh-CN","frontmatter":{"title":"编码实践","lang":"zh-CN","date":"2023-11-26T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["软件设计"],"tag":["实践"],"description":"DDD中的写操作 在写的操作中，我们需要严格地按照应用服务->聚合根->资源库的结构进行编码，写的操作又三种场景 通过聚合根完成业务请求，这是DDD完成业务请求的典型方式 通过Factory完成聚合跟单创建 通过DomainService去完成业务请求，当业务放在聚合根中不合适的时候才考虑放在DomainService中 资料来自：https://ww...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/softwareDesign/domainDrivenDesign/codingPractice.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"编码实践"}],["meta",{"property":"og:description","content":"DDD中的写操作 在写的操作中，我们需要严格地按照应用服务->聚合根->资源库的结构进行编码，写的操作又三种场景 通过聚合根完成业务请求，这是DDD完成业务请求的典型方式 通过Factory完成聚合跟单创建 通过DomainService去完成业务请求，当业务放在聚合根中不合适的时候才考虑放在DomainService中 资料来自：https://ww..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-16T07:47:51.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"实践"}],["meta",{"property":"article:published_time","content":"2023-11-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-16T07:47:51.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"编码实践\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-11-26T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-16T07:47:51.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"DDD中的写操作","slug":"ddd中的写操作","link":"#ddd中的写操作","children":[]},{"level":2,"title":"DDD中的读操作","slug":"ddd中的读操作","link":"#ddd中的读操作","children":[]},{"level":2,"title":"开源项目","slug":"开源项目","link":"#开源项目","children":[{"level":3,"title":"jasontaylordev/CleanArchitecture","slug":"jasontaylordev-cleanarchitecture","link":"#jasontaylordev-cleanarchitecture","children":[]},{"level":3,"title":"ardalis/CleanArchitecture","slug":"ardalis-cleanarchitecture","link":"#ardalis-cleanarchitecture","children":[]}]}],"git":{"createdTime":1701007162000,"updatedTime":1718524071000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":2}]},"readingTime":{"minutes":2.14,"words":642},"filePathRelative":"softwareDesign/domainDrivenDesign/codingPractice.md","localizedDate":"2023年11月26日","excerpt":"<h2>DDD中的写操作</h2>\\n<p>在写的操作中，我们需要严格地按照应用服务-&gt;聚合根-&gt;资源库的结构进行编码，写的操作又三种场景</p>\\n<ul>\\n<li>通过聚合根完成业务请求，这是DDD完成业务请求的典型方式</li>\\n<li>通过Factory完成聚合跟单创建</li>\\n<li>通过DomainService去完成业务请求，当业务放在聚合根中不合适的时候才考虑放在DomainService中</li>\\n</ul>\\n<p>资料来自：https://www.cnblogs.com/davenkin/p/ddd-coding-practices.html</p>\\n<h2>DDD中的读操作</h2>","autoDesc":true}');export{p as comp,m as data};
