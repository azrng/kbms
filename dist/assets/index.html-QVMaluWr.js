import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as i,o as l,c as o,a as s,b as n,d as e,e as t}from"./app-vSdX8vi3.js";const c="/kbms/common/1639900402748-a0260873-3100-4c5e-977a-a343ffaa4665.png",u={},r=t('<h2 id="什么是线程" tabindex="-1"><a class="header-anchor" href="#什么是线程"><span>什么是线程</span></a></h2><p>线程（Thread）是操作系统能够进行运算调度的最小单位，也是程序中能够并发执行的一段序列。它是进程中的实际运作单位，一个进程中可以包含多个线程，每条线程并行执行不同的任务，这些线程共享进程的资源。严格意义上来说，同一时间可以并行运行的线程数取决于 CPU 的核数。</p><p>单线程应用：在进程的独立环境里面只能跑一个新线程，所以该线程拥有独占权。</p><h2 id="什么是多线程" tabindex="-1"><a class="header-anchor" href="#什么是多线程"><span>什么是多线程</span></a></h2><p>多线程编程是指使用多个线程同时执行任务。这些线程可能是由操作系统调度的，也可以由开发人员手动创建和管理。在多线程编程中，我们通常需要考虑许多问题，如线程同步、死锁、竞态条件等等</p><h3 id="为什么需要多线程" tabindex="-1"><a class="header-anchor" href="#为什么需要多线程"><span>为什么需要多线程？</span></a></h3><ul><li>批量重复任务希望同时执行，比如对于数组中的每个元素都进行相同且耗时的操作</li><li>多个不同任务希望同时执行，互不干扰，例如有多个后台线程需要做轮询操作等</li></ul><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点</span></a></h3><p>1.可以提高cpu利用率，因为当一个线程处于等待状态时候，cpu会去执行另外的线程 2.提高cpu利用率，就可以提高程序的整体执行速度</p><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点</span></a></h3><p>1.线程开的越多，内存占用越大 2.协调和管理代码的难度加大，需要cpu时间跟踪线程 3.线程之间对资源的共享可能会产生不可预知的问题。 线程是寄托在进程上的，如果进程都结束了，线程也不复存在。</p><h2 id="术语" tabindex="-1"><a class="header-anchor" href="#术语"><span>术语</span></a></h2><h3 id="线程被抢占" tabindex="-1"><a class="header-anchor" href="#线程被抢占"><span>线程被抢占</span></a></h3><p>当线程执行到与另外的线程代码执行交织的那一点，这就是线程被抢占了。</p><h3 id="线程开销" tabindex="-1"><a class="header-anchor" href="#线程开销"><span>线程开销</span></a></h3><p>线程的开销实际上是非常大的，我们从空间开销和时间开销上分别讨论。</p>',16),d={href:"https://www.cnblogs.com/pandefu/p/17536277.html",target:"_blank",rel:"noopener noreferrer"},k=t(`<h4 id="空间开销" tabindex="-1"><a class="header-anchor" href="#空间开销"><span>空间开销</span></a></h4><p>线程的空间开销来自这四个部分：</p><ol><li>线程内核对象(Thread Kernel Object)。每个线程都会创建一个这样的对象，它主要包含线程上下文信息，在32位系统中，它所占用的内存在700字节左右。</li><li>线程环境块(Thread Environment Block)。TEB包括线程的异常处理链，32位系统中占用4KB内存。</li><li>用户模式栈(User Mode Stack),即线程栈。线程栈用于保存方法的参数、局部变量和返回值。每个线程栈占用1024KB的内存。要用完这些内存很简单，写一个不能结束的递归方法，让方法参数和返回值不停地消耗内存，很快就会发生 OutOfMemoryException 。</li><li>内核模式栈(Kernel Mode Stack)。当调用操作系统的内核模式函数时，系统会将函数参数从用户模式栈复制到内核模式栈。在32位系统中，内核模式栈会占用12KB内存。</li></ol><h4 id="时间开销" tabindex="-1"><a class="header-anchor" href="#时间开销"><span>时间开销</span></a></h4><p>线程的时间开销来自这三个过程：</p><ol><li>线程创建的时候，系统相继初始化以上这些内存空间。</li><li>接着CLR会调用所有加载DLL的DLLMain方法，并传递连接标志（线程终止的时候，也会调用DLL的DLLMain方法，并传递分离标志)。</li><li>线程上下文切换。一个系统中会加载很多的进程，而一个进程又包含若干个线程。但是一个CPU内核在任何时候都只能有一个线程在执行。为了让每个线程看上去都在运行，系统会不断地切换“线程上下文”：每个线程及其短暂的执行时间片，然后就会切换到下一个线程了。这个线程上下文切换过程大概又分为以下5个步骤： <ul><li>步骤1进入内核模式。</li><li>步骤2将上下文信息（主要是一些CPU寄存器信息）保存到正在执行的线程内核对象上。</li><li>步骤3系统获取一个 Spinlock ，并确定下一个要执行的线程，然后释放 Spinlock 。如果下一个线程不在同一个进程内，则需要进行虚拟地址交换。</li><li>步骤4从将被执行的线程内核对象上载入上下文信息。</li><li>步骤5离开内核模式。</li></ul></li></ol><p>所以，由于要进行如此多的工作，所以创建和销毁一个线程就意味着代价“昂贵”，即使现在的CPU多核多线程，如无节制的使用线程，依旧会严重影响性能。</p><h2 id="线程属性" tabindex="-1"><a class="header-anchor" href="#线程属性"><span>线程属性</span></a></h2><ul><li>线程一旦开始执行，IsAlive就是true，线程结束就变成了false。</li><li>线程结束的条件就是：线程构造函数传入的委托结束了执行。</li><li>线程一旦结束，就无法重启。</li><li>每个线程都有一个Name属性，通常用于调试 <ul><li>线程的Name只能设置一次，以后在修改就会抛出异常。</li></ul></li><li>静态的Thread.CurrentThread属性，会返回当前执行的线程。</li></ul><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>//设置当前线程线程名
Thread.CurrentThread.Name <span class="token operator">=</span> <span class="token string">&quot;main thread&quot;</span><span class="token punctuation">;</span>

//输出当前线程名字
System.Console.WriteLine<span class="token punctuation">(</span>Thread.CurrentThread.Name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th>常用属性</th><th>说明</th></tr></thead><tbody><tr><td>CurrentThread</td><td>获取当前正在运行的线程</td></tr><tr><td>IsAlive</td><td>获取一个值，该值指示当前线程的执行状态</td></tr><tr><td>IsBackground</td><td>获取或设置一个值，该值指示某个线程是否为后台线程， 后台线程会随前台线程的关闭而退出</td></tr><tr><td>IsThreadPoolThread</td><td>获取一个值，该值指示线程是否属于托管线程池</td></tr><tr><td>ManagedThreadId</td><td>获取当前托管线程的唯一标识符</td></tr><tr><td>Name</td><td>获取或设置线程的名称</td></tr><tr><td>Priority</td><td>获取或设置一个值，该值指示线程的调度优先级</td></tr><tr><td>ThreadState</td><td>获取一个值，该值包含当前线程的状态</td></tr></tbody></table><h2 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项"><span>注意事项</span></a></h2><h3 id="thread限制" tabindex="-1"><a class="header-anchor" href="#thread限制"><span>Thread限制</span></a></h3><ul><li>线程(Thread)是用来创建并发的一种低代码工具，它有一些限制，比如： <ul><li>虽然开始线程的时候可以方便传入数据，但是当Join的时候，很难从线程获取返回值。 <ul><li>可能需要设置一些共享字段</li><li>如果抛出异常，捕获和传播该异常都很麻烦</li></ul></li><li>无法告诉线程在结束的时候开始做另外的工作，你必须进行Join操作(在进程中阻塞该线程)</li></ul></li><li>很难使用较小的并发来组建大型的并发。</li><li>导致对手动同步的更大依赖。</li></ul><h3 id="异常处理" tabindex="-1"><a class="header-anchor" href="#异常处理"><span>异常处理</span></a></h3><ul><li>在创建线程时在作用域的范围内try/catch/finally块，在线程开始执行后就与线程无关了。(意思就是开始线程后，里面出现异常了，线程外的try不能捕获到这个异常)</li></ul><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>internal class ThreadTest
<span class="token punctuation">{</span>
    private static void <span class="token function-name function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        try
        <span class="token punctuation">{</span>
            new Thread<span class="token punctuation">((</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
            <span class="token punctuation">{</span>
                Console.WriteLine<span class="token punctuation">(</span><span class="token string">&quot;aaa&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                throw new AggregateException<span class="token punctuation">(</span><span class="token string">&quot;异常&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>.Start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        catch <span class="token punctuation">(</span>Exception ex<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            Console.WriteLine<span class="token punctuation">(</span><span class="token string">&quot;错误&quot;</span> + ex.Message<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        /*
         * 输出结果：
         aaa
         Unhandled exception. System.AggregateException: 异常
             at ThreadTest.<span class="token operator">&lt;&gt;</span>c.<span class="token operator">&lt;</span>Main<span class="token operator">&gt;</span>b__0_0<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">in</span> E:<span class="token punctuation">\\</span>Test<span class="token punctuation">\\</span>ConsoleApp3<span class="token punctuation">\\</span>ConsoleApp3<span class="token punctuation">\\</span>Program.cs:line <span class="token number">27</span>
             at System.Threading.Thread.StartCallback<span class="token punctuation">(</span><span class="token punctuation">)</span>
        
        解决方案：将try加入到线程方法里面
         */

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="进程操作" tabindex="-1"><a class="header-anchor" href="#进程操作"><span>进程操作</span></a></h2><p>进程：每个线程都在操作系统的进程内执行，而操作系统进程提供了程序运行的独立环境。</p><h3 id="获取进程" tabindex="-1"><a class="header-anchor" href="#获取进程"><span>获取进程</span></a></h3><p><code>Process.GetProcessesXXX</code>方法通过名称或者进程ID来检查执行的进程或者检索本机或者指定名称的计算机中所有的进程(包含托管和非托管进程)。 获取当前计算机上所有执行中的进程：</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> item <span class="token keyword">in</span> Process<span class="token punctuation">.</span><span class="token function">GetProcesses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>ProcessName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;    PID </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">item<span class="token punctuation">.</span>Id</span><span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;    Memory </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">item<span class="token punctuation">.</span>WorkingSet64</span><span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;    Threads </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">item<span class="token punctuation">.</span>Threads<span class="token punctuation">.</span>Count</span><span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//返回当前的进程</span>
<span class="token class-name"><span class="token keyword">var</span></span> currProcessName <span class="token operator">=</span> Process<span class="token punctuation">.</span><span class="token function">GetCurrentProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ProcessName<span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>currProcessName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//终结进程</span>
<span class="token class-name"><span class="token keyword">var</span></span> process <span class="token operator">=</span> Process<span class="token punctuation">.</span><span class="token function">GetProcessById</span><span class="token punctuation">(</span><span class="token number">13976</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
process<span class="token punctuation">.</span><span class="token function">Kill</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="开启一个进程" tabindex="-1"><a class="header-anchor" href="#开启一个进程"><span>开启一个进程</span></a></h3><p>通过Process类来开启进程</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">var</span></span> p <span class="token operator">=</span> Process<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token string">&quot;D:\\\\Soft\\\\cat\\\\RunCat.exe&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//延迟3s</span>
Thread<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">4000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//杀掉进程</span>
p<span class="token punctuation">.</span><span class="token function">Kill</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,25),v={href:"https://mp.weixin.qq.com/s/vJ7T-GgThzUEBAnIDesCfQ",target:"_blank",rel:"noopener noreferrer"},m=s("code",null,".NET FX",-1),b=s("code",null,".NET Core+",-1),h=t(`<h2 id="线程操作" tabindex="-1"><a class="header-anchor" href="#线程操作"><span>线程操作</span></a></h2><h3 id="获取线程" tabindex="-1"><a class="header-anchor" href="#获取线程"><span>获取线程</span></a></h3><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token comment">//获取某一个进程里面的所有线程</span>
<span class="token class-name"><span class="token keyword">var</span></span> process <span class="token operator">=</span> Process<span class="token punctuation">.</span><span class="token function">GetProcessById</span><span class="token punctuation">(</span><span class="token number">13976</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>process<span class="token punctuation">.</span>HasExited<span class="token punctuation">)</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name">ProcessThread</span> item <span class="token keyword">in</span> process<span class="token punctuation">.</span>Threads<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>Id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;    state:</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">item<span class="token punctuation">.</span>ThreadState</span><span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;    priority:</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">item<span class="token punctuation">.</span>PriorityLevel</span><span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;    started:</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">item<span class="token punctuation">.</span>StartTime</span><span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;    cpu time:</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">item<span class="token punctuation">.</span>TotalProcessorTime</span><span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Thread.CurrentThread 是一个 静态的 Thread 类，Thread 的CurrentThread 属性，可以获取到当前运行线程的一些信息</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">var</span></span> currentThread <span class="token operator">=</span> Thread<span class="token punctuation">.</span>CurrentThread<span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;线程标识：&quot;</span> <span class="token operator">+</span> currentThread<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;当前地域：&quot;</span> <span class="token operator">+</span> currentThread<span class="token punctuation">.</span>CurrentCulture<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;线程执行状态：&quot;</span> <span class="token operator">+</span> currentThread<span class="token punctuation">.</span>IsAlive<span class="token punctuation">)</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;是否为后台线程：&quot;</span> <span class="token operator">+</span> currentThread<span class="token punctuation">.</span>IsBackground<span class="token punctuation">)</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;是否为线程池线程&quot;</span> <span class="token operator">+</span> currentThread<span class="token punctuation">.</span>IsThreadPoolThread<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="创建新线程" tabindex="-1"><a class="header-anchor" href="#创建新线程"><span>创建新线程</span></a></h3><h4 id="thread" tabindex="-1"><a class="header-anchor" href="#thread"><span>Thread</span></a></h4><ul><li>Start <ul><li>不带参数：new Thread(()=&gt;{ xxxxx }).Start();</li><li>带参数：new Thread((obj)=&gt;{ xxxx }).Start();</li></ul></li><li>Join <ul><li>类似于Task.Wait()方法的作用</li><li>不带超时参数：thread.Join()</li><li>带超时参数：thread.Join(1000*5)</li></ul></li><li>Sleep <ul><li>冻结当前线程指定的删减：<code>Thread.Sleep(1000*5)</code></li></ul></li><li>IsBackground属性 <ul><li>指明当前线程为后台线程，默认是前台线程</li><li>如果主线程退出，后台线程自动退出</li><li>只有所有的前台线程都退出 ，主线程才能退出</li></ul></li></ul><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token comment">// 创建两个新的 Thread</span>
<span class="token class-name"><span class="token keyword">var</span></span> thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">PerformAction</span><span class="token punctuation">(</span><span class="token string">&quot;Thread&quot;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">var</span></span> thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">PerformAction</span><span class="token punctuation">(</span><span class="token string">&quot;Thread&quot;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 开始执行线程任务</span>
thread1<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
thread2<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 等待两个线程执行完成</span>
thread1<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
thread2<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;done!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">PerformAction</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> str<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> num<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;num:</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">num</span><span class="token punctuation">}</span></span><span class="token string">  内容：</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">str</span><span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际使用中，关于thread的使用不多，因为它较为底层</p><ul><li>线程太多，造成上下文奇切换频繁(CPU爆高) <ul><li>比如创建了5000个thread，假设都在执行耗时任务，而运行的服务器只有6核12线程，必然会造成频繁的上下文切换</li></ul></li><li>GC负担过大，徒增GC负担 <ul><li>比如创建了5000个thread跑了任务之后，虽然没有引用根了，但是GC还没有及时回收，这个时候他们就是dead thread，它们都在托管堆上</li></ul></li><li>一些方案 <ul><li>ThreadPool：线程池</li><li>Task：基于ThreadPool的上层封装</li></ul></li></ul><h4 id="timer" tabindex="-1"><a class="header-anchor" href="#timer"><span>Timer</span></a></h4><p>后台线程</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;当前线程ID：&quot;</span> <span class="token operator">+</span> Environment<span class="token punctuation">.</span>CurrentManagedThreadId<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//Timer：后台线程</span>
<span class="token class-name"><span class="token keyword">var</span></span> timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Timer</span><span class="token punctuation">(</span><span class="token keyword">delegate</span>
<span class="token punctuation">{</span>
    <span class="token comment">//阻塞3秒</span>
    Thread<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;Timer Thread ID: </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">Thread<span class="token punctuation">.</span>CurrentThread<span class="token punctuation">.</span>ManagedThreadId</span><span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">.</span>Second</span><span class="token punctuation">}</span></span><span class="token string"> Timer tick&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*
输出结果：
当前线程ID：1
Timer Thread ID: 6
19 Timer tick
Timer Thread ID: 9
22 Timer tick
Timer Thread ID: 6
25 Timer tick
Timer Thread ID: 4
28 Timer tick
*/</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="periodictimer" tabindex="-1"><a class="header-anchor" href="#periodictimer"><span>PeriodicTimer</span></a></h4><p>.Net6新增加的东西。</p><ul><li>异步执行</li><li>前台线程</li></ul><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token comment">//间隔时间1秒</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;主线程ID：</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">Environment<span class="token punctuation">.</span>CurrentManagedThreadId</span><span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">PeriodicTimer</span><span class="token punctuation">(</span>TimeSpan<span class="token punctuation">.</span><span class="token function">FromSeconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//在到达指定周期后执行方法</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">await</span> timer<span class="token punctuation">.</span><span class="token function">WaitForNextTickAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">await</span> Task<span class="token punctuation">.</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;Timer Thread: </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">Thread<span class="token punctuation">.</span>CurrentThread<span class="token punctuation">.</span>ManagedThreadId</span><span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">.</span>Second</span><span class="token punctuation">}</span></span><span class="token string"> PeriodicTimer tick&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//输出结果</span>
主线程ID：<span class="token number">1</span>
<span class="token class-name">Timer</span> Thread<span class="token punctuation">:</span> <span class="token number">8</span>
<span class="token number">25</span> PeriodicTimer tick
<span class="token class-name">Timer</span> Thread<span class="token punctuation">:</span> <span class="token number">8</span>
<span class="token number">28</span> PeriodicTimer tick
<span class="token class-name">Timer</span> Thread<span class="token punctuation">:</span> <span class="token number">4</span>
<span class="token number">31</span> PeriodicTimer tick
<span class="token class-name">Timer</span> Thread<span class="token punctuation">:</span> <span class="token number">4</span>
<span class="token number">34</span> PeriodicTimer tick
<span class="token class-name">Timer</span> Thread<span class="token punctuation">:</span> <span class="token number">4</span>
<span class="token number">37</span> PeriodicTimer tick
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>停止定时器</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token comment">//创建CancellationTokenSource，指定在3秒后将被取消</span>
<span class="token class-name"><span class="token keyword">var</span></span> cts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">CancellationTokenSource</span><span class="token punctuation">(</span>TimeSpan<span class="token punctuation">.</span><span class="token function">FromSeconds</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">PeriodicTimer</span><span class="token punctuation">(</span>TimeSpan<span class="token punctuation">.</span><span class="token function">FromSeconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">await</span> timer<span class="token punctuation">.</span><span class="token function">WaitForNextTickAsync</span><span class="token punctuation">(</span>cts<span class="token punctuation">.</span>Token<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">.</span>Second</span><span class="token punctuation">}</span></span><span class="token string"> PeriodicTimer tick&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>会引发OperationCancelled异常，你需要捕获该异常，然后根据需要进行处理。 也可以通过主动取消CancellationTokenSource，来停止PeriodicTimer计时，换成了TaskCancelled异常。示例代码如下：</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">var</span></span> cts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">CancellationTokenSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">PeriodicTimer</span><span class="token punctuation">(</span>TimeSpan<span class="token punctuation">.</span><span class="token function">FromSeconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword">int</span></span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">await</span> timer<span class="token punctuation">.</span><span class="token function">WaitForNextTickAsync</span><span class="token punctuation">(</span>cts<span class="token punctuation">.</span>Token<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>count <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment">//执行3次后取消</span>
            cts<span class="token punctuation">.</span><span class="token function">Cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">.</span>Second</span><span class="token punctuation">}</span></span><span class="token string"> PeriodicTimer tick&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果，你不想抛出异常，则可以用PeriodicTimer.Dispose方法来停止计时，示例代码如下：</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">PeriodicTimer</span><span class="token punctuation">(</span>TimeSpan<span class="token punctuation">.</span><span class="token function">FromSeconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword">int</span></span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">await</span> timer<span class="token punctuation">.</span><span class="token function">WaitForNextTickAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>count <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment">//执行3次后取消</span>
            timer<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">.</span>Second</span><span class="token punctuation">}</span></span><span class="token string"> PeriodicTimer tick&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="线程的状态" tabindex="-1"><a class="header-anchor" href="#线程的状态"><span>线程的状态</span></a></h3><p>ThreadState是一个flags枚举，标识了线程的执行状态，，里面包含多种状态。</p><ul><li>大多数枚举值不常用，常用的有四个：Unstarted、Running、WaitSleepJoin和Stopped。</li></ul><blockquote><p>注意：ThreadState属性可用于诊断的目录，但是不适用于同步，因为线程的状态可能会在测试ThreadState和对该信息进行操作之间发生变化。</p></blockquote><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Flags</span></span><span class="token punctuation">]</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">ThreadState</span>
<span class="token punctuation">{</span>
	Running <span class="token operator">=</span> <span class="token number">0x0</span><span class="token punctuation">,</span>
	StopRequested <span class="token operator">=</span> <span class="token number">0x1</span><span class="token punctuation">,</span>
	SuspendRequested <span class="token operator">=</span> <span class="token number">0x2</span><span class="token punctuation">,</span>
	Background <span class="token operator">=</span> <span class="token number">0x4</span><span class="token punctuation">,</span>
	Unstarted <span class="token operator">=</span> <span class="token number">0x8</span><span class="token punctuation">,</span>
	Stopped <span class="token operator">=</span> <span class="token number">0x10</span><span class="token punctuation">,</span>
	WaitSleepJoin <span class="token operator">=</span> <span class="token number">0x20</span><span class="token punctuation">,</span>
	Suspended <span class="token operator">=</span> <span class="token number">0x40</span><span class="token punctuation">,</span>
	AbortRequested <span class="token operator">=</span> <span class="token number">0x80</span><span class="token punctuation">,</span>
	Aborted <span class="token operator">=</span> <span class="token number">0x100</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th><strong>枚举</strong></th><th><strong>枚举</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Aborted</td><td>256</td><td>该线程现在已死，但其状态尚未更改为 Stopped</td></tr><tr><td>AbortRequested</td><td>128</td><td>已对线程调用了 Abort(Object) 方法，但线程尚未收到试图终止它的挂起的 ThreadAbortException</td></tr><tr><td>Background</td><td>4</td><td>线程正作为后台线程执行</td></tr><tr><td>Running</td><td>0</td><td>线程已启动且尚未停止</td></tr><tr><td>Stopped</td><td>16</td><td>线程已停止</td></tr><tr><td>StopRequested</td><td>1</td><td>正在请求线程停止</td></tr><tr><td>Suspended</td><td>64</td><td>线程已挂起</td></tr><tr><td>SuspendRequested</td><td>2</td><td>正在请求线程挂起</td></tr><tr><td>Unstarted</td><td>8</td><td>尚未对线程调用 Start() 方法</td></tr><tr><td>WaitSleepJoin</td><td>32</td><td>线程阻塞中</td></tr></tbody></table><p><img src="`+c+`" alt="image.png" loading="lazy"> 刚刚创建的线程处于已经准备好运行，但是还没有运行的状态，称为Ready(准备)状态。在操作系统的调度之下，这个线程可以进入(Runing)运行状态。运行状态的线程可能因为时间片用完的缘故被操作系统切换出CPU，称为Suspended(暂停运行)状态，也可能在时间片还没有用完的情况下，因为等待其他优先级更高的任务，而转换到Blocked(阻塞)状态。在阻塞状态下的线程，随时可以因为再次调度而重新进入运行状态。线程还可能通过Sleep方法进入Sleep(睡眠)状态，当睡眠时间到期之后，可以再次被调度运行。处于运行状态的线程还可能被主动终止执行，直接结束；也可能因为任务已经完成，被操作系统正常结束。</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword">var</span></span> currentThread <span class="token operator">=</span> Thread<span class="token punctuation">.</span>CurrentThread<span class="token punctuation">;</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>currentThread<span class="token punctuation">.</span>ThreadState<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>注意：线程的 ThreadState 属性，并不能表面线程实时状态。因为线程执行时，可能会被 CPU 夺取时间片</p></blockquote><h3 id="控制线程数量" tabindex="-1"><a class="header-anchor" href="#控制线程数量"><span>控制线程数量</span></a></h3><p>当线程数量达到一定数量，就意味着计算机管理不过来了，并且开线程也需要内存支持，防着内存被耗尽。 新开的线程可能需要等待相当长时间才会开始执行，因为这个是通过计算机调度决定的。比如你使用for循环开启一堆线程，然后再去开启新线程看下多久可以执行。线程切换也会造成性能损耗。</p><p>不要滥用线程，也不要滥用过多的线程，当工作需要去新开线程的时候，要仔细考虑该工作是否真正需要开启线程去解决，即时需要使用线程，也推荐使用线程池解决。</p><h3 id="i-o密集和计算密集" tabindex="-1"><a class="header-anchor" href="#i-o密集和计算密集"><span>I/O密集和计算密集</span></a></h3><p>I/O密集：一个操作的绝大部分时间都在等待事件的发生。比如读取或者写入文件。 计算密集：操作的大部分时间都用来执行大量的CPU操作。</p><h3 id="上下文切换" tabindex="-1"><a class="header-anchor" href="#上下文切换"><span>上下文切换</span></a></h3><ul><li>windows系统大概30ms进行一次上下文切换，如果上下文切换非常频繁，会造成CPU爆高</li><li>在上下文切换的时候涉及CPU和与Thread的交互 <ul><li>时间片到了，线程暂停，涉及到的数据保存(将高速缓存的数据存到线程的本地存储中)</li><li>时间片分配，thread恢复，涉及到数据恢复(从线程的环境块中将当时的数据重新提取出来)</li></ul></li></ul><h3 id="阻塞线程" tabindex="-1"><a class="header-anchor" href="#阻塞线程"><span>阻塞线程</span></a></h3><ul><li>如果线程的执行由于某种原因导致暂停，那么就认为该线程被阻塞了。 <ul><li>例如通过Sleep或者通过Join等待其他线程的结束。</li></ul></li><li>被阻塞的线程会立即将其处理的时间片还给其他线程，从此不再消耗处理器时间，直到满足阻塞条件(阻塞时间结束)为止。</li><li>可以通过ThreadState这个属性来判断线程是否处于被阻塞状态。</li></ul><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>bool isBlocked <span class="token operator">=</span> <span class="token punctuation">(</span>t.ThreadState <span class="token operator">&amp;</span> ThreadState.WaitSleepJoin<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>注意：当线程被阻塞或者解除阻塞时候，操作系统会进行一次上下文切换，这会导致细小的开销，一般在1到2毫秒左右。</p></blockquote><h4 id="sleep" tabindex="-1"><a class="header-anchor" href="#sleep"><span>Sleep</span></a></h4><p>Thread.Sleep() 、Thread.Yield() 方法可以将当前线程挂起一段时间。</p><blockquote><p>注意：Thread.Sleep() 将会导致线程立即放弃自己的时间片，将 CPU 交于其他的线程，而 Thread.Yield() 虽然交出时间片，但是<strong>它只会将资源交给同一个处理器上运行的线程</strong>。另一方面，及时没有其它线程要运行了，Thread.Sleep(xxx) 也会保证当前的线程继续休眠一段时间，而 Thread.Yield() 则会让不出来（没有其它线程可以要用 CPU），而且 Thread.Yield() 只是把 CPU 让一下，很快又会被分配时间片的。当然，如果是使用 Thread.Sleep(0) ，也会达到相同效果。</p></blockquote>`,47),g={href:"https://threads.whuanle.cn/1.thread_basic/1.thread",target:"_blank",rel:"noopener noreferrer"},T=t(`<h4 id="join" tabindex="-1"><a class="header-anchor" href="#join"><span>Join</span></a></h4><p>调用Thread的Join方法可以等待线程结束。 Thread.Join() 方法可以阻塞当前线程一直等待另一个线程运行至结束，需要两个线程配合。 示例： A 线程等待 B 线程执行完成，A 线程才能继续执行。</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token class-name"><span class="token keyword">var</span></span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span><span class="token punctuation">(</span>Print<span class="token punctuation">)</span><span class="token punctuation">;</span>
	Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;开始执行线程 B&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	thread<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 开始等待另一个完成完成</span>
	thread<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;线程 B 已经完成&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		Thread<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="添加超时" tabindex="-1"><a class="header-anchor" href="#添加超时"><span>添加超时</span></a></h5><ul><li>调用Join的时候，可以设置一个超时时间，用毫秒或者TimeSpan都可以。 <ul><li>如果返回true，那么就是线程结束了，如果超时了，那么就返回false。</li></ul></li><li>Thread.Sleep()方法会暂停当前的线程，并等一段时间。</li></ul><blockquote><p>Thread.Sleep(0)将会导致线程立即放弃自己的时间片，自觉地将CPU交于其他的线程。Thread.Yield()执行相同的操作，但是它仅仅会将资源交给同一个处理器上运行的线程。<strong>在等待线程Sleep或者Join的过程中，线程是阻塞(blocked)的.</strong></p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>//开启一个新的线程
Thread t <span class="token operator">=</span> new Thread<span class="token punctuation">(</span>WriteY<span class="token punctuation">)</span><span class="token punctuation">;</span>
t.Name <span class="token operator">=</span> <span class="token string">&quot;y thread&quot;</span><span class="token punctuation">;</span>
//设置线程的优先级<span class="token punctuation">(</span>只是提议<span class="token punctuation">)</span>
t.Priority <span class="token operator">=</span> ThreadPriority.Highest<span class="token punctuation">;</span> //0-31
t.Start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

//t.Join<span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
//或者
//t.Join<span class="token punctuation">(</span>TimeSpan.FromSeconds<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">))</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>t.Join<span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">))</span>
    Console.WriteLine<span class="token punctuation">(</span><span class="token string">&quot;线程结束&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">else</span>
    Console.WriteLine<span class="token punctuation">(</span><span class="token string">&quot;超时了&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


static void <span class="token function-name function">WriteY</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    System.Console.WriteLine<span class="token punctuation">(</span>Thread.CurrentThread.Name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i++<span class="token punctuation">)</span>
        System.Console.Write<span class="token punctuation">(</span><span class="token string">&quot;y&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    Thread.Sleep<span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果输出超时了。</p><h4 id="wait方法" tabindex="-1"><a class="header-anchor" href="#wait方法"><span>Wait方法</span></a></h4><p>调用Task的Wait方法可以阻塞当前方法，直到任务结束。</p><h4 id="解除阻塞" tabindex="-1"><a class="header-anchor" href="#解除阻塞"><span>解除阻塞</span></a></h4><p>当遇到下面四种情况的时候，就会接触阻塞</p><ul><li>阻塞条件被满足</li><li>操作超时(前提是设置了超时)</li><li>通过Thread.Interrupt()进行打断</li><li>通过Theead.Abort()进行中止</li></ul><h3 id="阻塞与自旋" tabindex="-1"><a class="header-anchor" href="#阻塞与自旋"><span>阻塞与自旋</span></a></h3><p>阻塞：设置线程来阻塞线程。 同步等待：在当前线程上同步的等待，比如Console.ReadLine()、Thread.Sleep()、Thread.Join()</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">while</span><span class="token punctuation">(</span>DataTime<span class="token punctuation">.</span>Now <span class="token operator">&lt;</span> nextStartTime<span class="token punctuation">)</span>
    Thread<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>异步的操作，在稍后操作完成时候出发一个回调操作。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>var writeTask <span class="token operator">=</span> WriteY<span class="token punctuation">(</span><span class="token punctuation">)</span>.GetAwaiter<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
writeTask.OnCompleted<span class="token punctuation">((</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
    writeTask.GetResult<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    global::System.Console.WriteLine<span class="token punctuation">(</span><span class="token string">&quot;执行结束&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Console.ReadLine<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

static async Task <span class="token function-name function">WriteY</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    await Task.Delay<span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    Console.WriteLine<span class="token punctuation">(</span>Thread.CurrentThread.Name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i++<span class="token punctuation">)</span>
        Console.Write<span class="token punctuation">(</span><span class="token string">&quot;y&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>自旋：使得程序一直在当前代码循环。</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">while</span><span class="token punctuation">(</span>DataTime<span class="token punctuation">.</span>Now <span class="token operator">&lt;</span> nextStartTime<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 在.net中提供了特殊的方法来提供帮助SpinLock SpinWait</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果只是短暂的自旋是非常搞笑的，因为避免了上下文切换带来的延迟和开销。阻塞也并非是零开销，因为每个线程在存活的时候会占用1MB的内存，并对CLR和操作系统带来持续性的管理开销。</p><h3 id="线程等待" tabindex="-1"><a class="header-anchor" href="#线程等待"><span>线程等待</span></a></h3><p>线程等待有内核模式(Kernel Mode)和用户模式(User Model)。 因为只有操作系统才能控制线程的生命周期，因此使用 Thread.Sleep() 等方式阻塞线程，发生上下文切换，此种等待称为内核模式。 用户模式使线程等待，并不需要线程切换上下文，而是让线程通过执行一些无意义的运算，实现等待。也称为自旋。</p><p>Thread.Sleep(); 会阻塞线程，使得线程交出时间片，然后处于休眠状态，直至被重新唤醒；适合用于长时间的等待，过段的线程等待，这种切换代价比较昂贵； Thread.SpinWait(); 使用了自旋等待，等待过程中会进行一些的运算，线程不会休眠，用于微小的时间等待；长时间等待会影响性能； SpinWait.SpinUntil()；是Thread.SpinWait新的实现。 Task.Delay(); 用于异步中的等待</p><h3 id="终止线程" tabindex="-1"><a class="header-anchor" href="#终止线程"><span>终止线程</span></a></h3><p>Abort() 方法不能在 .NET Core 上使用，不然会出现<code> System.PlatformNotSupportedException:“Thread abort is not supported on this platform.”</code> 。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Abort()</td><td>在调用此方法的线程上引发 ThreadAbortException，以开始终止此线程的过程。 调用此方法通常会终止线程。</td></tr><tr><td>Abort(Object)</td><td>引发在其上调用的线程中的 ThreadAbortException以开始处理终止线程，同时提供有关线程终止的异常信息。 调用此方法通常会终止线程。</td></tr></tbody></table><p>Abort() 方法给线程注入 ThreadAbortException 异常，导致线程被终止。 虽然 Abort() 不能用，但是还有 Thread.Interrupt() 可以用，它可以<strong>中断处于 WaitSleepJoin 线程状态的线程</strong>。当对另一个线程调用 Interrupt 时，会弹出 System.Threading.ThreadInterruptedException 异常，导致线程中止。在调试环境下，可能会导致 Vistual Studio 弹出异常，直接启动编译后的程序或者不使用调试模式运行，则不会弹出异常。</p><blockquote><p>注意：如果线程不会处于 WaitSleepJoin 状态，而是一直运行，则 Interrupt() 函数对线程无效</p></blockquote><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">long</span></span> <span class="token keyword">value</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token class-name"><span class="token keyword">var</span></span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
<span class="token punctuation">{</span>
    <span class="token keyword">try</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">long</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">value</span><span class="token operator">++</span><span class="token punctuation">;</span>
            Thread<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ThreadInterruptedException</span> e<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;线程被终止&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;开始执行线程 B&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

thread<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;等待终止线程&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 等待2秒</span>
Thread<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
thread<span class="token punctuation">.</span><span class="token function">Interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;value:</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp"><span class="token keyword">value</span></span><span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如何模拟出来一直运行的效果取消不了的情况，那就是while(true)，且里面不包含等待的方法</p><div class="language-c# line-numbers-mode" data-ext="c#" data-title="c#"><pre class="language-c#"><code>long value = 0;

var thread = new Thread((obj) =&gt;
{
    try
    {
        while (true)
        {
            // 如果里面没有任何要阻塞的操作，那么就会一直执行，取消不了
            // 如果真遇到这个情况，那么就需要做一个等待的代码
            // 为什么要写0那，因为我们的目的是让存在等待的代码，以允许我们执行线程取消，为什么不写1的，因为如果写1，实际也不会等待1毫秒
            Thread.Sleep(0);
        }
    }
    catch (ThreadInterruptedException e)
    {
        Console.WriteLine(&quot;线程被终止&quot;);
    }
});
Console.WriteLine(&quot;开始执行线程 B&quot;);

thread.Start();

Console.WriteLine(&quot;等待终止线程&quot;);

// 等待2秒
Thread.Sleep(2000);
thread.Interrupt();
Console.WriteLine($&quot;value:{value}&quot;);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以要求while(true)中必须要包含等待的方法，比如IO操作、Thread.Sleep等</p><h3 id="线程不确定性" tabindex="-1"><a class="header-anchor" href="#线程不确定性"><span>线程不确定性</span></a></h3><p>线程的不确定性是指几个并发运行的线程，不确定下一次 CPU 时间片会分配给谁(当然，分配有优先级)。 多线程是并发运行的，但一般 CPU 没有那么多核，不可能在同一时刻执行所有的线程。CPU 会决定某个时刻将时间片分配给多个线程中的一个线程，这就出现了 CPU 的时间片分配调度。</p><h3 id="跨线程数据共享" tabindex="-1"><a class="header-anchor" href="#跨线程数据共享"><span>跨线程数据共享</span></a></h3><h4 id="跨线程使用" tabindex="-1"><a class="header-anchor" href="#跨线程使用"><span>跨线程使用</span></a></h4><p>不建议跨线程使用数据</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//输出结果</span>
<span class="token number">2</span>
<span class="token number">3</span>
<span class="token number">2</span>
<span class="token number">4</span>
<span class="token number">5</span>
<span class="token number">6</span>
<span class="token number">7</span>
<span class="token number">8</span>
<span class="token number">8</span>
<span class="token number">10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是因为一个cpu核心修改了变量的值但是还没有写到内存的时候，另一个cpu读取到了旧的值，便会出现脏读。可以修改为</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
    <span class="token punctuation">{</span>
        <span class="token class-name"><span class="token keyword">var</span></span> <span class="token keyword">value</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//输出结果</span>
<span class="token number">1</span>
<span class="token number">2</span>
<span class="token number">3</span>
<span class="token number">4</span>
<span class="token number">5</span>
<span class="token number">6</span>
<span class="token number">7</span>
<span class="token number">8</span>
<span class="token number">9</span>
<span class="token number">10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每个线程单独存储一个变量，读写时不会相互干扰</p><h4 id="线程共享" tabindex="-1"><a class="header-anchor" href="#线程共享"><span>线程共享</span></a></h4><h5 id="local本地独立" tabindex="-1"><a class="header-anchor" href="#local本地独立"><span>Local本地独立</span></a></h5><p>CLR为每个线程分配自己的内存栈，以便使得本地变量保持独立。</p><h5 id="shared共享" tabindex="-1"><a class="header-anchor" href="#shared共享"><span>Shared共享</span></a></h5><ul><li>如果多个线程都引用到同一个对象的实例，那么他们就共享了数据。</li></ul><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>class ThreadTest
<span class="token punctuation">{</span>
    bool _done<span class="token punctuation">;</span>

    private static void <span class="token function-name function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        //由于是在同一个示例上调用的go<span class="token punctuation">(</span><span class="token punctuation">)</span>,所以他们共享_done
        ThreadTest tt <span class="token operator">=</span> new ThreadTest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        new Thread<span class="token punctuation">(</span>tt.Go<span class="token punctuation">)</span>.Start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tt.Go<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//结果就是只打印一次done！
    <span class="token punctuation">}</span>

    private void <span class="token function-name function">Go</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_done<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            _done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            Console.WriteLine<span class="token punctuation">(</span><span class="token string">&quot;done!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>被Lambda表达式或者匿名委托捕捉的本地变量，会被编译器转换成字段(field),所以也会被共享。</li></ul><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>internal class ThreadTest
<span class="token punctuation">{</span>
    private static void <span class="token function-name function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        bool _done <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        ThreadStart action <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_done<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                _done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                Console.WriteLine<span class="token punctuation">(</span><span class="token string">&quot;done!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        new Thread<span class="token punctuation">(</span>action<span class="token punctuation">)</span>.Start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        action<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        //当_done被lambda捕捉到之后，就转换为ThreadTest类的一个字段，然后输出一次done！
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>静态字段(field)也会在线程间共享数据。</li></ul><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>internal class ThreadTest
<span class="token punctuation">{</span>
    //静态字段在同一个应用域下的所有线程中被共享
    static bool _done<span class="token punctuation">;</span>

    private static void <span class="token function-name function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        new Thread<span class="token punctuation">(</span>Go<span class="token punctuation">)</span>.Start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Go<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//结果就是只打印一次done！
    <span class="token punctuation">}</span>

    static void <span class="token function-name function">Go</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_done<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            _done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            Console.WriteLine<span class="token punctuation">(</span><span class="token string">&quot;done!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面三个示例的输出实际上是无法确定的，有可能会被打印两次。</p><h4 id="安全-锁" tabindex="-1"><a class="header-anchor" href="#安全-锁"><span>安全(锁)</span></a></h4><p>尽可能避免使用共享状态。</p><ul><li><p>在读取和写入共享数据的时候，通过使用一个互斥锁，就可以解决前面的例子。</p></li><li><p>c#使用lock锁或者Monitor，前者是后者的语法糖。</p><ul><li>锁对象应该是在多个线程中可见的同一对象</li><li>在非静态方法中，静态变量不应该作为锁对象</li><li>值类型不能作为锁对象</li><li>避免将字符串作为锁对象</li><li>降低锁对象的可见性</li></ul></li><li><p>当两个线程同时竞争一个锁的时候，一个线程会等待或者阻塞，直到锁变为可用状态。</p></li><li><p>在多线程上下文中，通过上面的lock来避免不确定的代码就叫做<strong>线程安全。</strong></p></li><li><p>lock也会引起一些问题，比如死锁。</p></li></ul><h5 id="往线程传递数据" tabindex="-1"><a class="header-anchor" href="#往线程传递数据"><span>往线程传递数据</span></a></h5><ul><li>如果想往线程的启动方法里传递参数，最简单的方法就是使用lambda表达式，在里面使用参数调用方法。</li></ul><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>internal class ThreadTest
<span class="token punctuation">{</span>
    private static void <span class="token function-name function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        new Thread<span class="token variable"><span class="token punctuation">((</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> Go<span class="token punctuation">(</span>&quot;hello&quot;<span class="token punctuation">))</span></span>.Start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    static void Go<span class="token punctuation">(</span>string message<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console.WriteLine<span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>甚至可以将整个逻辑写入到线程lamdba中。</li><li>在c#3.0之前，没有lambda表达式，可以通过使用Thread的Start方法来传递参数。</li><li>使用lambda表达式传递参数，但是当线程开始后，可能会不小心修改捕获的变量。</li></ul><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>internal class ThreadTest
<span class="token punctuation">{</span>
    private static void <span class="token function-name function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i++<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            var temp <span class="token operator">=</span> i<span class="token punctuation">;</span>
            new Thread<span class="token punctuation">((</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
            <span class="token punctuation">{</span>
                Console.Write<span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>.Start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        /*
         i在循环的整个生命周期内指向的是同一个内存地址
        每个线程对Console.WriteLine的调用都会在他运行的时候对它进行修改
        解决方案是每次循环的时候定义一个单独的变量来接收。
         */
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="后台线程" tabindex="-1"><a class="header-anchor" href="#后台线程"><span>后台线程</span></a></h3><p>根据线程运行模式，可以把线程分为前台线程、后台线程和守护（Daemon）线程： 1.前台线程：主程序必须等待线程执行完毕后才可退出程序。C## 中的 Thread 默认为前台线程，也可以设置为后台线程。 2.后台线程：主程序执行完毕立即跟随退出，不管后台线程是否执行完毕，都会被终止。C## 的 ThreadPool 管理的线程默认为后台线程。 3.守护线程：守护线程拥有自动结束自己生命周期的特点，它通常被用来执行一些后台任务。</p><blockquote><p>注意：线程的前台、后台状态与它的优先级无关(所分配的执行时间)</p></blockquote><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">ThreadTest</span>
<span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">//当num大于0时候，被设置为后台线程，直接结束，当是前台线程的时候，会一直在等待输入</span>
        <span class="token class-name"><span class="token keyword">var</span></span> num <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">var</span></span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
        <span class="token punctuation">{</span>
            Thread<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            thread<span class="token punctuation">.</span>IsBackground <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        thread<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;主线程执行完毕&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//num=-1；先输出主线程执行完毕，在输出0123456789</span>
        <span class="token comment">//num=1；直接输出主线程执行完毕，程序退出，因为前台线程都已经执行结束</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果设置为后台线程，那么执行完发现没有前台线程就直接退出了。这种终止的方法，后台线程执行栈中的finally块就不会被执行了，如果想让执行，可以在退出程序的时候使用join来等待线程(前提条件是该线程是自己创建的)。</p><ul><li>应用程序无法退出的一个常见原因是因为还有活跃的前台线程。</li></ul><h3 id="线程优先级" tabindex="-1"><a class="header-anchor" href="#线程优先级"><span>线程优先级</span></a></h3><p>线程的Priority属性可以决定相对于其他活跃的线程当前线程在操作系统中执行时间的长短。 优先级分为：enum ThreadPrioity{ Lowest, BelowNormal , Normal, AboveNormal , Highest} 线程的优先级从高到低：Highest&gt;Normal&gt;Lowest</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">var</span></span> thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
<span class="token punctuation">{</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;thread1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
thread1<span class="token punctuation">.</span>Name <span class="token operator">=</span> <span class="token string">&quot;thread1&quot;</span><span class="token punctuation">;</span>
thread1<span class="token punctuation">.</span>Priority <span class="token operator">=</span> ThreadPriority<span class="token punctuation">.</span>Highest<span class="token punctuation">;</span> <span class="token comment">//设置优先级，只是建议0-31</span>

thread1<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="提升线程优先级" tabindex="-1"><a class="header-anchor" href="#提升线程优先级"><span>提升线程优先级</span></a></h4><ul><li>提供线程优先级需要注意，因为可能会“饿死”其他线程。</li><li>如果想让某线程的优先级比其他进程中线程高，那么就必须提升进程的优先级。 <ul><li>使用System.Diagnostics下的Process类。</li></ul></li><li>适合于一些工作量少，但是要求较低延迟的非UI进程中。</li><li>对于需要大量计算的应用程序(尤其是有UI的应用程序)，提高进程优先级可能使得其他进程饿死，从而降低整个计算机的速度。</li></ul><h3 id="线程的死锁" tabindex="-1"><a class="header-anchor" href="#线程的死锁"><span>线程的死锁</span></a></h3><p>死锁：当两个线程同时需要对方手中的锁时候，各自都在等对方放弃手中的锁，而使得程序无限期的等待下去，称为死锁。</p><div class="language-c# line-numbers-mode" data-ext="c#" data-title="c#"><pre class="language-c#"><code>public static async Task&lt;JObject&gt; GetJsonAsync(Uri uri)
{
  using (var client = new HttpClient())
  {
    var jsonString = await client.GetStringAsync(uri);
    return JObject.Parse(jsonString);
  }
}
// 上层调用方法
public class MyController : ApiController
{
  public string Get()
  {
    var jsonTask = GetJsonAsync(...);
    return jsonTask.Result.ToString();
  }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>控制权返回到上层调用函数时，执行流使用Result/(Wait方法)等待任务结果，Result/Wait()会导致调用线程同步阻塞(等待任务完成)， 而异步任务执行完成后，会尝试利用捕获的同步上下文执行后继代码，这样形成死锁。</p></blockquote><p>解决以上死锁有两种写法：</p><ul><li>不在混用异步、同步写法，始终使用async/await语法糖编写异步代码</li><li>在等待的异步任务时候应该使用VonfigureAwait(false)方法</li></ul><h2 id="实操" tabindex="-1"><a class="header-anchor" href="#实操"><span>实操</span></a></h2><h3 id="线程超时取消" tabindex="-1"><a class="header-anchor" href="#线程超时取消"><span>线程超时取消</span></a></h3><p>实现一个方法执行指定时间如果还没完成就直接取消，异步任务如何取消需要看异步任务的文章</p><h4 id="threadjoin" tabindex="-1"><a class="header-anchor" href="#threadjoin"><span>ThreadJoin</span></a></h4><p>借助Join方法来进行等待指定时间然后终止线程</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">var</span></span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
thread<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>thread<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span>TimeSpan<span class="token punctuation">.</span><span class="token function">FromSeconds</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 终止线程</span>
    thread<span class="token punctuation">.</span><span class="token function">Interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;Done&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">try</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;Foo start ...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Thread<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;Foo end&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ThreadInterruptedException</span> ex<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;Foo interrupted  message:</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">ex<span class="token punctuation">.</span>Message</span><span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用double-check来创建对象" tabindex="-1"><a class="header-anchor" href="#使用double-check来创建对象"><span>使用Double Check来创建对象</span></a></h3><div class="language-c# line-numbers-mode" data-ext="c#" data-title="c#"><pre class="language-c#"><code>internal IDictionary KeyTable
{
    get
    {
        if (this._keyTable == null)
        {
            lock (base._lock)
            {
                if (this._keyTable == null)
                {
                    this._keyTable = new Hashtable();
                }
            }
        }
        return this._keyTable;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建单例对象是很常见的一种编程情况。一般在 lock 语句后就会直接创建对象了，但这不够安全。因为在 lock 锁定对象之前，可能已经有多个线程进入到了第一个 if 语句中。如果不加第二个 if 语句，则单例对象会被重复创建，新的实例替代掉旧的实例。如果单例对象中已有数据不允许被破坏或者别的什么原因，则应考虑使用 Double Check 技术。</p><h3 id="多线程消费队列数据" tabindex="-1"><a class="header-anchor" href="#多线程消费队列数据"><span>多线程消费队列数据</span></a></h3><div class="language-c# line-numbers-mode" data-ext="c#" data-title="c#"><pre class="language-c#"><code>using System.Collections.Concurrent;
using ConsoleApp2;

SubDeTransaction();

void SubDeTransaction()
{
    var list = new List&lt;AssetRepayment&gt;();
    for (int i = 0; i &lt; 1000; i++)
    {
        list.Add(new AssetRepayment() { Title = i + &quot;---&quot; + Guid.NewGuid() });
    }

    if (!list.Any())
    {
        Console.WriteLine(&quot;没有可执行的数据&quot;);
        return;
    }

    ConcurrentQueue&lt;AssetRepayment&gt; queues = new ConcurrentQueue&lt;AssetRepayment&gt;();

    Console.WriteLine(&quot;可执行的数据:&quot; + list.Count + &quot;条&quot;);
    foreach (var item in list)
    {
        queues.Enqueue(item);
    }

    var tasks = new List&lt;Task&gt;();
    // 定义线程数
    for (int i = 0; i &lt; 4; i++)
    {
        var task = Task.Run(() =&gt; { Process(queues); });
        tasks.Add(task);
    }

    var taskList = Task.Factory.ContinueWhenAll(tasks.ToArray(), (ts) =&gt; { });
    taskList.Wait();
}

// 处理
void Process(ConcurrentQueue&lt;AssetRepayment&gt; queues)
{
    while (true)
    {
        var isExit = queues.TryDequeue(out var repayId);
        if (!isExit)
        {
            break;
        }

        try
        {
            Console.WriteLine(repayId.Title);
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex);
        }
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="对比" tabindex="-1"><a class="header-anchor" href="#对比"><span>对比</span></a></h2><h3 id="thread、threadpool-和-task" tabindex="-1"><a class="header-anchor" href="#thread、threadpool-和-task"><span>Thread、ThreadPool 和 Task</span></a></h3><ul><li>Thread</li></ul><p>实际的操作系统级别的线程(os线程),有自己的栈和内核资源，Thread允许最高程度的控制，你可以abort、suspend或resume一个线程，你还可以监听它的状态，设置他的堆栈大小和culture等属性。Thread的开销成本很高，你的每一个线程都会为它的堆栈消耗相对较多的内存，并且在线程之间的处理器上下切换时会在增加额外的cpu开销。</p><ul><li>ThreadPool</li></ul><p>ThreadPool(线程池)是一堆线程的包装器，由CLR维护。你对线程池的线程没有任何的控制权，你甚至都不知道线程池什么时候开始执行你提交的任务，你只能控制线程池的大小。简单来说线程池调用线程的机制是，它首先调用已经创建的空闲线程来执行你的任务，如果当前没有空闲的线程，可能会创建新的线程，也可能会进行等待。 使用ThreadPool可以避免创建创建太多线程的开销。但是如果你向ThreadPool提交了太多长时间运行的任务，它可能会被填满，这个时候你提交的后面的任务可能最终会等待前面的长时间运行的任务执行完成。线程池没有提供任何方法来检测一个工作任务何时完成，也没有方法来获取结果。因此，ThreadPool最好用于调度者不需要结果的短时操作。</p><ul><li>Task</li></ul><p>Task和ThreadPool一样，Task并不会创建自己的OS线程。相反，Task是由TaskScheduler调度器执行的，默认的调度器只是在ThreadPool上运行。与ThreadPool不同的是，Task还允许你知道他完成的时间，并获取返回一个结果，你可以在现有的Task上调用ContinueWith(),使他在任务完成后运行更多的代码(如果它已经完成，就会立即运行回调)，你也可以通过调用 Wait() 来同步等待一个任务的完成（或者，通过获取它的 Result 属性）。与 Thread.Join() 一样，这将阻塞调用线程，直到任务完成。通常不建议同步等待任务执行完成，它使调用线程无法进行任何其他工作。如果当前线程要等待其它线程任务执行完成，建议使用 async/await 异步等待，这样当前线程可以空闲出来去处理其它任务，比如在 await Task.Delay() 时，并不占用线程资源。由于任务仍然在 ThreadPool 上运行，因此不应该将其用于长时任务的执行，因为它们会填满线程池并阻塞新的工作任务。相反，Task 提供了一个 LongRunning 选项，它将告诉 TaskScheduler 启用一个新的线程，而不是在 ThreadPool 上运行(Task.Factory.StartNew(要执行的方法名称, 方法参数, TaskCreationOptions.LongRunning))。 Task.Factory.StartNew 可以使用比Task更多的参数，可以认为Task.Run是简化了Task.Factory.StartNew 的使用，除了需要指定一个线程是长时间占用的(线程池就不会鞥带这个线程的回收)，否则就使用 Task.Run</p><ul><li>总结</li></ul><p><strong>大多数情况我们应该使用 Task，而不要直接使用 Thread，除非你明确知道你需要一个独立的线程来执行一个长耗时的任务。</strong><strong>关于Thread和Task的区别：Thread更底层，Task更抽象。</strong> 看后感： <strong>Thread创建的线程是前台线程，线程池中的是后台线程。</strong></p><h2 id="资料" tabindex="-1"><a class="header-anchor" href="#资料"><span>资料</span></a></h2>`,100),f={href:"https://www.cnblogs.com/edisonchou/p/4848131.html",target:"_blank",rel:"noopener noreferrer"},w={href:"https://www.cnblogs.com/kissdodog/category/464176.html",target:"_blank",rel:"noopener noreferrer"},y={href:"https://threads.whuanle.cn/",target:"_blank",rel:"noopener noreferrer"},x={href:"https://www.cnblogs.com/kissdodog/category/464176.html",target:"_blank",rel:"noopener noreferrer"},q={href:"https://blog.gkarch.com/topic/threading.html",target:"_blank",rel:"noopener noreferrer"},C={href:"https://mp.weixin.qq.com/s/f7tVZi7QTBd5fmLsWVuj_g",target:"_blank",rel:"noopener noreferrer"},S={href:"https://threads.whuanle.cn",target:"_blank",rel:"noopener noreferrer"},W={href:"https://www.cnblogs.com/baibaomen-org/p/17695662.html",target:"_blank",rel:"noopener noreferrer"},P=s("p",null,"https://www.cnblogs.com/wyt007/p/9486752.html | c#多线程总结（纯干货） - 一个大西瓜咚咚咚 - 博客园",-1);function L(_,A){const a=i("ExternalLinkIcon");return l(),o("div",null,[r,s("blockquote",null,[s("p",null,[n("资料来源："),s("a",d,[n("https://www.cnblogs.com/pandefu/p/17536277.html"),e(a)])])]),k,s("p",null,[s("a",v,[n("https://mp.weixin.qq.com/s/vJ7T-GgThzUEBAnIDesCfQ"),e(a)]),n(" | 【.NET】几行代码识别.NET程序进程(包括"),m,n("和"),b,n(")")]),h,s("p",null,[n("资料："),s("a",g,[n("https://threads.whuanle.cn/1.thread_basic/1.thread"),e(a)])]),T,s("p",null,[n("线程池相关信息： "),s("a",f,[n("https://www.cnblogs.com/edisonchou/p/4848131.html"),e(a)]),n(" 多线程文档："),s("a",w,[n("https://www.cnblogs.com/kissdodog/category/464176.html"),e(a)]),n(" 多线程、锁、同步异步、线程池、任务、async/await、并行、并发等知识点："),s("a",y,[n("https://threads.whuanle.cn/"),e(a)])]),s("p",null,[n("多线程文章："),s("a",x,[n("https://www.cnblogs.com/kissdodog/category/464176.html"),e(a)]),n(" c#中的多线程："),s("a",q,[n("https://blog.gkarch.com/topic/threading.html"),e(a)]),s("a",C,[n("https://mp.weixin.qq.com/s/f7tVZi7QTBd5fmLsWVuj_g"),e(a)]),n(" | C#中10种多进程之间的通讯方式 C## 多线程入门："),s("a",S,[n("https://threads.whuanle.cn"),e(a)]),s("a",W,[n("https://www.cnblogs.com/baibaomen-org/p/17695662.html"),e(a)]),n(" | .NET中测量多线程基准性能 - 百宝门园地 - 博客园")]),P])}const D=p(u,[["render",L],["__file","index.html.vue"]]),J=JSON.parse('{"path":"/dotnet/csharp/threadConcurrencyAndAsync/","title":"说明","lang":"zh-CN","frontmatter":{"title":"说明","lang":"zh-CN","date":"2023-10-22T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["csharp"],"tag":["thread"],"description":"什么是线程 线程（Thread）是操作系统能够进行运算调度的最小单位，也是程序中能够并发执行的一段序列。它是进程中的实际运作单位，一个进程中可以包含多个线程，每条线程并行执行不同的任务，这些线程共享进程的资源。严格意义上来说，同一时间可以并行运行的线程数取决于 CPU 的核数。 单线程应用：在进程的独立环境里面只能跑一个新线程，所以该线程拥有独占权。 ...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dotnet/csharp/threadConcurrencyAndAsync/"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"说明"}],["meta",{"property":"og:description","content":"什么是线程 线程（Thread）是操作系统能够进行运算调度的最小单位，也是程序中能够并发执行的一段序列。它是进程中的实际运作单位，一个进程中可以包含多个线程，每条线程并行执行不同的任务，这些线程共享进程的资源。严格意义上来说，同一时间可以并行运行的线程数取决于 CPU 的核数。 单线程应用：在进程的独立环境里面只能跑一个新线程，所以该线程拥有独占权。 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://azrng.gitee.io/kbms/kbms/common/1639900402748-a0260873-3100-4c5e-977a-a343ffaa4665.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-29T14:13:05.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"thread"}],["meta",{"property":"article:published_time","content":"2023-10-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-29T14:13:05.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"说明\\",\\"image\\":[\\"https://azrng.gitee.io/kbms/kbms/common/1639900402748-a0260873-3100-4c5e-977a-a343ffaa4665.png\\"],\\"datePublished\\":\\"2023-10-22T00:00:00.000Z\\",\\"dateModified\\":\\"2024-03-29T14:13:05.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"什么是线程","slug":"什么是线程","link":"#什么是线程","children":[]},{"level":2,"title":"什么是多线程","slug":"什么是多线程","link":"#什么是多线程","children":[{"level":3,"title":"为什么需要多线程？","slug":"为什么需要多线程","link":"#为什么需要多线程","children":[]},{"level":3,"title":"优点","slug":"优点","link":"#优点","children":[]},{"level":3,"title":"缺点","slug":"缺点","link":"#缺点","children":[]}]},{"level":2,"title":"术语","slug":"术语","link":"#术语","children":[{"level":3,"title":"线程被抢占","slug":"线程被抢占","link":"#线程被抢占","children":[]},{"level":3,"title":"线程开销","slug":"线程开销","link":"#线程开销","children":[{"level":4,"title":"空间开销","slug":"空间开销","link":"#空间开销","children":[]},{"level":4,"title":"时间开销","slug":"时间开销","link":"#时间开销","children":[]}]}]},{"level":2,"title":"线程属性","slug":"线程属性","link":"#线程属性","children":[]},{"level":2,"title":"注意事项","slug":"注意事项","link":"#注意事项","children":[{"level":3,"title":"Thread限制","slug":"thread限制","link":"#thread限制","children":[]},{"level":3,"title":"异常处理","slug":"异常处理","link":"#异常处理","children":[]}]},{"level":2,"title":"进程操作","slug":"进程操作","link":"#进程操作","children":[{"level":3,"title":"获取进程","slug":"获取进程","link":"#获取进程","children":[]},{"level":3,"title":"开启一个进程","slug":"开启一个进程","link":"#开启一个进程","children":[]}]},{"level":2,"title":"线程操作","slug":"线程操作","link":"#线程操作","children":[{"level":3,"title":"获取线程","slug":"获取线程","link":"#获取线程","children":[]},{"level":3,"title":"创建新线程","slug":"创建新线程","link":"#创建新线程","children":[{"level":4,"title":"Thread","slug":"thread","link":"#thread","children":[]},{"level":4,"title":"Timer","slug":"timer","link":"#timer","children":[]},{"level":4,"title":"PeriodicTimer","slug":"periodictimer","link":"#periodictimer","children":[]}]},{"level":3,"title":"线程的状态","slug":"线程的状态","link":"#线程的状态","children":[]},{"level":3,"title":"控制线程数量","slug":"控制线程数量","link":"#控制线程数量","children":[]},{"level":3,"title":"I/O密集和计算密集","slug":"i-o密集和计算密集","link":"#i-o密集和计算密集","children":[]},{"level":3,"title":"上下文切换","slug":"上下文切换","link":"#上下文切换","children":[]},{"level":3,"title":"阻塞线程","slug":"阻塞线程","link":"#阻塞线程","children":[{"level":4,"title":"Sleep","slug":"sleep","link":"#sleep","children":[]},{"level":4,"title":"Join","slug":"join","link":"#join","children":[{"level":5,"title":"添加超时","slug":"添加超时","link":"#添加超时","children":[]}]},{"level":4,"title":"Wait方法","slug":"wait方法","link":"#wait方法","children":[]},{"level":4,"title":"解除阻塞","slug":"解除阻塞","link":"#解除阻塞","children":[]}]},{"level":3,"title":"阻塞与自旋","slug":"阻塞与自旋","link":"#阻塞与自旋","children":[]},{"level":3,"title":"线程等待","slug":"线程等待","link":"#线程等待","children":[]},{"level":3,"title":"终止线程","slug":"终止线程","link":"#终止线程","children":[]},{"level":3,"title":"线程不确定性","slug":"线程不确定性","link":"#线程不确定性","children":[]},{"level":3,"title":"跨线程数据共享","slug":"跨线程数据共享","link":"#跨线程数据共享","children":[{"level":4,"title":"跨线程使用","slug":"跨线程使用","link":"#跨线程使用","children":[]},{"level":4,"title":"线程共享","slug":"线程共享","link":"#线程共享","children":[{"level":5,"title":"Local本地独立","slug":"local本地独立","link":"#local本地独立","children":[]},{"level":5,"title":"Shared共享","slug":"shared共享","link":"#shared共享","children":[]}]},{"level":4,"title":"安全(锁)","slug":"安全-锁","link":"#安全-锁","children":[{"level":5,"title":"往线程传递数据","slug":"往线程传递数据","link":"#往线程传递数据","children":[]}]}]},{"level":3,"title":"后台线程","slug":"后台线程","link":"#后台线程","children":[]},{"level":3,"title":"线程优先级","slug":"线程优先级","link":"#线程优先级","children":[{"level":4,"title":"提升线程优先级","slug":"提升线程优先级","link":"#提升线程优先级","children":[]}]},{"level":3,"title":"线程的死锁","slug":"线程的死锁","link":"#线程的死锁","children":[]}]},{"level":2,"title":"实操","slug":"实操","link":"#实操","children":[{"level":3,"title":"线程超时取消","slug":"线程超时取消","link":"#线程超时取消","children":[{"level":4,"title":"ThreadJoin","slug":"threadjoin","link":"#threadjoin","children":[]}]},{"level":3,"title":"使用Double Check来创建对象","slug":"使用double-check来创建对象","link":"#使用double-check来创建对象","children":[]},{"level":3,"title":"多线程消费队列数据","slug":"多线程消费队列数据","link":"#多线程消费队列数据","children":[]}]},{"level":2,"title":"对比","slug":"对比","link":"#对比","children":[{"level":3,"title":"Thread、ThreadPool 和 Task","slug":"thread、threadpool-和-task","link":"#thread、threadpool-和-task","children":[]}]},{"level":2,"title":"资料","slug":"资料","link":"#资料","children":[]}],"git":{"createdTime":1700232644000,"updatedTime":1711721585000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":3}]},"readingTime":{"minutes":29.85,"words":8956},"filePathRelative":"dotnet/csharp/threadConcurrencyAndAsync/readme.md","localizedDate":"2023年10月22日","excerpt":"<h2>什么是线程</h2>\\n<p>线程（Thread）是操作系统能够进行运算调度的最小单位，也是程序中能够并发执行的一段序列。它是进程中的实际运作单位，一个进程中可以包含多个线程，每条线程并行执行不同的任务，这些线程共享进程的资源。严格意义上来说，同一时间可以并行运行的线程数取决于 CPU 的核数。</p>\\n<p>单线程应用：在进程的独立环境里面只能跑一个新线程，所以该线程拥有独占权。</p>\\n<h2>什么是多线程</h2>\\n<p>多线程编程是指使用多个线程同时执行任务。这些线程可能是由操作系统调度的，也可以由开发人员手动创建和管理。在多线程编程中，我们通常需要考虑许多问题，如线程同步、死锁、竞态条件等等</p>","autoDesc":true}');export{D as comp,J as data};
