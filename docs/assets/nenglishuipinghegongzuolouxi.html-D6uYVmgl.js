import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,o as a,d as n}from"./app-CHE8a282.js";const l={},i=n('<blockquote><p>摘录网站：<a href="https://www.cnblogs.com/liangchen001/p/14729537.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/liangchen001/p/14729537.html</a></p></blockquote><h2 id="_4个能力水平" tabindex="-1"><a class="header-anchor" href="#_4个能力水平"><span>4个能力水平</span></a></h2><h3 id="_1-线性级" tabindex="-1"><a class="header-anchor" href="#_1-线性级"><span>1. 线性级</span></a></h3><p>线性级程序员的思维很简单，写程序的时候就像盖房子似的，一块砖一块砖往上垒的，但是他不知道后面会垒成什么样，可能越垒越庞大，后面的代码组织、管理等会越来越混乱，最后导致后面的很多程序修改和维护很麻烦。</p><h3 id="_2-逻辑级" tabindex="-1"><a class="header-anchor" href="#_2-逻辑级"><span>2. 逻辑级</span></a></h3><p>对于逻辑级程序员，已经掌握了一些算法理论基础，并且对于业务世界的逻辑有一个清楚的把握，能能够撰写出一些很好的模块和和函数，而且逻辑比较严密，bug比较少的这样的一个状态。</p><h3 id="_3-架构级" tabindex="-1"><a class="header-anchor" href="#_3-架构级"><span>3. 架构级</span></a></h3><p>对于架构级程序员，因为除了对程序语言本身的了解和把握以外，还要对现实世界的所要解决的业务逻辑有一个清楚的把握和了解。 这样的话才能够对软件进行架构和分层，然后指导团队的其他成员来按照统一的目标来不断的实现。</p><h3 id="_4-工程级" tabindex="-1"><a class="header-anchor" href="#_4-工程级"><span>4. 工程级</span></a></h3><p>对于工程级程序员，因为本身软件开发不仅仅是开发本身，这里面还有很多其他的项目管理的要素在里面。 比如说刚才提到的计划、组织、管理和控制，如果有了一些项目管理的指导和原则的话，那么对于一个软件工程的过程管理就会有一个&quot;一览众山小&quot;的状态。</p><h2 id="_8个陋习" tabindex="-1"><a class="header-anchor" href="#_8个陋习"><span>8个陋习</span></a></h2><p>根据以前的工作经验呢，我觉得程序员身上的这些陋习是阻碍程序员进步的最大的一个障碍。</p><h3 id="_1-自我" tabindex="-1"><a class="header-anchor" href="#_1-自我"><span>1. 自我</span></a></h3><p>那么首先程序员因为本身是一个脑力活动者，他那个是一个很重要的特性，就是非常自我。 很多时候就是说撰写代码的时候，基本上是不愿意去听从别人的意见和建议的。</p><h3 id="_2-封闭" tabindex="-1"><a class="header-anchor" href="#_2-封闭"><span>2. 封闭</span></a></h3><p>有的程序员很封闭，也就说它不够开放。 如果是用一种开放和交流的心态来跟其他程序上来进行交互的话，那么这样的相互取得的促进效果会是非常明显的。</p><h3 id="_3-惯性" tabindex="-1"><a class="header-anchor" href="#_3-惯性"><span>3. 惯性</span></a></h3><p>有一些有经验的程序员会有一些工作的惯性，经常会说&quot;我以前是怎么这么做的&quot;、“我以前是这样这样做的，我就觉得你现在这样做的不对”… 其实这种惯性，也是阻碍沟通的一种很大的问题。</p><h3 id="_4-沟通障碍" tabindex="-1"><a class="header-anchor" href="#_4-沟通障碍"><span>4. 沟通障碍</span></a></h3><p>这是比较显著的一类陋习，因为程序员整天面对电脑、只跟机器交互，所以说去跟其他产品经理和其他测试等等一些这些人去交流的时候，会有很明显的沟通障碍。</p><h3 id="_5-一叶障目" tabindex="-1"><a class="header-anchor" href="#_5-一叶障目"><span>5. 一叶障目</span></a></h3><p>这是最大的问题，就是说程序员经常一叶障目，只看到自己眼前的工作。 比如说有一些团队协作开发的任务的时候呢，只依据自己为中心。那么对于别人的一些请求，尤其有一些交互性的复杂的网络接口的开发的时候经常会下意识地去拒绝别人。</p><h3 id="_6-工作量估计乐观" tabindex="-1"><a class="header-anchor" href="#_6-工作量估计乐观"><span>6. 工作量估计乐观</span></a></h3><p>还有一个最重要的问题，就是说经常会把工作量估计漏完。 比如说拿到一个需求的时候，好，我一个星期就能完成结果，真正的实现的时候呢，发现需要花两到三周乃至更长的时间来实现这项工作任务。</p><h3 id="_7-拒绝变化" tabindex="-1"><a class="header-anchor" href="#_7-拒绝变化"><span>7. 拒绝变化</span></a></h3><p>对于需求的变更来讲的话，程序员的很大心态是有逆反心理的。 当我正在撰写一个东西的时候，发现需求变更了，就会产生一种阻碍心态来拒绝变化。 但是拒绝变化的前提应该先进行客观、合理的分析和判断，最后再给出答案。其实它应该是要仔细衡量本身这个变化影响不影响我目前的软件体系和架构？对我的工作量的增加有多大？这需要有一个好的估量来决定这个变化的取舍。</p><h3 id="_8-拒绝重构" tabindex="-1"><a class="header-anchor" href="#_8-拒绝重构"><span>8. 拒绝重构</span></a></h3><p>最后且最重要的一个问题，就是说很多时候我们是拒绝重构的，因为这个重构有些时候是很难取舍的一个问题。 比如说经常会想，哎呀我原来写的这个软件体系结构，跟后面的整个实现过程中，变化会越来越大，而且信息学、新需求进来的时候呢，我就很难再保持一个良好的这样的一个体系结构。那么经常会纠结，我是重构呢还是按照这个原来的路敲敲打打呢？ 是否重构其实是需要根据我实际性的。比如尤其我前几个月写的一个安卓游戏，我也是经常处于这种心态，我也在纠结到底重不重构的？后来一咬牙一闭眼还是重构了。 重构的话，前期可能会花费点时间，但是能够在后期保证我这个软件的目标实现，且拥有一个清晰、完整的架构和体系结构，并且后期会达到一个易于维护的这样的一个状态。</p>',28),h=[i];function r(o,s){return a(),t("div",null,h)}const d=e(l,[["render",r],["__file","nenglishuipinghegongzuolouxi.html.vue"]]),g=JSON.parse('{"path":"/classicArticle/nenglishuipinghegongzuolouxi.html","title":"能力水平和工作陋习","lang":"zh-CN","frontmatter":{"title":"能力水平和工作陋习","lang":"zh-CN","date":"2023-07-26T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":false,"category":["article"],"tag":["无"],"filename":"nenglishuipinghegongzuolouxi","slug":"vodphg","docsId":"44767189","description":"摘录网站：https://www.cnblogs.com/liangchen001/p/14729537.html 4个能力水平 1. 线性级 线性级程序员的思维很简单，写程序的时候就像盖房子似的，一块砖一块砖往上垒的，但是他不知道后面会垒成什么样，可能越垒越庞大，后面的代码组织、管理等会越来越混乱，最后导致后面的很多程序修改和维护很麻烦。 2. 逻辑...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/classicArticle/nenglishuipinghegongzuolouxi.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"能力水平和工作陋习"}],["meta",{"property":"og:description","content":"摘录网站：https://www.cnblogs.com/liangchen001/p/14729537.html 4个能力水平 1. 线性级 线性级程序员的思维很简单，写程序的时候就像盖房子似的，一块砖一块砖往上垒的，但是他不知道后面会垒成什么样，可能越垒越庞大，后面的代码组织、管理等会越来越混乱，最后导致后面的很多程序修改和维护很麻烦。 2. 逻辑..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-07-26T14:03:17.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-07-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-07-26T14:03:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"能力水平和工作陋习\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-07-26T00:00:00.000Z\\",\\"dateModified\\":\\"2023-07-26T14:03:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"4个能力水平","slug":"_4个能力水平","link":"#_4个能力水平","children":[{"level":3,"title":"1. 线性级","slug":"_1-线性级","link":"#_1-线性级","children":[]},{"level":3,"title":"2. 逻辑级","slug":"_2-逻辑级","link":"#_2-逻辑级","children":[]},{"level":3,"title":"3. 架构级","slug":"_3-架构级","link":"#_3-架构级","children":[]},{"level":3,"title":"4. 工程级","slug":"_4-工程级","link":"#_4-工程级","children":[]}]},{"level":2,"title":"8个陋习","slug":"_8个陋习","link":"#_8个陋习","children":[{"level":3,"title":"1. 自我","slug":"_1-自我","link":"#_1-自我","children":[]},{"level":3,"title":"2. 封闭","slug":"_2-封闭","link":"#_2-封闭","children":[]},{"level":3,"title":"3. 惯性","slug":"_3-惯性","link":"#_3-惯性","children":[]},{"level":3,"title":"4. 沟通障碍","slug":"_4-沟通障碍","link":"#_4-沟通障碍","children":[]},{"level":3,"title":"5. 一叶障目","slug":"_5-一叶障目","link":"#_5-一叶障目","children":[]},{"level":3,"title":"6. 工作量估计乐观","slug":"_6-工作量估计乐观","link":"#_6-工作量估计乐观","children":[]},{"level":3,"title":"7. 拒绝变化","slug":"_7-拒绝变化","link":"#_7-拒绝变化","children":[]},{"level":3,"title":"8. 拒绝重构","slug":"_8-拒绝重构","link":"#_8-拒绝重构","children":[]}]}],"git":{"createdTime":1690380197000,"updatedTime":1690380197000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":1}]},"readingTime":{"minutes":4.74,"words":1421},"filePathRelative":"classicArticle/nenglishuipinghegongzuolouxi.md","localizedDate":"2023年7月26日","excerpt":"<blockquote>\\n<p>摘录网站：<a href=\\"https://www.cnblogs.com/liangchen001/p/14729537.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://www.cnblogs.com/liangchen001/p/14729537.html</a></p>\\n</blockquote>\\n<h2>4个能力水平</h2>\\n<h3>1. 线性级</h3>\\n<p>线性级程序员的思维很简单，写程序的时候就像盖房子似的，一块砖一块砖往上垒的，但是他不知道后面会垒成什么样，可能越垒越庞大，后面的代码组织、管理等会越来越混乱，最后导致后面的很多程序修改和维护很麻烦。</p>","autoDesc":true}');export{d as comp,g as data};
