import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,d as n,o as a}from"./app-fQkBsvt-.js";const o={};function b(c,e){return a(),t("div",null,e[0]||(e[0]=[n('<p>http头域列表与解释之request篇<br> HTTP 头域是HTTP协议中请求(request)和响应(response)中的头部信息,其实就是HTTP通信的操作参数，告诉web服务器和浏览器怎样处理这个通信。HTTP头从一个请求信息或者响应信息的第二行开始（第一行是请求行或者响应行），以两个CR-LF字符组结束（CR：回车符,\\r，LF：换行符\\n）而每个HTTP头是字符串形式的，用冒号分割的键值对，多个HTTP头之间用CR-LF字符组隔开。<br> 某些http头可以有注释，例如user-agent,server,via。但这些注释会被服务器或者浏览器忽略IETF组织已经将一些核心的HTTP头定义在RFC2616规范中，这些HTTP头是每个基于HTTP协议的软件必须实现的，而其他一些更新和扩展的头域也必须被基于HTTP的软件实现。当然，各个软件也可以定义自己的头域。<br> 另一方面，RFC2616规范中并没有限制每个HTTP头的长度，或者限制HTTP头的数量，但出于性能和安全的考虑，多数服务器都会自己作规定，例如apache2.3 就规定每个HTTP头不能超过8190个字节，每个请求不能超过100个HTTP头。<br> 以下来看看发送一个请求(request)时候，可能包含的各个HTTP头和它的解释。<br> 1.标准请求头<br> Accept : 浏览器（或者其他基于HTTP的客户端程序）可以接收的内容类型（Content-types）,例如 Accept: text/plain<br>  <br> Accept-Charset：浏览器能识别的字符集，例如 Accept-Charset: utf-8<br>  <br> Accept-Encoding：浏览器可以处理的编码方式，注意这里的编码方式有别于字符集，这里的编码方式通常指gzip,deflate等。例如 Accept-Encoding: gzip, deflate<br>  <br> Accept-Language：浏览器接收的语言，其实也就是用户在什么语言地区，例如简体中文的就是 Accept-Language: zh-CN<br>  <br> Accept-Datetime：（这个暂时没搞清楚什么意思）<br>  <br> Authorization：在HTTP中，服务器可以对一些资源进行认证保护，如果你要访问这些资源，就要提供用户名和密码，这个用户名和密码就是在Authorization头中附带的，格式是“username:password”字符串的base64编码，例如：Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ<mark>中，basic指使用basic认证方式，　QWxhZGRpbjpvcGVuIHNlc2FtZQ</mark>使用base64解码就是Aladdin:open sesame<br>  <br> Cache-Control：这个指令在request和response中都有，用来指示缓存系统（服务器上的，或者浏览器上的）应该怎样处理缓存，因为这个头域比较重要，特别是希望使用缓　存改善性能的时候，内容也较多，所以我想在下一篇博文中主要介绍一下。<br>  <br> Connection：告诉服务器这个user agent（通常就是浏览器）想要使用怎样的连接方式。值有keep-alive和close。http1.1默认是keep-alive。keep-alive就是浏览器和服务器　的通信连接会被持续保存，不会马上关闭，而close就会在response后马上关闭。但这里要注意一点，我们说HTTP是无状态的，跟这个是否keep-alive没有关系，不要认为keep-alive是对HTTP无状态的特性的改进。<br>  <br> Cookie：浏览器向服务器发送请求时发送cookie，或者服务器向浏览器附加cookie，就是将cookie附近在这里的。例如：Cookie:user=admin<br>  <br> Content-Length：一个请求的请求体的内存长度，单位为字节(byte)。请求体是指在HTTP头结束后，两个CR-LF字符组之后的内容，常见的有POST提交的表单数据，这个Content-Length并不包含请求行和HTTP头的数据长度。<br>  <br> Content-MD5：使用base64进行了编码的请求体的MD5校验和。例如：Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==<br>  <br> Content-Type：请求体中的内容的mime类型。通常只会用在POST和PUT方法的请求中。例如：Content-Type: application/x-www-form-urlencoded<br>  <br> Date：发送请求时的GMT时间。例如：Date: Tue, 15 Nov 1994 08:12:31 GMT<br>  <br> Expect：指示需要使用服务器某些特殊的功能。（这个我不是很清楚）<br>  <br> From：发送这个请求的用户的email地址。例如：From: <a href="mailto:user@example.com" target="_blank" rel="noopener noreferrer">user@example.com</a><br>  <br> Host：被服务器的域名或IP地址，如果不是通用端口，还包含该端口号，例如：Host: <a href="http://www.some.com:182" target="_blank" rel="noopener noreferrer">www.some.com:182</a><br>  <br> If-Match :通常用在使用PUT方法对服务器资源进行更新的请求中，意思就是，询问服务器，现在正在请求的资源的tag和这个If-Match的tag相不相同，如果相同，则证明服务器上的这个资源还是旧的，现在可以被更新，如果不相同，则证明该资源被更新过，现在就不用再更新了（否则有可能覆盖掉其他人所做的更改）。<br>  <br> If-Modified-Since：询问服务器现在正在请求的资源在某个时间以来有没有被修改过，如果没有，服务器则返回304状态来告诉浏览器使用浏览器自己本地的缓存，如果有修改过，则返回200，并发送新的资源（当然如果资源不存在，则返回404。）<br>  <br> If-None-Match：和If-Modified-Since用意差不多，不过不是根据时间来确定，而是根据一个叫ETag的东西来确定。关于etag我想在下一篇博客介绍一下。<br>  <br> If-Range：告诉服务器如果这个资源没有更改过(根据If-Range后面给出的Etag判断)，就发送这个资源中在浏览器缺少了的某些部分给浏览器，如果该资源以及被修改过，则将整个资源重新发送一份给浏览器。<br>  <br> If-Unmodified-Since：询问服务器现在正在请求的资源在某个时刻以来是否没有被修改过。<br>  <br> Max-Forwards：限制请求信息在代理服务器或网关中向前传递的次数。<br>  <br> Pragma：好像只有一个值，就是:no-cache。Pragma:no-cache 与cache-control:no-cache相同，只不过cache-control:no-cache是http1.1专门指定的，而Pragma:no-cache可以在http1.0和1.1中使用<br>  <br> Proxy-Authorization：连接到某个代理时使用的身份认证信息，跟Authorization头差不多。例如：Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==<br>  <br> Range：在HTTP头中，”Range”字眼都表示“资源的byte形式数据的顺序排列，并且取其某一段数据”的意思。Range头就是表示请求资源的从某个数值到某个数值间的数据，例如：Range: bytes=500-999 就是表示请求资源从500到999byte的数据。数据的分段下载和多线程下载就是利用这个实现的。<br>  <br> Referer：指当前请求的URL是在什么地址引用的。<a href="http://xn--www-uc0e316agqd.a.com/index.html%E9%A1%B5%E9%9D%A2%E4%B8%AD%E7%82%B9%E5%87%BB%E4%B8%80%E4%B8%AA%E6%8C%87%E5%90%91www.b.com%E7%9A%84%E8%B6%85%E9%93%BE%E6%8E%A5%EF%BC%8C%E9%82%A3%E4%B9%88%EF%BC%8C%E8%BF%99%E4%B8%AAwww.b.com%E7%9A%84%E8%AF%B7%E6%B1%82%E4%B8%AD%E7%9A%84Referer%E5%B0%B1%E6%98%AFwww.a.com/index.html%E3%80%82%E9%80%9A%E5%B8%B8%E6%88%91%E4%BB%AC%E8%A7%81%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87%E9%98%B2%E7%9B%97%E9%93%BE%E5%B0%B1%E6%98%AF%E7%94%A8%E8%BF%99%E4%B8%AA%E5%AE%9E%E7%8E%B0%E7%9A%84%E3%80%82" target="_blank" rel="noopener noreferrer">例如在www.a.com/index.html页面中点击一个指向www.b.com的超链接，那么，这个www.b.com的请求中的Referer就是www.a.com/index.html。通常我们见到的图片防盗链就是用这个实现的。</a><br>  <br> Upgrade：请求服务器更新至另外一个协议，例如：Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11<br>  <br> User-Agent：通常就是用户的浏览器相关信息。例如：User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/12.0<br>  <br> Via：用来记录一个请求经过了哪些代理或网关才被送到目标服务器上。例如一个请求从浏览器出发(假设使用http/1.0)，发送给名为 SomeProxy的内部代理，然后被转发至www.somenet.com的公共代理（使用http/1.1），<a href="http://xn--www-4w2e97cpkq4l415boda96i829dgw1a2isvtv.someweb.com" target="_blank" rel="noopener noreferrer">最后被转发至目标服务器www.someweb.com</a>，那么在someweb.com中收到的via 头应该是：via:1.0 someProxy 1.1 [<a href="http://www.someweb.com" target="_blank" rel="noopener noreferrer">www.someweb.com</a>(apache](<a href="http://www.someweb.com" target="_blank" rel="noopener noreferrer">http://www.someweb.com</a>(apache) 1.1)<br>  <br> Warning：记录一些警告信息。<br> 2.通用但是并非标准的http头<br> X-Requested-With：主要是用来识别ajax请求，很多javascript框架会发送这个头域（值为XMLHttpRequest）<br>  <br> DNT : DO NOT TRACK的缩写，要求服务器程序不要跟踪记录用户信息。DNT: 1 (开启DNT) DNT: 0 (关闭DNT)火狐，safari,IE9都支持这个头域，并且于2011年3月7日被提交至IETF组织实现标准化<br>  <br> X-Forwarded-For : 记录一个请求从客户端出发到目标服务器过程中经历的代理，或者负载平衡设备的IP。<br>  <br> X-Forwarded-Proto：记录一个请求一个请求最初从浏览器发出时候，是使用什么协议。因为有可能当一个请求最初和反向代理通信时，是使用https，但反向代理和服务器通信时改变成http协议，这个时候，X-Forwarded-Proto的值应该是https<br>  <br> Front-End-Https：微软使用与其负载平衡的一个头域。</p>',1)]))}const s=r(o,[["render",b],["__file","liulanqiqingqiutou.html.vue"]]),T=JSON.parse('{"path":"/web/webkaifa/changedaimajiexi/liulanqiqingqiutou.html","title":"浏览器请求头","lang":"zh-CN","frontmatter":{"title":"浏览器请求头","lang":"zh-CN","date":"2023-08-19T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["web"],"tag":["无"],"filename":"liulanqiqingqiutou","slug":"zhmdtf","docsId":"29633634","description":"http头域列表与解释之request篇 HTTP 头域是HTTP协议中请求(request)和响应(response)中的头部信息,其实就是HTTP通信的操作参数，告诉web服务器和浏览器怎样处理这个通信。HTTP头从一个请求信息或者响应信息的第二行开始（第一行是请求行或者响应行），以两个CR-LF字符组结束（CR：回车符,\\\\r，LF：换行符\\\\n）而...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/web/webkaifa/changedaimajiexi/liulanqiqingqiutou.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"浏览器请求头"}],["meta",{"property":"og:description","content":"http头域列表与解释之request篇 HTTP 头域是HTTP协议中请求(request)和响应(response)中的头部信息,其实就是HTTP通信的操作参数，告诉web服务器和浏览器怎样处理这个通信。HTTP头从一个请求信息或者响应信息的第二行开始（第一行是请求行或者响应行），以两个CR-LF字符组结束（CR：回车符,\\\\r，LF：换行符\\\\n）而..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-08-19T10:58:50.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-08-19T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-08-19T10:58:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"浏览器请求头\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-08-19T00:00:00.000Z\\",\\"dateModified\\":\\"2023-08-19T10:58:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[],"git":{"createdTime":1692442730000,"updatedTime":1692442730000,"contributors":[{"name":"zhangyunpeng","username":"zhangyunpeng","email":"zhang.yunpeng@synyi.com","commits":1}]},"readingTime":{"minutes":7.38,"words":2213},"filePathRelative":"web/webkaifa/changedaimajiexi/liulanqiqingqiutou.md","localizedDate":"2023年8月19日","excerpt":"<p>http头域列表与解释之request篇<br>\\nHTTP 头域是HTTP协议中请求(request)和响应(response)中的头部信息,其实就是HTTP通信的操作参数，告诉web服务器和浏览器怎样处理这个通信。HTTP头从一个请求信息或者响应信息的第二行开始（第一行是请求行或者响应行），以两个CR-LF字符组结束（CR：回车符,\\\\r，LF：换行符\\\\n）而每个HTTP头是字符串形式的，用冒号分割的键值对，多个HTTP头之间用CR-LF字符组隔开。<br>\\n某些http头可以有注释，例如user-agent,server,via。但这些注释会被服务器或者浏览器忽略IETF组织已经将一些核心的HTTP头定义在RFC2616规范中，这些HTTP头是每个基于HTTP协议的软件必须实现的，而其他一些更新和扩展的头域也必须被基于HTTP的软件实现。当然，各个软件也可以定义自己的头域。<br>\\n另一方面，RFC2616规范中并没有限制每个HTTP头的长度，或者限制HTTP头的数量，但出于性能和安全的考虑，多数服务器都会自己作规定，例如apache2.3 就规定每个HTTP头不能超过8190个字节，每个请求不能超过100个HTTP头。<br>\\n以下来看看发送一个请求(request)时候，可能包含的各个HTTP头和它的解释。<br>\\n1.标准请求头<br>\\nAccept : 浏览器（或者其他基于HTTP的客户端程序）可以接收的内容类型（Content-types）,例如 Accept: text/plain<br>\\n&nbsp;<br>\\nAccept-Charset：浏览器能识别的字符集，例如 Accept-Charset: utf-8<br>\\n&nbsp;<br>\\nAccept-Encoding：浏览器可以处理的编码方式，注意这里的编码方式有别于字符集，这里的编码方式通常指gzip,deflate等。例如 Accept-Encoding: gzip, deflate<br>\\n&nbsp;<br>\\nAccept-Language：浏览器接收的语言，其实也就是用户在什么语言地区，例如简体中文的就是 Accept-Language: zh-CN<br>\\n&nbsp;<br>\\nAccept-Datetime：（这个暂时没搞清楚什么意思）<br>\\n&nbsp;<br>\\nAuthorization：在HTTP中，服务器可以对一些资源进行认证保护，如果你要访问这些资源，就要提供用户名和密码，这个用户名和密码就是在Authorization头中附带的，格式是“username:password”字符串的base64编码，例如：Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ<mark>中，basic指使用basic认证方式，　QWxhZGRpbjpvcGVuIHNlc2FtZQ</mark>使用base64解码就是Aladdin:open sesame<br>\\n&nbsp;<br>\\nCache-Control：这个指令在request和response中都有，用来指示缓存系统（服务器上的，或者浏览器上的）应该怎样处理缓存，因为这个头域比较重要，特别是希望使用缓　存改善性能的时候，内容也较多，所以我想在下一篇博文中主要介绍一下。<br>\\n&nbsp;<br>\\nConnection：告诉服务器这个user agent（通常就是浏览器）想要使用怎样的连接方式。值有keep-alive和close。http1.1默认是keep-alive。keep-alive就是浏览器和服务器　的通信连接会被持续保存，不会马上关闭，而close就会在response后马上关闭。但这里要注意一点，我们说HTTP是无状态的，跟这个是否keep-alive没有关系，不要认为keep-alive是对HTTP无状态的特性的改进。<br>\\n&nbsp;<br>\\nCookie：浏览器向服务器发送请求时发送cookie，或者服务器向浏览器附加cookie，就是将cookie附近在这里的。例如：Cookie:user=admin<br>\\n&nbsp;<br>\\nContent-Length：一个请求的请求体的内存长度，单位为字节(byte)。请求体是指在HTTP头结束后，两个CR-LF字符组之后的内容，常见的有POST提交的表单数据，这个Content-Length并不包含请求行和HTTP头的数据长度。<br>\\n&nbsp;<br>\\nContent-MD5：使用base64进行了编码的请求体的MD5校验和。例如：Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==<br>\\n&nbsp;<br>\\nContent-Type：请求体中的内容的mime类型。通常只会用在POST和PUT方法的请求中。例如：Content-Type: application/x-www-form-urlencoded<br>\\n&nbsp;<br>\\nDate：发送请求时的GMT时间。例如：Date: Tue, 15 Nov 1994 08:12:31 GMT<br>\\n&nbsp;<br>\\nExpect：指示需要使用服务器某些特殊的功能。（这个我不是很清楚）<br>\\n&nbsp;<br>\\nFrom：发送这个请求的用户的email地址。例如：From: <a href=\\"mailto:user@example.com\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">user@example.com</a><br>\\n&nbsp;<br>\\nHost：被服务器的域名或IP地址，如果不是通用端口，还包含该端口号，例如：Host: <a href=\\"http://www.some.com:182\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">www.some.com:182</a><br>\\n&nbsp;<br>\\nIf-Match :通常用在使用PUT方法对服务器资源进行更新的请求中，意思就是，询问服务器，现在正在请求的资源的tag和这个If-Match的tag相不相同，如果相同，则证明服务器上的这个资源还是旧的，现在可以被更新，如果不相同，则证明该资源被更新过，现在就不用再更新了（否则有可能覆盖掉其他人所做的更改）。<br>\\n&nbsp;<br>\\nIf-Modified-Since：询问服务器现在正在请求的资源在某个时间以来有没有被修改过，如果没有，服务器则返回304状态来告诉浏览器使用浏览器自己本地的缓存，如果有修改过，则返回200，并发送新的资源（当然如果资源不存在，则返回404。）<br>\\n&nbsp;<br>\\nIf-None-Match：和If-Modified-Since用意差不多，不过不是根据时间来确定，而是根据一个叫ETag的东西来确定。关于etag我想在下一篇博客介绍一下。<br>\\n&nbsp;<br>\\nIf-Range：告诉服务器如果这个资源没有更改过(根据If-Range后面给出的Etag判断)，就发送这个资源中在浏览器缺少了的某些部分给浏览器，如果该资源以及被修改过，则将整个资源重新发送一份给浏览器。<br>\\n&nbsp;<br>\\nIf-Unmodified-Since：询问服务器现在正在请求的资源在某个时刻以来是否没有被修改过。<br>\\n&nbsp;<br>\\nMax-Forwards：限制请求信息在代理服务器或网关中向前传递的次数。<br>\\n&nbsp;<br>\\nPragma：好像只有一个值，就是:no-cache。Pragma:no-cache 与cache-control:no-cache相同，只不过cache-control:no-cache是http1.1专门指定的，而Pragma:no-cache可以在http1.0和1.1中使用<br>\\n&nbsp;<br>\\nProxy-Authorization：连接到某个代理时使用的身份认证信息，跟Authorization头差不多。例如：Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==<br>\\n&nbsp;<br>\\nRange：在HTTP头中，”Range”字眼都表示“资源的byte形式数据的顺序排列，并且取其某一段数据”的意思。Range头就是表示请求资源的从某个数值到某个数值间的数据，例如：Range: bytes=500-999 就是表示请求资源从500到999byte的数据。数据的分段下载和多线程下载就是利用这个实现的。<br>\\n&nbsp;<br>\\nReferer：指当前请求的URL是在什么地址引用的。<a href=\\"http://xn--www-uc0e316agqd.a.com/index.html%E9%A1%B5%E9%9D%A2%E4%B8%AD%E7%82%B9%E5%87%BB%E4%B8%80%E4%B8%AA%E6%8C%87%E5%90%91www.b.com%E7%9A%84%E8%B6%85%E9%93%BE%E6%8E%A5%EF%BC%8C%E9%82%A3%E4%B9%88%EF%BC%8C%E8%BF%99%E4%B8%AAwww.b.com%E7%9A%84%E8%AF%B7%E6%B1%82%E4%B8%AD%E7%9A%84Referer%E5%B0%B1%E6%98%AFwww.a.com/index.html%E3%80%82%E9%80%9A%E5%B8%B8%E6%88%91%E4%BB%AC%E8%A7%81%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87%E9%98%B2%E7%9B%97%E9%93%BE%E5%B0%B1%E6%98%AF%E7%94%A8%E8%BF%99%E4%B8%AA%E5%AE%9E%E7%8E%B0%E7%9A%84%E3%80%82\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">例如在www.a.com/index.html页面中点击一个指向www.b.com的超链接，那么，这个www.b.com的请求中的Referer就是www.a.com/index.html。通常我们见到的图片防盗链就是用这个实现的。</a><br>\\n&nbsp;<br>\\nUpgrade：请求服务器更新至另外一个协议，例如：Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11<br>\\n&nbsp;<br>\\nUser-Agent：通常就是用户的浏览器相关信息。例如：User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/12.0<br>\\n&nbsp;<br>\\nVia：用来记录一个请求经过了哪些代理或网关才被送到目标服务器上。例如一个请求从浏览器出发(假设使用http/1.0)，发送给名为 SomeProxy的内部代理，然后被转发至www.somenet.com的公共代理（使用http/1.1），<a href=\\"http://xn--www-4w2e97cpkq4l415boda96i829dgw1a2isvtv.someweb.com\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">最后被转发至目标服务器www.someweb.com</a>，那么在someweb.com中收到的via 头应该是：via:1.0 someProxy 1.1 [<a href=\\"http://www.someweb.com\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">www.someweb.com</a>(apache](<a href=\\"http://www.someweb.com\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">http://www.someweb.com</a>(apache) 1.1)<br>\\n&nbsp;<br>\\nWarning：记录一些警告信息。<br>\\n2.通用但是并非标准的http头<br>\\nX-Requested-With：主要是用来识别ajax请求，很多javascript框架会发送这个头域（值为XMLHttpRequest）<br>\\n&nbsp;<br>\\nDNT : DO NOT TRACK的缩写，要求服务器程序不要跟踪记录用户信息。DNT: 1 (开启DNT) DNT: 0 (关闭DNT)火狐，safari,IE9都支持这个头域，并且于2011年3月7日被提交至IETF组织实现标准化<br>\\n&nbsp;<br>\\nX-Forwarded-For : 记录一个请求从客户端出发到目标服务器过程中经历的代理，或者负载平衡设备的IP。<br>\\n&nbsp;<br>\\nX-Forwarded-Proto：记录一个请求一个请求最初从浏览器发出时候，是使用什么协议。因为有可能当一个请求最初和反向代理通信时，是使用https，但反向代理和服务器通信时改变成http协议，这个时候，X-Forwarded-Proto的值应该是https<br>\\n&nbsp;<br>\\nFront-End-Https：微软使用与其负载平衡的一个头域。</p>","autoDesc":true}');export{s as comp,T as data};
