import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,d as n,o as a}from"./app-pTjtTAfI.js";const l={};function t(r,s){return a(),e("div",null,s[0]||(s[0]=[n(`<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h2><p>贫血模型：一个类里面只有属性或者成员变量，没有方法<br> 充血模式：一个类既有属性也有成员变量，也有方法</p><p>贫血模式缺点以及充血模式需要注意的点<br> 业务泄露：对于对象的操作，应该通过对象自身来完成，不应该将操作泄露到对象的外部<br> 增加调用者负担：当调用对象的方法的时候，应该将对象当为一个黑盒状态，不需要去使用对象的内部细节(需要先调用a方法后调用b方法)<br> 难以维护：当后期业务需求发生变成，需要去修改操作该对象的所有方法，这样子难以维护</p><h2 id="贫血模型" tabindex="-1"><a class="header-anchor" href="#贫血模型"><span>贫血模型</span></a></h2><p>就将后端项目分为 Repository 层、Service 层、Controller 层。其 中，Repository 层负责数据访问，Service 层负责业务逻辑，Controller 层负责暴露接 口。<br> UserEntity 和 UserRepository 组成了数据访问层，UserBo 和 UserService 组成了业务逻辑层，UserVo 和 UserController 在这里属于接口层。 从代码中，我们可以发现，UserBo 是一个纯粹的数据结构，只包含数据，不包含任何业务 逻辑。业务逻辑集中在 UserService 中。我们通过 UserService 来操作 UserBo。换句话 说，Service 层的数据和业务逻辑，被分割为 BO 和 Service 两个类中。像 UserBo 这样， 只包含数据，不包含业务逻辑的类，就叫作贫血模型（Anemic Domain Model）</p><h2 id="充血模型" tabindex="-1"><a class="header-anchor" href="#充血模型"><span>充血模型</span></a></h2><p>基于充血模型的 DDD 开发模式实现的代码，也是按照 MVC 三层架构分层的。 Controller 层还是负责暴露接口，Repository 层还是负责数据存取，Service 层负责核心 业务逻辑。它跟基于贫血模型的传统开发模式的区别主要在 Service 层。<br> Service 层包含 Service 类和 Domain 类两部分。Domain 就相 当于贫血模型中的 BO。不过，Domain 与 BO 的区别在于它是基于充血模型开发的，既包 含数据，也包含业务逻辑。而 Service 类变得非常单薄。总结一下的话就是，基于贫血模型 的传统的开发模式，重 Service 轻 BO；基于充血模型的 DDD 开发模式，轻 Service 重 Domain。</p><p>将对实体类的操作，比如初始化状态修改等操作都放在实体类内进行操作，这就是充血模型</p><h2 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景</span></a></h2><p>基于充血模型的DDD开发模式，更适合业务复杂的系统开发。</p><h2 id="使用示例" tabindex="-1"><a class="header-anchor" href="#使用示例"><span>使用示例</span></a></h2><div class="language-plsql line-numbers-mode" data-highlighter="shiki" data-ext="plsql" data-title="plsql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">public class Employee</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    /// &lt;summary&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    /// 私有无参构造方法，给EFCore使用</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    /// &lt;/summary&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    private Employee()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    public Employee(string </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) : this()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        Name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    /// &lt;summary&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    /// 用户名 init只允许在构造函数的时候初始化</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    /// &lt;/summary&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    public string </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">Name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { get; init; }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    /// &lt;summary&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    /// 积分  private </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">，只允许在内部进行修改</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    /// &lt;/summary&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    public int Credit { get; private </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    /// &lt;summary&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    /// 密码哈希值  需要映射数据库中的列，但是不可以被修改的，所以定义为私有字段</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    /// &lt;/summary&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    private string PasswordHash;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    public void ChangeCredit(int credit)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        Credit = credit;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,12)]))}const h=i(l,[["render",t],["__file","modelDesignMode.html.vue"]]),c=JSON.parse('{"path":"/softwareDesign/domainDrivenDesign/commonConcept/modelDesignMode.html","title":"贫血充血和充血模式","lang":"zh-CN","frontmatter":{"title":"贫血充血和充血模式","lang":"zh-CN","date":"2023-08-24T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["软件设计"],"tag":["无"],"filename":"modelDesignMode","slug":"fuetgg","docsId":"67828037","description":"概述 贫血模型：一个类里面只有属性或者成员变量，没有方法 充血模式：一个类既有属性也有成员变量，也有方法 贫血模式缺点以及充血模式需要注意的点 业务泄露：对于对象的操作，应该通过对象自身来完成，不应该将操作泄露到对象的外部 增加调用者负担：当调用对象的方法的时候，应该将对象当为一个黑盒状态，不需要去使用对象的内部细节(需要先调用a方法后调用b方法) 难...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/softwareDesign/domainDrivenDesign/commonConcept/modelDesignMode.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"贫血充血和充血模式"}],["meta",{"property":"og:description","content":"概述 贫血模型：一个类里面只有属性或者成员变量，没有方法 充血模式：一个类既有属性也有成员变量，也有方法 贫血模式缺点以及充血模式需要注意的点 业务泄露：对于对象的操作，应该通过对象自身来完成，不应该将操作泄露到对象的外部 增加调用者负担：当调用对象的方法的时候，应该将对象当为一个黑盒状态，不需要去使用对象的内部细节(需要先调用a方法后调用b方法) 难..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-10-31T07:43:44.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-08-24T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-10-31T07:43:44.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"贫血充血和充血模式\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-08-24T00:00:00.000Z\\",\\"dateModified\\":\\"2023-10-31T07:43:44.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[]},{"level":2,"title":"贫血模型","slug":"贫血模型","link":"#贫血模型","children":[]},{"level":2,"title":"充血模型","slug":"充血模型","link":"#充血模型","children":[]},{"level":2,"title":"使用场景","slug":"使用场景","link":"#使用场景","children":[]},{"level":2,"title":"使用示例","slug":"使用示例","link":"#使用示例","children":[]}],"git":{"createdTime":1693926838000,"updatedTime":1698738224000,"contributors":[{"name":"zhangyunpeng","username":"zhangyunpeng","email":"zhang.yunpeng@synyi.com","commits":1},{"name":"azrng","username":"azrng","email":"itzhangyunpeng@163.com","commits":1}]},"readingTime":{"minutes":2.7,"words":809},"filePathRelative":"softwareDesign/domainDrivenDesign/commonConcept/modelDesignMode.md","localizedDate":"2023年8月24日","excerpt":"<h2>概述</h2>\\n<p>贫血模型：一个类里面只有属性或者成员变量，没有方法<br>\\n充血模式：一个类既有属性也有成员变量，也有方法</p>\\n<p>贫血模式缺点以及充血模式需要注意的点<br>\\n业务泄露：对于对象的操作，应该通过对象自身来完成，不应该将操作泄露到对象的外部<br>\\n增加调用者负担：当调用对象的方法的时候，应该将对象当为一个黑盒状态，不需要去使用对象的内部细节(需要先调用a方法后调用b方法)<br>\\n难以维护：当后期业务需求发生变成，需要去修改操作该对象的所有方法，这样子难以维护</p>\\n<h2>贫血模型</h2>\\n<p>就将后端项目分为 Repository 层、Service 层、Controller 层。其 中，Repository 层负责数据访问，Service 层负责业务逻辑，Controller 层负责暴露接 口。<br>\\nUserEntity 和 UserRepository 组成了数据访问层，UserBo 和 UserService 组成了业务逻辑层，UserVo 和 UserController 在这里属于接口层。 从代码中，我们可以发现，UserBo 是一个纯粹的数据结构，只包含数据，不包含任何业务 逻辑。业务逻辑集中在 UserService 中。我们通过 UserService 来操作 UserBo。换句话 说，Service 层的数据和业务逻辑，被分割为 BO 和 Service 两个类中。像 UserBo 这样， 只包含数据，不包含业务逻辑的类，就叫作贫血模型（Anemic Domain Model）</p>","autoDesc":true}');export{h as comp,c as data};
