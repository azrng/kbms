import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as e,o as p,c as o,a as n,d as s,e as c,b as i}from"./app-Bw62I61B.js";const l={},u=i(`<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h2><p>现如今程序员对Web API的调用已经是轻车熟路。但是传统的api调用都是拉模式，也就是主动发起请求去调用一个api. 但是程序员往往对另一种很有用的模式很陌生，即推模式。</p><ul><li>拉模式 - 主动调用并获取结果的模式。</li><li>推模式 - 订阅并接受数据推送的模式。</li></ul><p>今天要介绍的是一个被大家忽略但却非常有用的一项技术。 基于HTTP/2的标准服务器事件推送模式，英文简称Server-Sent Events，后面简称SSE。</p><h2 id="server-sent-events" tabindex="-1"><a class="header-anchor" href="#server-sent-events"><span>Server-Sent Events</span></a></h2><p>这里引用MDN上的一段解释：</p><blockquote><p>EventSource 是服务器推送的一个网络事件接口。一个EventSource实例会对HTTP服务开启一个持久化的连接，以text/event-stream\` 格式发送事件, 会一直保持开启直到被要求关闭。 一旦连接开启，来自服务端传入的消息会以事件的形式分发至你代码中。如果接收消息中有一个事件字段，触发的事件与事件字段的值相同。如果没有事件字段存在，则将触发通用事件。 与 WebSockets,不同的是，服务端推送是单向的。数据信息被单向从服务端到客户端分发. 当不需要以消息形式将数据从客户端发送到服务器时，这使它们成为绝佳的选择。例如，对于处理社交媒体状态更新，新闻提要或将数据传递到客户端存储机制（如IndexedDB或Web存储）之类的，EventSource无疑是一个有效方案。</p></blockquote><p>以上解释简单说明了SSE的用途，该项技术也是推模式的典型技术之一。同类型的技术是WebSockets, 和SignalR。 代码是展示一项技术的最好办法：</p><h2 id="操作示例" tabindex="-1"><a class="header-anchor" href="#操作示例"><span>操作示例</span></a></h2><h3 id="客户端实现" tabindex="-1"><a class="header-anchor" href="#客户端实现"><span>客户端实现</span></a></h3><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code>   <span class="token comment">//javascript 构造一个EventSource实例，代表一个服务器推送长连接。</span>
<span class="token class-name"><span class="token keyword">var</span></span> source <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">EventSource</span><span class="token punctuation">(</span><span class="token string">&quot;/api/values&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//传入支持推送模式的api url。随后展示。</span>

<span class="token comment">//当普通消息被传递时触发。</span>
       source<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> function <span class="token punctuation">(</span><span class="token keyword">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>&#39;onmessage<span class="token punctuation">:</span> &#39; <span class="token operator">+</span> <span class="token keyword">event</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//当连接打开时触发。</span>
       source<span class="token punctuation">.</span>onopen <span class="token operator">=</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>&#39;onopen&#39;<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//当出错时候触发</span>
       source<span class="token punctuation">.</span>onerror <span class="token operator">=</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>&#39;onerror&#39;<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
       
       <span class="token comment">//使用自定义时间时候触发。ping为自定义事件，你可以根据实际需求定义自己的事件名称。如果事件名称匹配，则该方法会被调用</span>
       source<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;ping&quot;</span><span class="token punctuation">,</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>&#39;onping&#39; <span class="token operator">+</span> <span class="token keyword">event</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="asp-net-core-api实现" tabindex="-1"><a class="header-anchor" href="#asp-net-core-api实现"><span>ASP.NET Core API实现</span></a></h3><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">HttpGet</span></span><span class="token punctuation">]</span>
<span class="token keyword">public</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">GetValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token comment">//测试，debug到这里的时候你会发现，协议使用的是HTTP/2. APS.NET Core 2.1以上就默认支持HTTP/2，无需额外的配置。再Windows Server2016/Windows10+会自动提供支持。</span>
   <span class="token class-name"><span class="token keyword">string</span></span> requestProtocol <span class="token operator">=</span> HttpContext<span class="token punctuation">.</span>Request<span class="token punctuation">.</span>Protocol<span class="token punctuation">;</span>
   <span class="token class-name"><span class="token keyword">var</span></span> response <span class="token operator">=</span> Response<span class="token punctuation">;</span>
   <span class="token comment">//响应头部添加text/event-stream，这是HTTP/2协议的一部分。</span>
   response<span class="token punctuation">.</span>Headers<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">&quot;Content-Type&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;text/event-stream&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
	   <span class="token comment">// event:ping event是事件字段名，冒号后面是事件名称，不要忘了\\n换行符。</span>
	   <span class="token keyword">await</span> HttpContext<span class="token punctuation">.</span>Response<span class="token punctuation">.</span><span class="token function">WriteAsync</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;event:ping\\n&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	   
	   <span class="token comment">// data: 是数据字段名称，冒号后面是数据字段内容。注意数据内容仅仅支持UTF-8，不支持二进制格式。</span>
	   <span class="token comment">// data后面的数据当然可以传递JSON String的。</span>
	   <span class="token keyword">await</span> HttpContext<span class="token punctuation">.</span>Response<span class="token punctuation">.</span><span class="token function">WriteAsync</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;data:Controller </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">i</span><span class="token punctuation">}</span></span><span class="token string"> at </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">DateTime<span class="token punctuation">.</span>Now</span><span class="token punctuation">}</span></span><span class="token string">\\r\\r&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	   
	   <span class="token comment">// 写入数据到响应后不要忘记 FlushAsync()，因为该api方法是异步的，所以要全程异步，调用同步方法会报错。</span>
	   <span class="token keyword">await</span> HttpContext<span class="token punctuation">.</span>Response<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">FlushAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	   
	   <span class="token comment">//模拟一个1秒的延迟。</span>
	   <span class="token keyword">await</span> Task<span class="token punctuation">.</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
   
   <span class="token comment">//数据发送完毕后关闭连接。</span>
   Response<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="协议字段解释" tabindex="-1"><a class="header-anchor" href="#协议字段解释"><span>协议字段解释</span></a></h2><p>event 事件类型.如果指定了该字段,则在客户端接收到该条消息时,会在当前的EventSource对象上触发一个事件,事件类型就是该字段的字段值,你可以使用addEventListener()方法在当前EventSource对象上监听任意类型的命名事件,如果该条消息没有event字段,则会触发onmessage属性上的事件处理函数. data 消息的数据字段.如果该条消息包含多个data字段,则客户端会用换行符把它们连接成一个字符串来作为字段值. id 事件ID,会成为当前EventSource对象的内部属性&quot;最后一个事件ID&quot;的属性值. retry 一个整数值,指定了重新连接的时间(单位为毫秒),如果该字段值不是整数,则会被忽略. 消息的例子：</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">event</span><span class="token punctuation">:</span> <span class="token class-name">userconnect</span>
data<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">&quot;username&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;bobby&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;time&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;02:33:48&quot;</span><span class="token punctuation">}</span>

<span class="token keyword">event</span><span class="token punctuation">:</span> <span class="token class-name">usermessage</span>
data<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">&quot;username&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;bobby&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;time&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;02:34:11&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;text&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;Hi everyone.&quot;</span><span class="token punctuation">}</span>

<span class="token keyword">event</span><span class="token punctuation">:</span> <span class="token class-name">userdisconnect</span>
data<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">&quot;username&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;bobby&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;time&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;02:34:23&quot;</span><span class="token punctuation">}</span>

<span class="token keyword">event</span><span class="token punctuation">:</span> <span class="token class-name">usermessage</span>
data<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">&quot;username&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;sean&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;time&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;02:34:36&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;text&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;Bye, bobby.&quot;</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>这里提醒大家去仔细阅读消息的格式。消息格式错误，将导致数据无法正确解析。</p></blockquote><h2 id="对比" tabindex="-1"><a class="header-anchor" href="#对比"><span>对比</span></a></h2><p>到这里大家不难发现SSE技术其实也是一种实时服务端推送数据的技术，但是他的光环被更为闪耀的WebSockets给覆盖了。Stackoverflow上有一篇很不错的对比。大家可以搜索WebSockets vs. Server-Sent events/EventSource 总的来说，SSE能实现的功能WebSockets都能实现，但是SEE更轻量无需其他库并且服务器端也非常容易编写。同时她是基于HTTP的，自然在穿透防火墙方面也就无需太多顾虑。更多的对比结论如下（参考。 SSE 相对于 Websockets 的优势：</p><ul><li>通过简单的 HTTP 而不是自定义协议传输</li><li>可以使用第三方库支持不支持SSE的浏览器例如IE浏览器。</li><li>内置支持重新连接和事件 ID</li><li>更简单的协议</li><li>企业防火墙进行数据包检查不会有问题。</li></ul><p>Websockets 相对于 SSE 的优势：</p><ul><li>实时，双向通信。</li><li>更多浏览器的原生支持</li></ul><p>SSE 的理想用例：</p><ul><li>股票行情流，数据监控大屏数据发送，IOT物联网设备数据发送。</li><li>社交平台上的状态更新等。</li><li>浏览器通知</li></ul><p>SSE缺陷：</p><ul><li>不支持二进制</li><li>最大打开连接数限制。HTTP1.1 单个浏览器只支持6个连接（也就是打开6个Tab页以上就会出问题，并且在Chrom和Firefox上无法解决）HTTP/2上默认100个。</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>SSE是一项轻量级的基于HTTP/2的标准协议，除了IE浏览器（不包含Edge）以外的其他浏览器均已支持该协议。后端服务ASP.NET Core 无疑也是完美支持的，.NET程序员可以放心使用。因为SSE使用HTTP最大的优势可以避过防火墙的坑，WebSockets协议在穿透防火墙时候可能会有问题，而且有些老式的中间设备可能不认识WebSockets协议导致兼容性问题。 SSE另一个优点是无需额外的库就可以启用，而且支持自动重连。非常适合从服务器推送数据到客户端的单项应用。而不用无脑的考虑WebSockets协议。甚至可以吧SSE 和 Websokets协议联合起来使用，当仅需服务器单项传输时候采用SSE，需要双向传输时候采用Websokets。</p><h2 id="资料" tabindex="-1"><a class="header-anchor" href="#资料"><span>资料</span></a></h2>`,29),r={href:"https://mp.weixin.qq.com/s/DEZ3FiWGyLQ5-HwTuvjSQw",target:"_blank",rel:"noopener noreferrer"};function k(d,v){const a=e("ExternalLinkIcon");return p(),o("div",null,[u,n("p",null,[n("a",r,[s("https://mp.weixin.qq.com/s/DEZ3FiWGyLQ5-HwTuvjSQw"),c(a)]),s(" | 基于ASP.NET Core api 的服务器事件发送")])])}const g=t(l,[["render",k],["__file","sse.html.vue"]]),h=JSON.parse('{"path":"/dotnet/api/sse.html","title":"SSE","lang":"zh-CN","frontmatter":{"title":"SSE","lang":"zh-CN","date":"2023-06-20T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["dotNET"],"tag":["无"],"filename":"sse","slug":"wu9bhq","docsId":"69447450","description":"概述 现如今程序员对Web API的调用已经是轻车熟路。但是传统的api调用都是拉模式，也就是主动发起请求去调用一个api. 但是程序员往往对另一种很有用的模式很陌生，即推模式。 拉模式 - 主动调用并获取结果的模式。 推模式 - 订阅并接受数据推送的模式。 今天要介绍的是一个被大家忽略但却非常有用的一项技术。 基于HTTP/2的标准服务器事件推送模式...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dotnet/api/sse.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"SSE"}],["meta",{"property":"og:description","content":"概述 现如今程序员对Web API的调用已经是轻车熟路。但是传统的api调用都是拉模式，也就是主动发起请求去调用一个api. 但是程序员往往对另一种很有用的模式很陌生，即推模式。 拉模式 - 主动调用并获取结果的模式。 推模式 - 订阅并接受数据推送的模式。 今天要介绍的是一个被大家忽略但却非常有用的一项技术。 基于HTTP/2的标准服务器事件推送模式..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-10-22T08:11:43.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-06-20T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-10-22T08:11:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"SSE\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-06-20T00:00:00.000Z\\",\\"dateModified\\":\\"2023-10-22T08:11:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[]},{"level":2,"title":"Server-Sent Events","slug":"server-sent-events","link":"#server-sent-events","children":[]},{"level":2,"title":"操作示例","slug":"操作示例","link":"#操作示例","children":[{"level":3,"title":"客户端实现","slug":"客户端实现","link":"#客户端实现","children":[]},{"level":3,"title":"ASP.NET Core API实现","slug":"asp-net-core-api实现","link":"#asp-net-core-api实现","children":[]}]},{"level":2,"title":"协议字段解释","slug":"协议字段解释","link":"#协议字段解释","children":[]},{"level":2,"title":"对比","slug":"对比","link":"#对比","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"资料","slug":"资料","link":"#资料","children":[]}],"git":{"createdTime":1697962303000,"updatedTime":1697962303000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":1}]},"readingTime":{"minutes":6.15,"words":1845},"filePathRelative":"dotnet/api/sse.md","localizedDate":"2023年6月20日","excerpt":"<h2>概述</h2>\\n<p>现如今程序员对Web API的调用已经是轻车熟路。但是传统的api调用都是拉模式，也就是主动发起请求去调用一个api.\\n但是程序员往往对另一种很有用的模式很陌生，即推模式。</p>\\n<ul>\\n<li>拉模式 - 主动调用并获取结果的模式。</li>\\n<li>推模式 - 订阅并接受数据推送的模式。</li>\\n</ul>\\n<p>今天要介绍的是一个被大家忽略但却非常有用的一项技术。\\n基于HTTP/2的标准服务器事件推送模式，英文简称Server-Sent Events，后面简称SSE。</p>\\n<h2>Server-Sent Events</h2>\\n<p>这里引用MDN上的一段解释：</p>","autoDesc":true}');export{g as comp,h as data};
