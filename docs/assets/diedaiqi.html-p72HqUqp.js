import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,b as e}from"./app-Bw62I61B.js";const t={},p=e(`<h2 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍"><span>介绍</span></a></h2><p>迭代器就是可以返回相同类型的值的有序序列的一段代码，可以做维护方法、运算符或者get访问器的代码体、迭代器代码使用yield return依次返回每个元素，yield break语句将终止迭代。</p><h2 id="操作" tabindex="-1"><a class="header-anchor" href="#操作"><span>操作</span></a></h2><p>在 C## 代码中，尤其是基础库的 API 中，我们经常可以看到很多方法返回的是 <code>IEnumerable&lt;T&gt;</code> 类型，为什么要返回 <code>IEnumerable&lt;T&gt;</code> 而不是 <code>IList&lt;T&gt;</code>、<code>ICollection&lt;T&gt;</code> 等类型呢？从字面上理解，<code>IEnumerable&lt;T&gt;</code> 表示该集合中的元素可以被遍历。要完全理解 <code>IEnumerable&lt;T&gt;</code> 类型对象如何被遍历，就要先理解 yield 关键字。 在 C## 中，大多数方法都是通过 return 语句把计算得到的结果返回给调用者，同时把控制权交回给调用者。比如下面这样一个获取斐波那契数列的方法：</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">&gt;</span></span> nums <span class="token operator">=</span> <span class="token function">Fibonacci</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> n <span class="token keyword">in</span> nums<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token string">&quot;{0} &quot;</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token return-type class-name">List<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">&gt;</span></span> <span class="token function">Fibonacci</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> count<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token class-name"><span class="token keyword">int</span></span> prev <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token class-name"><span class="token keyword">int</span></span> curr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token class-name">List<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    result<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword">int</span></span> temp <span class="token operator">=</span> prev <span class="token operator">+</span> curr<span class="token punctuation">;</span>
    prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>
    curr <span class="token operator">=</span> temp<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出：</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token number">1</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">8</span> <span class="token number">13</span> <span class="token number">21</span> <span class="token number">34</span> <span class="token number">55</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在 Console.Write() 打印结果之前，变量 nums 已经装载了完整的数据，所以运行后在打印结果的时候可以瞬间把结果全部输出，这看起来没有什么问题。 现在换个场景，假设 Fibonacci() 方法内部每次计算得到下一个数都需要耗费较长的时间。我们用 Thread.Sleep() 模拟一下所需的耗时，如下：</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token range operator">..</span><span class="token punctuation">.</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    result<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Thread<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword">int</span></span> temp <span class="token operator">=</span> prev <span class="token operator">+</span> curr<span class="token punctuation">;</span>
    prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>
    curr <span class="token operator">=</span> temp<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次运行，你会发现，大概等待 10 秒后所有数字被瞬间打印出来。而在等待的这段时间，你无法了解程序运算的进展，期间是没有反馈的。 可以通过 yield 关键字很好地解决这个问题。yield 可以把每一步计算推迟到它程序实际需要的时候再执行，也就是说，你不必等所有结果都计算完才执行下文代码。 下面使用 yield 关键字改造一下 Fibonacci() 方法：</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token return-type class-name">IEnumerable<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">&gt;</span></span> <span class="token function">Fibonacci</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> count<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword">int</span></span> prev <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword">int</span></span> curr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">yield</span> <span class="token keyword">return</span> prev<span class="token punctuation">;</span>
        Thread<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">int</span></span> temp <span class="token operator">=</span> prev <span class="token operator">+</span> curr<span class="token punctuation">;</span>
        prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>
        curr <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次运行后，你会看到，每隔 1 秒会输出一个数字，直到所有数字全部输出。虽然总的等待时间是一样的，但对于图形用户界面来说，这种即时响应的用户体验明细要好于之前的“漫长”等待。 yield 关键字的用途是把指令推迟到程序实际需要的时候再执行，这个特性允许我们更细致地控制集合每个元素产生的时机。它的好处之一是，可以像上面演示的那样尽可能即时地给用户响应。还有一个好处是，可以提高内存使用效率。当我们有一个方法要返回一个集合时，而作为方法的实现者我们并不清楚方法调用者具体在什么时候要使用该集合数据。如果我们不使用 yield 关键字，则意味着需要把集合数据装载到内存中等待被使用，这可能导致数据在内存中占用较长的时间。 通过 yield 返回的 <code>IEnumerable&lt;T&gt;</code> 类型，表示这是一个可以被遍历的数据集合。它之所以可以被遍历，是因为它实现了一个标准的 IEnumerable 接口。一般，我们把像上面这种包含 yield 语句并返回 <code>IEnumerable&lt;T&gt;</code> 类型的方法称为迭代器（Iterator）。 注意：包含 yield 语句的方法的返回类型也可以是 <code>IEnumerator&lt;T&gt;</code>，它比迭代器更低一个层级，迭代器是列举器的一种实现。 迭代器方法和普通的方法相比，普通方法是通过 return 语句立即把程序的控制权交回给调用者，同时也会把方法内的本地（局部）资源释放掉。迭代器方法则是在依次返回多个值给调用者的期间保留本地资源，等所有值都返回结束时再释放掉本地资源，这些返回的值将形成一组序列被调用者使用。 在 C## 中，迭代器可以用于方法、属性或索引器中。迭代器中的 yield 语句分为两种：</p><ul><li>yeild return，把程序控制权交回调用者并保留本地状态，调用者拿到返回的值继续往后执行。</li><li>yeild break，用于告诉程序当前序列已经结束，相当于正常代码块的 return 语句（迭代器中直接使用 return 是非法的）。</li></ul><p>实际场景中，我们一般很少直接写迭代器，因为大部分需要迭代的场景都是数组、集合和列表等，而这些类型内部已经封装好了所需的迭代器。</p>`,14),o=[p];function c(l,i){return s(),a("div",null,o)}const d=n(t,[["render",c],["__file","diedaiqi.html.vue"]]),k=JSON.parse('{"path":"/dotnet/csharp/jigecaozuo/diedaiqi.html","title":"迭代器","lang":"zh-CN","frontmatter":{"title":"迭代器","lang":"zh-CN","date":"2023-10-22T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["csharp"],"tag":["无"],"filename":"diedaiqi","slug":"dl5z69","docsId":"57052189","description":"介绍 迭代器就是可以返回相同类型的值的有序序列的一段代码，可以做维护方法、运算符或者get访问器的代码体、迭代器代码使用yield return依次返回每个元素，yield break语句将终止迭代。 操作 在 C## 代码中，尤其是基础库的 API 中，我们经常可以看到很多方法返回的是 IEnumerable<T> 类型，为什么要返回 IEnumer...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dotnet/csharp/jigecaozuo/diedaiqi.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"迭代器"}],["meta",{"property":"og:description","content":"介绍 迭代器就是可以返回相同类型的值的有序序列的一段代码，可以做维护方法、运算符或者get访问器的代码体、迭代器代码使用yield return依次返回每个元素，yield break语句将终止迭代。 操作 在 C## 代码中，尤其是基础库的 API 中，我们经常可以看到很多方法返回的是 IEnumerable<T> 类型，为什么要返回 IEnumer..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-11-17T15:44:14.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-10-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-11-17T15:44:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"迭代器\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-10-22T00:00:00.000Z\\",\\"dateModified\\":\\"2023-11-17T15:44:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"介绍","slug":"介绍","link":"#介绍","children":[]},{"level":2,"title":"操作","slug":"操作","link":"#操作","children":[]}],"git":{"createdTime":1700232644000,"updatedTime":1700235854000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":2}]},"readingTime":{"minutes":4.34,"words":1301},"filePathRelative":"dotnet/csharp/jigecaozuo/diedaiqi.md","localizedDate":"2023年10月22日","excerpt":"<h2>介绍</h2>\\n<p>迭代器就是可以返回相同类型的值的有序序列的一段代码，可以做维护方法、运算符或者get访问器的代码体、迭代器代码使用yield return依次返回每个元素，yield break语句将终止迭代。</p>\\n<h2>操作</h2>\\n<p>在 C## 代码中，尤其是基础库的 API 中，我们经常可以看到很多方法返回的是 <code>IEnumerable&lt;T&gt;</code> 类型，为什么要返回 <code>IEnumerable&lt;T&gt;</code> 而不是 <code>IList&lt;T&gt;</code>、<code>ICollection&lt;T&gt;</code> 等类型呢？从字面上理解，<code>IEnumerable&lt;T&gt;</code> 表示该集合中的元素可以被遍历。要完全理解 <code>IEnumerable&lt;T&gt;</code> 类型对象如何被遍历，就要先理解 yield 关键字。\\n在 C## 中，大多数方法都是通过 return 语句把计算得到的结果返回给调用者，同时把控制权交回给调用者。比如下面这样一个获取斐波那契数列的方法：</p>","autoDesc":true}');export{d as comp,k as data};
