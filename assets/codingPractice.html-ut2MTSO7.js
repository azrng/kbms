import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,d as a,o as n}from"./app-OPlDaE8U.js";const i={};function c(o,e){return n(),r("div",null,e[0]||(e[0]=[a('<h2 id="ddd中的写操作" tabindex="-1"><a class="header-anchor" href="#ddd中的写操作"><span>DDD中的写操作</span></a></h2><p>在写的操作中，我们需要严格地按照应用服务-&gt;聚合根-&gt;资源库的结构进行编码，写的操作又三种场景</p><ul><li>通过聚合根完成业务请求，这是DDD完成业务请求的典型方式</li><li>通过Factory完成聚合跟单创建</li><li>通过DomainService去完成业务请求，当业务放在聚合根中不合适的时候才考虑放在DomainService中</li></ul><p>资料来自：<a href="https://www.cnblogs.com/davenkin/p/ddd-coding-practices.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/davenkin/p/ddd-coding-practices.html</a></p><h2 id="ddd中的读操作" tabindex="-1"><a class="header-anchor" href="#ddd中的读操作"><span>DDD中的读操作</span></a></h2><p>介绍三种读操作的方式</p><ul><li>基于领域模型的读操作：如果涉及到表关联的，需要先查询第一个，在查询第二个，然后在内存中进行处理</li><li>基于数据模型的读操作：直接另外编写一个新的领域服务，然后通过数据库读取客户端所需要的数据，然后直接返回对应的数据</li><li>CQRS：命令查询职责分离，读和写操作分别使用了不同的数据库，数据从写的模型中同步到的读的模型库中，通过领域事件的形式同步变更信息。</li></ul><p>遵循的原则是：领域中的对象不能直接返回给客户端，因为这样子领域模型的内部便暴漏给了外界，这样子如果对领域模型的修改也是直接影响到客户端，所以通常我们会对读操作专门创建用于数据展示的模型。</p><p>资料来自：<a href="https://www.cnblogs.com/davenkin/p/ddd-coding-practices.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/davenkin/p/ddd-coding-practices.html</a></p><h2 id="开源项目" tabindex="-1"><a class="header-anchor" href="#开源项目"><span>开源项目</span></a></h2><h3 id="jasontaylordev-cleanarchitecture" tabindex="-1"><a class="header-anchor" href="#jasontaylordev-cleanarchitecture"><span>jasontaylordev/CleanArchitecture</span></a></h3><p>jasontaylordev/CleanArchitecture:Jason <a href="http://xn--TaylorCleanArchitectureASP-2k15bv7at3xhw1pb91dtcjpndwv03b.NET" target="_blank" rel="noopener noreferrer">Taylor的CleanArchitecture项目是一个使用ASP.NET</a> Core的范例应用，以演示Clean Architecture的实际应用为目的。它包含一个简单的任务管理应用程序，展示了如何使用Clean <a href="http://xn--ArchitectureASP-ib5zg25lcfdcp6l.NET" target="_blank" rel="noopener noreferrer">Architecture的思想和ASP.NET</a> Core技术栈构建应用。该项目的代码结构和组织方式符合Clean Architecture的原则，分为实体（Entities）、用例（Use Cases）、接口适配器（Interface Adapters）和框架和驱动（Frameworks and Drivers）等层次。</p><p>仓库地址：<a href="https://github.com/jasontaylordev/CleanArchitecture" target="_blank" rel="noopener noreferrer">https://github.com/jasontaylordev/CleanArchitecture</a></p><h3 id="ardalis-cleanarchitecture" tabindex="-1"><a class="header-anchor" href="#ardalis-cleanarchitecture"><span>ardalis/CleanArchitecture</span></a></h3><p>ardalis/CleanArchitecture:Steve &quot;ardalis&quot; <a href="http://xn--SmithCleanArchitectureASP-6d53bo6am6by8rhk8pb91dscjpndwv03b.NET" target="_blank" rel="noopener noreferrer">Smith的CleanArchitecture项目也是一个使用ASP.NET</a> Core的Clean Architecture实现，旨在为开发者提供一个可用于实际项目的模板。与Taylor的项目类似，ardalis的项目也包含了一些实用的工具和模板代码，以帮助开发者更轻松地构建符合Clean Architecture的应用。</p><p>仓库地址：<a href="https://github.com/ardalis/CleanArchitecture" target="_blank" rel="noopener noreferrer">https://github.com/ardalis/CleanArchitecture</a></p>',16)]))}const d=t(i,[["render",c]]),s=JSON.parse('{"path":"/softwareDesign/domainDrivenDesign/codingPractice.html","title":"编码实践","lang":"zh-CN","frontmatter":{"title":"编码实践","lang":"zh-CN","date":"2023-11-26T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["软件设计"],"tag":["实践"],"description":"DDD中的写操作 在写的操作中，我们需要严格地按照应用服务->聚合根->资源库的结构进行编码，写的操作又三种场景 通过聚合根完成业务请求，这是DDD完成业务请求的典型方式 通过Factory完成聚合跟单创建 通过DomainService去完成业务请求，当业务放在聚合根中不合适的时候才考虑放在DomainService中 资料来自：https://ww...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"编码实践\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-11-26T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-16T07:47:51.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"],["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/softwareDesign/domainDrivenDesign/codingPractice.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"编码实践"}],["meta",{"property":"og:description","content":"DDD中的写操作 在写的操作中，我们需要严格地按照应用服务->聚合根->资源库的结构进行编码，写的操作又三种场景 通过聚合根完成业务请求，这是DDD完成业务请求的典型方式 通过Factory完成聚合跟单创建 通过DomainService去完成业务请求，当业务放在聚合根中不合适的时候才考虑放在DomainService中 资料来自：https://ww..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-16T07:47:51.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"实践"}],["meta",{"property":"article:published_time","content":"2023-11-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-16T07:47:51.000Z"}]]},"git":{"createdTime":1701007162000,"updatedTime":1718524071000,"contributors":[{"name":"azrng","username":"","email":"itzhangyunpeng@163.com","commits":2}]},"readingTime":{"minutes":2.14,"words":642},"filePathRelative":"softwareDesign/domainDrivenDesign/codingPractice.md","excerpt":"<h2>DDD中的写操作</h2>\\n<p>在写的操作中，我们需要严格地按照应用服务-&gt;聚合根-&gt;资源库的结构进行编码，写的操作又三种场景</p>\\n<ul>\\n<li>通过聚合根完成业务请求，这是DDD完成业务请求的典型方式</li>\\n<li>通过Factory完成聚合跟单创建</li>\\n<li>通过DomainService去完成业务请求，当业务放在聚合根中不合适的时候才考虑放在DomainService中</li>\\n</ul>\\n<p>资料来自：<a href=\\"https://www.cnblogs.com/davenkin/p/ddd-coding-practices.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://www.cnblogs.com/davenkin/p/ddd-coding-practices.html</a></p>","autoDesc":true}');export{d as comp,s as data};
