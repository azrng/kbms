import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,o as a,d as i}from"./app-2OrQE2Jp.js";const n="/kbms/common/1609400134093-42c4d987-18cf-4d59-82e0-732efed0c75b.png",r="/kbms/common/1609400134139-7ef0cc81-84a6-4978-bed8-42e25eab7955.png",l={},o=i('<h2 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍"><span>介绍</span></a></h2><p>没有消费的消息叫做死信队列 生产者 --&gt; 消息 --&gt; 交换机 --&gt; 队列 --&gt; 变成死信 --&gt; DLX交换机 --&gt;队列 --&gt; 消费者</p><h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h2><h3 id="dlx" tabindex="-1"><a class="header-anchor" href="#dlx"><span>DLX</span></a></h3><p>Dead Letter Exchange 的缩写 DLX（Dead Letter Exchanges）死信交换，死信队列本身也是一个普通的消息队列，在创建队列的时候，通过设置一些关键参数，可以将一个普通的消息队列设置为死信队列，与其它消息队列不同的是，其入栈的消息根据入栈时指定的过期时间/被拒绝/超出队列长度被移除，依次被转发到指定的消息队列中进行二次处理。这样说法比较拗口，其原理就是死信队列内位于顶部的消息过期时，该消息将被马上发送到另外一个订阅者（消息队列）中。</p><h3 id="什么是死信" tabindex="-1"><a class="header-anchor" href="#什么是死信"><span>什么是死信</span></a></h3><p>当一条消息满足下列条件之一那么它会成为死信：</p><ul><li>消息被否定确认（如 channel.basicNack）并且此时 requeue 属性被设置为 false。</li><li>消息在队列的存活时间超过设置的 TTL 时间</li><li>消息队列的消息数量已经超过最大队列长度</li></ul><p>若配置了死信队列，死信会被 RabbitMQ 投到死信队列中。</p><h3 id="什么是死信交换机" tabindex="-1"><a class="header-anchor" href="#什么是死信交换机"><span>什么是死信交换机</span></a></h3><p>在定义业务队列的时候，要考虑指定一个死信交换机，死信交换机可以和任何一个普通的队列进行绑定，然后在业务队列出现死信的时候就会将数据发送到死信队列。</p><h3 id="什么是死信队列" tabindex="-1"><a class="header-anchor" href="#什么是死信队列"><span>什么是死信队列</span></a></h3><p>死信队列实际上就是一个普通的队列，只是这个队列跟死信交换机进行了绑定，用来存放死信而已     <strong>如何使用死信交换机</strong> 定义业务（普通）队列的时候指定参数 x-dead-letter-exchange: 用来设置死信后发送的交换机 x-dead-letter-routing-key：用来设置死信的routingKey 死信交换机图解 <img src="'+n+'" alt="image.png" loading="lazy">     <img src="'+r+'" alt="image.png" loading="lazy">     <strong>生产者:</strong> (1)生产者连接到RabbitMQ Broker，建立一个连接( Connection)开启一个信道(Channel) (2)生产者声明一个交换器，并设置相关属性，比如交换机类型、是否持久化等 (3)生产者声明一个队列井设置相关属性，比如是否排他、是否持久化、是否自动删除等 (4)生产者通过路由键将交换器和队列绑定起来 (5)生产者发送消息至RabbitMQ Broker，其中包含路由键、交换器等信息。 (6)相应的交换器根据接收到的路由键查找相匹配的队列。 (7)如果找到，则将从生产者发送过来的消息存入相应的队列中。 (8)如果没有找到，则根据生产者配置的属性选择丢弃还是回退给生产者 (9)关闭信道。 (10)关闭连接。   <strong>消费者:</strong> (1)消费者连接到RabbitMQ Broker ，建立一个连接(Connection)，开启一个信道(Channel) 。 (2)消费者向RabbitMQ Broker 请求消费相应队列中的消息，可能会设置相应的回调函数， (3)等待RabbitMQ Broker 回应并投递相应队列中的消息，消费者接收消息。 (4)消费者确认(ack) 接收到的消息。 (5)RabbitMQ 从队列中删除相应己经被确认的消息。 (6)关闭信道。 (7)关闭连接。</p><h2 id="操作" tabindex="-1"><a class="header-anchor" href="#操作"><span>操作</span></a></h2><h3 id="创建死信队列" tabindex="-1"><a class="header-anchor" href="#创建死信队列"><span>创建死信队列</span></a></h3><p>在 RabbitMQ 中创建死信队列的操作流程大概是：</p><ul><li>创建一个交换机作为死信交换机</li><li>在业务队列中配置 x-dead-letter-exchange 和 x-dead-letter-routing-key，将第一步的交换机设为业务队列的死信交换机</li><li>在死信交换机上创建队列，并监听此队列</li></ul>',17),c=[o];function s(d,h){return a(),t("div",null,c)}const m=e(l,[["render",s],["__file","rabbitmqsixin.html.vue"]]),b=JSON.parse('{"path":"/middleware/xiaoxiduilie/rabbitmq/kuozhan/rabbitmqsixin.html","title":"RabbitMQ死信","lang":"zh-CN","frontmatter":{"title":"RabbitMQ死信","lang":"zh-CN","date":"2023-04-01T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["middleware"],"tag":["无"],"filename":"rabbitmqsixin","slug":"mx8bo5","docsId":"29412087","description":"介绍 没有消费的消息叫做死信队列 生产者 --> 消息 --> 交换机 --> 队列 --> 变成死信 --> DLX交换机 -->队列 --> 消费者 概念 DLX Dead Letter Exchange 的缩写 DLX（Dead Letter Exchanges）死信交换，死信队列本身也是一个普通的消息队列，在创建队列的时候，通过设置一些关键参数...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/middleware/xiaoxiduilie/rabbitmq/kuozhan/rabbitmqsixin.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"RabbitMQ死信"}],["meta",{"property":"og:description","content":"介绍 没有消费的消息叫做死信队列 生产者 --> 消息 --> 交换机 --> 队列 --> 变成死信 --> DLX交换机 -->队列 --> 消费者 概念 DLX Dead Letter Exchange 的缩写 DLX（Dead Letter Exchanges）死信交换，死信队列本身也是一个普通的消息队列，在创建队列的时候，通过设置一些关键参数..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://azrng.gitee.io/kbms/kbms/common/1609400134093-42c4d987-18cf-4d59-82e0-732efed0c75b.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-10-19T14:00:28.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-04-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-10-19T14:00:28.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RabbitMQ死信\\",\\"image\\":[\\"https://azrng.gitee.io/kbms/kbms/common/1609400134093-42c4d987-18cf-4d59-82e0-732efed0c75b.png\\",\\"https://azrng.gitee.io/kbms/kbms/common/1609400134139-7ef0cc81-84a6-4978-bed8-42e25eab7955.png\\"],\\"datePublished\\":\\"2023-04-01T00:00:00.000Z\\",\\"dateModified\\":\\"2023-10-19T14:00:28.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"介绍","slug":"介绍","link":"#介绍","children":[]},{"level":2,"title":"概念","slug":"概念","link":"#概念","children":[{"level":3,"title":"DLX","slug":"dlx","link":"#dlx","children":[]},{"level":3,"title":"什么是死信","slug":"什么是死信","link":"#什么是死信","children":[]},{"level":3,"title":"什么是死信交换机","slug":"什么是死信交换机","link":"#什么是死信交换机","children":[]},{"level":3,"title":"什么是死信队列","slug":"什么是死信队列","link":"#什么是死信队列","children":[]}]},{"level":2,"title":"操作","slug":"操作","link":"#操作","children":[{"level":3,"title":"创建死信队列","slug":"创建死信队列","link":"#创建死信队列","children":[]}]}],"git":{"createdTime":1697724028000,"updatedTime":1697724028000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":1}]},"readingTime":{"minutes":3.32,"words":996},"filePathRelative":"middleware/xiaoxiduilie/rabbitmq/kuozhan/rabbitmqsixin.md","localizedDate":"2023年4月1日","excerpt":"<h2>介绍</h2>\\n<p>没有消费的消息叫做死信队列\\n生产者   --&gt;  消息 --&gt; 交换机  --&gt; 队列  --&gt; 变成死信  --&gt; DLX交换机 --&gt;队列 --&gt; 消费者</p>\\n<h2>概念</h2>\\n<h3>DLX</h3>\\n<p>Dead Letter Exchange 的缩写\\nDLX（Dead Letter Exchanges）死信交换，死信队列本身也是一个普通的消息队列，在创建队列的时候，通过设置一些关键参数，可以将一个普通的消息队列设置为死信队列，与其它消息队列不同的是，其入栈的消息根据入栈时指定的过期时间/被拒绝/超出队列长度被移除，依次被转发到指定的消息队列中进行二次处理。这样说法比较拗口，其原理就是死信队列内位于顶部的消息过期时，该消息将被马上发送到另外一个订阅者（消息队列）中。</p>","autoDesc":true}');export{m as comp,b as data};
