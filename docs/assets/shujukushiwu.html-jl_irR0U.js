import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,o as a,d as r}from"./app-HmxoaDfj.js";const n={},i=r('<h2 id="事务隔离级别" tabindex="-1"><a class="header-anchor" href="#事务隔离级别"><span>事务隔离级别</span></a></h2><h3 id="事务串行化" tabindex="-1"><a class="header-anchor" href="#事务串行化"><span>事务串行化</span></a></h3><h3 id="可重复读" tabindex="-1"><a class="header-anchor" href="#可重复读"><span>可重复读</span></a></h3><p>repeatable read：可重复读隔离级别下开启一个事务，这个事务在事务开启的时候申请到了一次快照，在这个事务的所有查询都是用这个快照，即使当前事务前的事务提交了修改操作，对当前事务中的查询也没有任何影响，读到的结果都是一样的。</p><h3 id="读已提交" tabindex="-1"><a class="header-anchor" href="#读已提交"><span>读已提交</span></a></h3><p>read committed：读一提交隔离级别下开启一个事务，这个事务之前的事务对它来说都是可见的(不包括活跃事务)，活跃事务中的活跃元组提交后对它来说是可见的。当活跃事务提交后，当前事务中的查询语句在执行前会先申请快照，就能查到那些活跃事务中修改的记录，而这个事务之后的事务对当前事务来说都是不可见的。 在此说下幻读： 当在一个活跃事务中插入记录并提交，而另一个事务删除了这条插入的记录并提交时，在当前事务中就看到了不同的结果，像是发生了幻觉，这叫幻读。</p><h2 id="读未提交" tabindex="-1"><a class="header-anchor" href="#读未提交"><span>读未提交</span></a></h2>',7),s=[i];function o(l,h){return a(),t("div",null,s)}const c=e(n,[["render",o],["__file","shujukushiwu.html.vue"]]),m=JSON.parse('{"path":"/dataBase/postgresql/shujukushiwu.html","title":"数据库事务","lang":"zh-CN","frontmatter":{"title":"数据库事务","lang":"zh-CN","date":"2023-08-29T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["dataBase"],"tag":["无"],"filename":"shujukushiwu","slug":"syd563d59fawezaa","docsId":"113725658","description":"事务隔离级别 事务串行化 可重复读 repeatable read：可重复读隔离级别下开启一个事务，这个事务在事务开启的时候申请到了一次快照，在这个事务的所有查询都是用这个快照，即使当前事务前的事务提交了修改操作，对当前事务中的查询也没有任何影响，读到的结果都是一样的。 读已提交 read committed：读一提交隔离级别下开启一个事务，这个事务之...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dataBase/postgresql/shujukushiwu.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"数据库事务"}],["meta",{"property":"og:description","content":"事务隔离级别 事务串行化 可重复读 repeatable read：可重复读隔离级别下开启一个事务，这个事务在事务开启的时候申请到了一次快照，在这个事务的所有查询都是用这个快照，即使当前事务前的事务提交了修改操作，对当前事务中的查询也没有任何影响，读到的结果都是一样的。 读已提交 read committed：读一提交隔离级别下开启一个事务，这个事务之..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-09-23T15:53:24.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-08-29T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-09-23T15:53:24.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"数据库事务\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-08-29T00:00:00.000Z\\",\\"dateModified\\":\\"2023-09-23T15:53:24.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"事务隔离级别","slug":"事务隔离级别","link":"#事务隔离级别","children":[{"level":3,"title":"事务串行化","slug":"事务串行化","link":"#事务串行化","children":[]},{"level":3,"title":"可重复读","slug":"可重复读","link":"#可重复读","children":[]},{"level":3,"title":"读已提交","slug":"读已提交","link":"#读已提交","children":[]}]},{"level":2,"title":"读未提交","slug":"读未提交","link":"#读未提交","children":[]}],"git":{"createdTime":1695484404000,"updatedTime":1695484404000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":1}]},"readingTime":{"minutes":1.16,"words":347},"filePathRelative":"dataBase/postgresql/shujukushiwu.md","localizedDate":"2023年8月29日","excerpt":"<h2>事务隔离级别</h2>\\n<h3>事务串行化</h3>\\n<h3>可重复读</h3>\\n<p>repeatable read：可重复读隔离级别下开启一个事务，这个事务在事务开启的时候申请到了一次快照，在这个事务的所有查询都是用这个快照，即使当前事务前的事务提交了修改操作，对当前事务中的查询也没有任何影响，读到的结果都是一样的。</p>\\n<h3>读已提交</h3>\\n<p>read committed：读一提交隔离级别下开启一个事务，这个事务之前的事务对它来说都是可见的(不包括活跃事务)，活跃事务中的活跃元组提交后对它来说是可见的。当活跃事务提交后，当前事务中的查询语句在执行前会先申请快照，就能查到那些活跃事务中修改的记录，而这个事务之后的事务对当前事务来说都是不可见的。\\n在此说下幻读：\\n当在一个活跃事务中插入记录并提交，而另一个事务删除了这条插入的记录并提交时，在当前事务中就看到了不同的结果，像是发生了幻觉，这叫幻读。</p>","autoDesc":true}');export{c as comp,m as data};
