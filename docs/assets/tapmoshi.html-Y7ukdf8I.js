import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as c,c as l,a as s,d as n,e as t,b as e}from"./app-Bw62I61B.js";const i="/kbms/common/1622078328301-f0e28dc1-9dbe-4359-b144-d00269bf0b4c.webp",u="/kbms/common/1677077797920-bedf58c6-47f4-4219-b3bf-0f7c4d458cdf.png",r={},k=e(`<h2 id="描述" tabindex="-1"><a class="header-anchor" href="#描述"><span>描述</span></a></h2><ul><li>async和await关键字可以让你写出来和同步代码一样简洁且结构相同的异步代码。</li><li>await关键字简化了附加Continuation的过程</li><li>async修饰符会让编译器把await当作关键字而不是标识符(c#5以前可能会使用await作为标识符)</li><li>async修饰符只能作用于方法(包括lambda表达式) <ul><li>该方法可以返回void、Task、<code>Task&lt;TResult&gt;</code></li></ul></li><li>async修饰符对方法的签名或者public元数据没有影响，它只会影响方法内部 <ul><li>在接口内使用async是没有意义的</li><li>使用async来重载非async的方法却是合理的(只要方法签名一致)</li></ul></li><li>在C#中只要类包含GetAwaiter() 方法和bool IsCompleted属性，并且GetAwaiter()的返回值包含 GetResult()方法、bool IsCompleted属性和实现了 INotifyCompletion接口，那么这个类的实例就是可以await 的</li></ul><p>无论方法是同步还是异步都可以用async关键字来进行标识，因为用async标识只是显示表明在该方法内可能会用到await关键字使其变为异步方法，而且将该异步方法进行了明确的划分，只有用了await关键字时才是异步操作，其余一并为同步操作。</p><p>用async标识方法并不会影响方法运行完成是否是同步或者异步，相反，它能够将方法划分成多块，有可能有些在异步中运行，以至于这些方法是异步完成的，而划分异步和同步方法的边界就是使用await关键字。也就是说如果在方法中未用到await关键字时则该方法就是一整块没有所谓的划分，会在同步中运行，在同步中完成。</p><h2 id="示例" tabindex="-1"><a class="header-anchor" href="#示例"><span>示例</span></a></h2><p>await包含等待的意思，不过他的等待是挂起，而不是阻塞，在等待的时候，cpu可以去做其他事情。</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">var</span></span> result <span class="token operator">=</span> <span class="token keyword">await</span> Task<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
<span class="token punctuation">{</span>
    <span class="token keyword">await</span> Task<span class="token punctuation">.</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token string">&quot;success&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//作用相当于</span>

<span class="token class-name"><span class="token keyword">var</span></span> task <span class="token operator">=</span> Task<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
<span class="token punctuation">{</span>
    <span class="token keyword">await</span> Task<span class="token punctuation">.</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token string">&quot;success&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">var</span></span> awaiter <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">GetAwaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
awaiter<span class="token punctuation">.</span><span class="token function">OnCompleted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword">var</span></span> <span class="token keyword">value</span> <span class="token operator">=</span> awaiter<span class="token punctuation">.</span><span class="token function">GetResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>异步动作时在状态机中完成，当执行到这里时，编译器会自动生成代码来检测该动作是否已经完成，如果已经完成则继续同步执行await关键字后面的代码，通过判断其状态机状态若未完成则会挂起一个继续的委托为await关键字的对象直到完成为止，调用这个继续动作的委托重新进入未完成的这样一个方法。</p><h2 id="工作机制" tabindex="-1"><a class="header-anchor" href="#工作机制"><span>工作机制</span></a></h2><p>微软提出Task线程包装类、 await/async语法糖简化了异步编程的方式：</p><ul><li>遇到await表达式，执行(正常情况下)返回给调用者 <ul><li>就像iterator里面的yield return</li><li>在返回前，运行时会附件一个continuation到await的task <ul><li>为保证task结束时候，执行会跳转会原始方法，从停止的地址继续执行。</li></ul></li><li>如果发生故障，那么异常会被重新抛出</li><li>如果一切正常，那么它的返回值就会被赋值给await表达式</li></ul></li></ul><p><img src="`+i+'" alt="" loading="lazy"> 第②步：调用异步方法GetStringAsync时，开启异步任务； 第⑥步：遇到await关键字，框架会捕获调用线程的同步上下文(<code>SynchronizationContext</code>)对象, 附加给异步任务；同时控制权上交到上层调用函数； 第⑦步：异步任务完成，通过IO完成端口通知上层线程， 第⑧步：通过捕获的线程同步上下文执行后继代码块；</p>',12),d={href:"https://mp.weixin.qq.com/s/eefBRr2wVOb8jC-elIVJvA",target:"_blank",rel:"noopener noreferrer"},v=e(`<p>.NET 6.0 中的 await 原理浅析 https://www.cnblogs.com/broadm/p/17833442.html</p><h2 id="await之后的执行线程" tabindex="-1"><a class="header-anchor" href="#await之后的执行线程"><span>await之后的执行线程</span></a></h2><ul><li>在await表达式之后，编译器依赖continuation(通过awaiter模式)来继续执行</li><li>如果在富客户端应用的UI线程上，同步上下文会保证后续是在原始线程上执行</li><li>否则，就会在task结束的线程上继续执行</li></ul><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span>CurrentThread<span class="token punctuation">.</span>ManagedThreadId<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">await</span> File<span class="token punctuation">.</span><span class="token function">WriteAllTextAsync</span><span class="token punctuation">(</span><span class="token string">@&quot;D:\\docs\\1.txt&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Hello World!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span>CurrentThread<span class="token punctuation">.</span>ManagedThreadId<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">await</span> File<span class="token punctuation">.</span><span class="token function">ReadAllTextAsync</span><span class="token punctuation">(</span><span class="token string">@&quot;D:\\docs\\1.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span>CurrentThread<span class="token punctuation">.</span>ManagedThreadId<span class="token punctuation">)</span><span class="token punctuation">;</span>

输出结果：
<span class="token number">1</span>
<span class="token number">9</span>
<span class="token number">6</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>总结：在遇到await等待的时候，当前线程归还线程池，等异步方法执行结束的时候，再次从 线程池取一个出来执行后续的代码，这个新取出来的线程可能是刚才归还的线程。如果异步方法耗时比较短，这个后续的线程还是当前线程(因为到等待的时候发现已经执行结束了，那么就没必要再切换线程了，后续还在当前线程上执行)。</p></blockquote><h2 id="async-await语法糖的底层原理" tabindex="-1"><a class="header-anchor" href="#async-await语法糖的底层原理"><span>async/await语法糖的底层原理</span></a></h2><p>async/await只是编辑器提供的语法糖，它不是一种新的异步模型，只是一种简化异步代码编写的方式。从反编译的代码后来看，对于async/await的方法编译器会新生成一个实现了IAsyncStateMachine接口的状态机类。</p><ul><li>IAsyncStateMachine接口定义：</li></ul><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IAsyncStateMachine</span>
<span class="token punctuation">{</span>
    <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">MoveNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SetStateMachine</span><span class="token punctuation">(</span><span class="token class-name">IAsyncStateMachine</span> stateMachine<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>AsyncStateMachine实现类的基本执行步骤 <ul><li>初始化一个异步状态机machine</li><li>初始化一个asyncTaskMethodBuilder的实例，赋予machine.Builder</li><li>设置异步状态机的状态为-1，将类接入状态机的内部</li><li>调用machine.builder的Start方法</li><li>返回machine.builder.Task</li></ul></li></ul><figure><img src="`+u+`" alt="a8e969df08f79ea9253a0a051c8264b0.png" tabindex="0" loading="lazy"><figcaption>a8e969df08f79ea9253a0a051c8264b0.png</figcaption></figure><h2 id="有些异步方法没有async和await" tabindex="-1"><a class="header-anchor" href="#有些异步方法没有async和await"><span>有些异步方法没有async和await</span></a></h2><p>对于async方法，编译器会把代码根据await调用分成若干片段，然后对不同的片段采用状态机的方式切换执行，不过有些时候这个语法糖反而是一个负担</p><p>方法举例</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">await</span> System<span class="token punctuation">.</span>IO<span class="token punctuation">.</span>File<span class="token punctuation">.</span><span class="token function">WriteAllTextAsync</span><span class="token punctuation">(</span><span class="token string">&quot;d:/aa.txt&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;aaaa&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">await</span> System<span class="token punctuation">.</span>IO<span class="token punctuation">.</span>File<span class="token punctuation">.</span><span class="token function">WriteAllTextAsync</span><span class="token punctuation">(</span><span class="token string">&quot;d:/bb.txt&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;aaaa&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">await</span> System<span class="token punctuation">.</span>IO<span class="token punctuation">.</span>File<span class="token punctuation">.</span><span class="token function">WriteAllTextAsync</span><span class="token punctuation">(</span><span class="token string">&quot;d:/cc.txt&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;aaaa&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>生成的实际代码是</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token operator">&lt;</span>Main<span class="token operator">&gt;</span><span class="token class-name">d__4</span> stateMachine <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token operator">&lt;</span>Main<span class="token operator">&gt;</span>d__4 <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stateMachine<span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>t__builder <span class="token operator">=</span> AsyncTaskMethodBuilder<span class="token punctuation">.</span>Create <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stateMachine<span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>4__this <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
stateMachine<span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>1__state <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
stateMachine<span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>t__builder<span class="token punctuation">.</span>Start <span class="token punctuation">(</span><span class="token keyword">ref</span> stateMachine<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> stateMachine<span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>t__builder<span class="token punctuation">.</span>Task<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>生成的<code>&lt;Main&gt;</code>d__4类内容为</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">int</span></span> num <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span>1__state<span class="token punctuation">;</span>
<span class="token keyword">try</span>
<span class="token punctuation">{</span>
	<span class="token class-name">TaskAwaiter</span> awaiter3<span class="token punctuation">;</span>
	<span class="token class-name">TaskAwaiter</span> awaiter2<span class="token punctuation">;</span>
	<span class="token class-name">TaskAwaiter</span> awaiter<span class="token punctuation">;</span>
	<span class="token keyword">switch</span> <span class="token punctuation">(</span>num<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		 <span class="token keyword">default</span><span class="token punctuation">:</span>
			  awaiter3 <span class="token operator">=</span> File<span class="token punctuation">.</span>WriteAllTextAsync <span class="token punctuation">(</span><span class="token string">&quot;d:/aa.txt&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;aaaa&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>GetAwaiter <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>awaiter3<span class="token punctuation">.</span>IsCompleted<span class="token punctuation">)</span>
			  <span class="token punctuation">{</span>
				   num <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>1__state <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				   <span class="token operator">&lt;</span><span class="token operator">&gt;</span>u__1 <span class="token operator">=</span> awaiter3<span class="token punctuation">;</span>
				   <span class="token operator">&lt;</span>Main<span class="token operator">&gt;</span><span class="token class-name">d__4</span> stateMachine <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
				   <span class="token operator">&lt;</span><span class="token operator">&gt;</span>t__builder<span class="token punctuation">.</span>AwaitUnsafeOnCompleted <span class="token punctuation">(</span><span class="token keyword">ref</span> awaiter3<span class="token punctuation">,</span> <span class="token keyword">ref</span> stateMachine<span class="token punctuation">)</span><span class="token punctuation">;</span>
				   <span class="token keyword">return</span><span class="token punctuation">;</span>
			  <span class="token punctuation">}</span>
			  <span class="token keyword">goto</span> IL_0092<span class="token punctuation">;</span>
		 <span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span>
			  awaiter3 <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span>u__1<span class="token punctuation">;</span>
			  <span class="token operator">&lt;</span><span class="token operator">&gt;</span>u__1 <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">(</span><span class="token type-expression class-name">TaskAwaiter</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			  num <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>1__state <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			  <span class="token keyword">goto</span> IL_0092<span class="token punctuation">;</span>
		 <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>
			  awaiter2 <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span>u__1<span class="token punctuation">;</span>
			  <span class="token operator">&lt;</span><span class="token operator">&gt;</span>u__1 <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">(</span><span class="token type-expression class-name">TaskAwaiter</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			  num <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>1__state <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			  <span class="token keyword">goto</span> IL_0107<span class="token punctuation">;</span>
		 <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>
			  <span class="token punctuation">{</span>
				   awaiter <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span>u__1<span class="token punctuation">;</span>
				   <span class="token operator">&lt;</span><span class="token operator">&gt;</span>u__1 <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">(</span><span class="token type-expression class-name">TaskAwaiter</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				   num <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>1__state <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				   <span class="token keyword">break</span><span class="token punctuation">;</span>
			  <span class="token punctuation">}</span>
			  IL_0107<span class="token punctuation">:</span>
			  awaiter2<span class="token punctuation">.</span>GetResult <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			  awaiter <span class="token operator">=</span> File<span class="token punctuation">.</span>WriteAllTextAsync <span class="token punctuation">(</span><span class="token string">&quot;d:/cc.txt&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;aaaa&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>GetAwaiter <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>awaiter<span class="token punctuation">.</span>IsCompleted<span class="token punctuation">)</span>
			  <span class="token punctuation">{</span>
				   num <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>1__state <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				   <span class="token operator">&lt;</span><span class="token operator">&gt;</span>u__1 <span class="token operator">=</span> awaiter<span class="token punctuation">;</span>
				   <span class="token operator">&lt;</span>Main<span class="token operator">&gt;</span><span class="token class-name">d__4</span> stateMachine <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
				   <span class="token operator">&lt;</span><span class="token operator">&gt;</span>t__builder<span class="token punctuation">.</span>AwaitUnsafeOnCompleted <span class="token punctuation">(</span><span class="token keyword">ref</span> awaiter<span class="token punctuation">,</span> <span class="token keyword">ref</span> stateMachine<span class="token punctuation">)</span><span class="token punctuation">;</span>
				   <span class="token keyword">return</span><span class="token punctuation">;</span>
			  <span class="token punctuation">}</span>
			  <span class="token keyword">break</span><span class="token punctuation">;</span>
			  IL_0092<span class="token punctuation">:</span>
			  awaiter3<span class="token punctuation">.</span>GetResult <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			  awaiter2 <span class="token operator">=</span> File<span class="token punctuation">.</span>WriteAllTextAsync <span class="token punctuation">(</span><span class="token string">&quot;d:/bb.txt&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;aaaa&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>GetAwaiter <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>awaiter2<span class="token punctuation">.</span>IsCompleted<span class="token punctuation">)</span>
			  <span class="token punctuation">{</span>
				   num <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>1__state <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				   <span class="token operator">&lt;</span><span class="token operator">&gt;</span>u__1 <span class="token operator">=</span> awaiter2<span class="token punctuation">;</span>
				   <span class="token operator">&lt;</span>Main<span class="token operator">&gt;</span><span class="token class-name">d__4</span> stateMachine <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
				   <span class="token operator">&lt;</span><span class="token operator">&gt;</span>t__builder<span class="token punctuation">.</span>AwaitUnsafeOnCompleted <span class="token punctuation">(</span><span class="token keyword">ref</span> awaiter2<span class="token punctuation">,</span> <span class="token keyword">ref</span> stateMachine<span class="token punctuation">)</span><span class="token punctuation">;</span>
				   <span class="token keyword">return</span><span class="token punctuation">;</span>
			  <span class="token punctuation">}</span>
			  <span class="token keyword">goto</span> IL_0107<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	awaiter<span class="token punctuation">.</span>GetResult <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> exception<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token operator">&lt;</span><span class="token operator">&gt;</span>1__state <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token operator">&lt;</span><span class="token operator">&gt;</span>t__builder<span class="token punctuation">.</span>SetException <span class="token punctuation">(</span>exception<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">&gt;</span>1__state <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">&gt;</span>t__builder<span class="token punctuation">.</span>SetResult <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当有些方法只是简单的调用一个异步方法，那么就可以去掉async和await关键字。因为你方法加了async，他会把这点编译成一个类，然后涉及类的实例化等操作，所以有些方法我们可以这么写</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestService</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">await</span> <span class="token function">NantokaAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token return-type class-name">ValueTask</span> <span class="token function">NantokaAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 异步写入文件</span>
        <span class="token class-name"><span class="token keyword">var</span></span> message <span class="token operator">=</span> <span class="token string">&quot;Hello!&quot;</span><span class="token punctuation">;</span>

        <span class="token comment">// 这里不加await并且返回不加async</span>
        <span class="token keyword">return</span> <span class="token function">WriteAsync</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">async</span> <span class="token return-type class-name">ValueTask</span> <span class="token function">WriteAsync</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> message<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">await</span> Task<span class="token punctuation">.</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;WriteAsync: </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">message</span><span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是有些情况await和async又是不可以省略的，会存在一些陷阱，比如下面不加await就可能会导致异常</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestService</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">await</span> <span class="token function">NantokaAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">ValueTask</span> <span class="token function">NantokaAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name"><span class="token keyword">var</span></span> message <span class="token operator">=</span> <span class="token string">&quot;Hello Konnichiwa!&quot;</span><span class="token punctuation">;</span>

        <span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> conn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">NanikaConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment">// 如果这里不加await，会导致错误，因为作用域问题，释放了不应该释放的NanikaConnection</span>
            <span class="token keyword">return</span> <span class="token function">WriteAsync</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">async</span> <span class="token return-type class-name">ValueTask</span> <span class="token function">WriteAsync</span><span class="token punctuation">(</span><span class="token class-name">NanikaConnection</span> conn<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> message<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">await</span> Task<span class="token punctuation">.</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">await</span> conn<span class="token punctuation">.</span><span class="token function">WriteAsync</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NanikaConnection</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IDisposable</span></span>
    <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">bool</span></span> _disposed<span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">WriteAsync</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> message<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>_disposed<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ObjectDisposedException</span><span class="token punctuation">(</span><span class="token keyword">nameof</span><span class="token punctuation">(</span>NanikaConnection<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;NanikaConnection.WriteAsync: </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">message</span><span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;NanikaConnection.Dispose&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            _disposed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还可能存在其他问题，比如</p><ul><li>当你没有await，然后调用方那边发现错误的时候，堆栈跟踪中会缺少调用的堆栈</li><li>还会引起AsyncLocal泄露</li></ul>`,25),m={href:"https://zenn.dev/mayuki/articles/96a17916096714",target:"_blank",rel:"noopener noreferrer"},b=e(`<h2 id="编写异步函数" tabindex="-1"><a class="header-anchor" href="#编写异步函数"><span>编写异步函数</span></a></h2><ul><li>对于任何异步函数，你可以使用Task替代void作为返回类型，让该方法称为更有效的异步(可以进行await)</li><li>并不需要在方法的返回体中显式返回Task。编译器会生成一个Task(当方法完成或者发生异常时候)，这使得创建异步的调用链非常方便。</li></ul><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">static</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">string</span><span class="token punctuation">&gt;</span></span> <span class="token function">Go</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">await</span> Task<span class="token punctuation">.</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token string">&quot;success&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>编译器会对返回Task的异步函数进行扩展，使其成为当发送信息或者发生故障时使用TaskCompletionSource来创建Task的代码。</li></ul><p><strong>.NET 4.5开始提供的async/await，本质是.NET 4.0的Task + 状态机</strong><strong>.NET 4.0开始提供的Task，本质是.NET 3.5提供的Thread+ThreadPool+等待/取消等API操作</strong></p><h2 id="优化同步完成" tabindex="-1"><a class="header-anchor" href="#优化同步完成"><span>优化同步完成</span></a></h2><ul><li>异步函数可以在await之前就返回</li></ul><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">var</span></span> result <span class="token operator">=</span> <span class="token function">Go</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">string</span><span class="token punctuation">&gt;</span></span> <span class="token function">Go</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> id<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword">var</span></span> name <span class="token operator">=</span> _cache<span class="token punctuation">.</span><span class="token function">GetValue</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>name <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">await</span> _userInfo<span class="token punctuation">.</span><span class="token function">GetName</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>如果URI在缓存中存在，那么就不会有await发生，执行者就会返回给调用者，方法会返回一个已经设置信号的Task，这就是同步完成。</li><li>当await同步完成Task时候，执行不会返回到调用者，也不会通过Continuation调回。它会立即执行到下个语句。 <ul><li>编译器是通过检查awaiter上的IsCompleted属性来实现这个优化的，当你await的时候执行完成awaiter.IsCompleted为true，否则直接输出</li></ul></li></ul><h3 id="使用result方法死锁" tabindex="-1"><a class="header-anchor" href="#使用result方法死锁"><span>使用Result方法死锁</span></a></h3><ul><li>慎用Result <ul><li>场景1：带有同步上下文的编程模型中可能会出现死锁 <ul><li>例如：winform、wpf</li></ul></li><li>场景2：同步+异步场景中也可能会出现死锁 <ul><li>result=》同步等待，其实已经违背了异步编程的初心。</li><li>同步+异步混用会异常复杂，产生的bug不易被发现</li><li>比如在winform下，同步调用异步方法(task.GetResult())时候，async的callback进入了Quene，而主线程需要不断读取Quene的内容来执行，就容易造成死锁</li><li>为啥会出现死锁 <ul><li>主线程要结束阻塞，必须要等待延续Task执行完毕</li><li>延续Task要执行完毕，必须要主线程从Quene中调取执行</li></ul></li></ul></li></ul></li><li>解决方案 <ul><li>不使用同步上下文，比如WindowsFormSynchronizationContext，在自己的IO线程中完成，就没有所谓的Quene了</li></ul></li></ul><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">var</span></span> content <span class="token operator">=</span> <span class="token keyword">await</span> client
  <span class="token punctuation">.</span><span class="token function">GetStringAsync</span><span class="token punctuation">(</span><span class="token string">&quot;http://cnblogs.com&quot;</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">ConfigureAwait</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>不阻塞主线程 <ul><li>适用我们熟知的async+await</li></ul></li><li>使用线程池完成</li></ul><p>用线程池中的thread执行（比如：Task.Run），不用 main thread</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code>
<span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">button1_Click</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> sender<span class="token punctuation">,</span> <span class="token class-name">EventArgs</span> e<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token class-name"><span class="token keyword">var</span></span> task <span class="token operator">=</span> Task<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
   <span class="token punctuation">{</span>
       <span class="token class-name"><span class="token keyword">var</span></span> content <span class="token operator">=</span> <span class="token function">GetContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Result<span class="token punctuation">;</span>

       <span class="token keyword">return</span> content<span class="token punctuation">;</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

   textBox1<span class="token punctuation">.</span>Text <span class="token operator">=</span> task<span class="token punctuation">.</span>Result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="configureawait" tabindex="-1"><a class="header-anchor" href="#configureawait"><span>ConfigureAwait</span></a></h2><p>ConfigureAwait方法仅仅是一个返回结构体(ConfiguredTaskAwaitable)的方法，该结构体包装调用它的原始任务以及调用者指定的布尔值。 当使用async/await得时候，默认情况下得到结果后它需要在开始请求的原始线程上继续运行，如果当另一个长时间运行得进程已经接管了该线程，那么你就不得不等待它完成。要避免这个问题，可以使用ConfigureAwait的方法和false参数，当你使用该方法时候，可以告诉Task它可以在任何可用的线程上恢复自己继续运行，而不是等待最初创建它的线程，这可以加快响应速度并且避免死锁。</p><blockquote><p>AspNetSynchronizationContext维护了HttpContext.Current、用户身份和文化，但在ASP. NET Core这些信息天然依赖注入，故不再需要SynchronizationContext；另一个好处是不再获取同步上下文对性能也是一种提升。因此，对于ASP.NET Core程序，ConfigureAwait(false)不是必需的，然而，在基础库时最好还是使用ConfigureAwait(false)，因为你保不准上层会混用同步/异步代码。</p></blockquote><ul><li>ConfigureAwait(bool)：true(默认处理方式)  表示尝试在捕获的原调用线程SynchronizationContext 中执行后继代码；</li><li>ConfigureAwait(bool)：false 不再尝试在捕获原调用线程SynchronizationContext中执行后继代码。 ConfigureAwait(false)  能解决<code>因调用线程同步阻塞</code>引发的死锁，但是同步阻塞没有利用异步编程的优点。 <ul><li>不用再等在原始上下文或调度程序中进行回调。</li><li>避免死锁。假如有一个方法，使用await等待网络下载结果，你需要通过同步阻塞的方式调用该方法等待其完成，比如使用.Wait()、.Result或.GetAwaiter().GetResult()。思考一下，如果限制当前SynchronizationContext并发数为1，会发生什么情况？方式不限，无论是显式地通过类似于前面所说的MaxConcurrencySynchronizationContext的方式，还是隐式地通过仅具有一个可以使用的线程的上下文来实现，例如UI线程，你都可以在那个线程上调用该方法并阻塞它等待操作完成，该操作将开启网络下载并等待。在默认情况下， 等待Task会捕获当前SynchronizationContext，所以，当网络下载完成时，它会将回调排队返回到SynchronizationContext中执行剩下的操作。但是，当前唯一可以处理排队回调的线程却还被你阻塞着等待操作完成，不幸的是，在回调处理完毕之前，该操作永远不会完成。完蛋，死锁了！</li></ul></li></ul><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点</span></a></h3><p>当在另一个线程上继续时候，线程同步上下文将丢失，然后会失去归属于线程的Culture和Language，其中包含了国家语言时区信息，以及来自原始线程的HttpContext Current之类的信息，因此当不需要这些信息的时候，可以使用CongifureAwait该方法的调用。</p><blockquote><p>注意：如果需要language/culture，可以始终在await之前存储当前相关状态值，然后在await新线程之后重新应用它。</p></blockquote><h3 id="防止卡死的场景" tabindex="-1"><a class="header-anchor" href="#防止卡死的场景"><span>防止卡死的场景</span></a></h3><p>在使用async/await关键字时，应该尽可能使用ConfigureAwait(false)方法，这个方法可以让异步操作不必恢复到原始的SynchronizationContext上，从而减少线程切换的开销和提高性能。某些情况下，如果在异步操作完成后需要返回到原始的SynchronizationContext上，使用ConfigureAwait(false)会导致调用者无法正确处理结果。因此，建议仅在确定不需要返回到原始的SynchronizationContext上时才使用ConfigureAwait(false)方法。</p><p>示例代码：假设我们有一个控制台应用程序，其中有两个异步方法：MethodAAsync()和MethodBAsync()。MethodAAsync()会等待1秒钟，然后返回一个字符串。MethodBAsync()会等待2秒钟，然后返回一个字符串。代码如下所示：</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">async</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">string</span><span class="token punctuation">&gt;</span></span> <span class="token function">MethodAAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">await</span> Task<span class="token punctuation">.</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token interpolation-string"><span class="token string">$&quot;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">DateTime<span class="token punctuation">.</span>Now</span><span class="token format-string"><span class="token punctuation">:</span>ss.fff</span><span class="token punctuation">}</span></span><span class="token string">&gt;Hello&quot;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">async</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">string</span><span class="token punctuation">&gt;</span></span> <span class="token function">MethodBAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">await</span> Task<span class="token punctuation">.</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token interpolation-string"><span class="token string">$&quot;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">DateTime<span class="token punctuation">.</span>Now</span><span class="token format-string"><span class="token punctuation">:</span>ss.fff</span><span class="token punctuation">}</span></span><span class="token string">&gt;World&quot;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，我们想要同时调用这两个方法，并将它们的结果合并成一个字符串。我们可以像下面这样编写代码：</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">async</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">string</span><span class="token punctuation">&gt;</span></span> <span class="token function">CombineResultsAAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword">var</span></span> resultA <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">MethodAAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword">var</span></span> resultB <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">MethodBAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token interpolation-string"><span class="token string">$&quot;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">DateTime<span class="token punctuation">.</span>Now</span><span class="token format-string"><span class="token punctuation">:</span>yyyy-MM-dd HH:mm:ss.fff</span><span class="token punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">resultA</span><span class="token punctuation">}</span></span><span class="token string"> | </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">resultB</span><span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个代码看起来非常简单明了，但是它存在一个性能问题。当我们调用CombineResultsAAsync()方法时，第一个await操作将使执行上下文切换回原始SynchronizationContext（即主线程），因此我们的异步操作将在UI线程上运行。由于我们要等待1秒钟才能从MethodAAsync()中返回结果，因此UI线程将被阻塞，直到异步操作完成并且结果可用为止。 这种情况下，我们可以使用ConfigureAwait(false)方法来指定不需要保留当前上下文的线程执行状态，从而让异步操作在一个线程池线程上运行。这可以通过下面的代码实现：</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">async</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">string</span><span class="token punctuation">&gt;</span></span> <span class="token function">CombineResultsBAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword">var</span></span> resultA <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">MethodAAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ConfigureAwait</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword">var</span></span> resultB <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">MethodBAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ConfigureAwait</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token interpolation-string"><span class="token string">$&quot;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">DateTime<span class="token punctuation">.</span>Now</span><span class="token format-string"><span class="token punctuation">:</span>yyyy-MM-dd HH:mm:ss.fff</span><span class="token punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">resultA</span><span class="token punctuation">}</span></span><span class="token string"> | </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">resultB</span><span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过使用ConfigureAwait(false)方法，我们告诉异步操作不需要保留当前上下文的线程执行状态，这样异步操作就会在一个线程池线程上运行，而不是在UI线程上运行。这样做可以避免一些潜在的性能问题，因为我们的UI线程不会被阻塞，并且异步操作可以在一个新的线程池线程上运行。</p><h3 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项"><span>注意事项</span></a></h3><h4 id="同步方法调用异步方法" tabindex="-1"><a class="header-anchor" href="#同步方法调用异步方法"><span>同步方法调用异步方法</span></a></h4><p>如果要使用async/await，需要注意一些事情。您可能遇到的最大问题是处理异步方法请求同步方法。如果你开发一个新项目，通常可以将async/await从上到下贯穿于整个方法链中，而不需要做太多工作。但是，如果你在外层是同步的，并且必须调用异步库，那么就会出现一些有隐患的操作。如果一不小心，便会引发大批量的死锁。</p><p>如果有同步方法调用异步方法,则必须使用ConfigureAwait(false)。如果不这样做，就会立即掉进死锁陷阱。发生的情况是主线程将调用async方法，最终会阻塞这个线程，直到那个async方法完成。然而，一旦异步方法完成，它必须等待原始调用者完成后才能继续。他们都在等待对方完成，而且永远不会。通过在调用中使用configurewait (false)， async方法将能够在另一个线程上完成自己操作，而不关心自己的状态机的位置，并通知原始线程它已经完成。进行这个调用的最佳实践如下:</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code> <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">HttpPut</span></span><span class="token punctuation">]</span>
 <span class="token keyword">public</span> <span class="token return-type class-name">IActionResult</span> <span class="token function">Put</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">FromBody</span></span><span class="token punctuation">]</span><span class="token class-name">UpdateCommand</span> command<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
     _responseMediator<span class="token punctuation">.</span><span class="token function">ExecuteAsync</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ConfigureAwait</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetAwaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="net-standard与configureawait-false" tabindex="-1"><a class="header-anchor" href="#net-standard与configureawait-false"><span>.NET Standard与ConfigureAwait(false)</span></a></h4><p>在.NETCore中，微软删除了导致我们在任何地方都需要ConfigureAwait(false)的SynchronizationContext。因此，ASP.NETCore应用程序在技术上不需要任何ConfigureAwait(false)逻辑，因为它是多余的。但是，如果在开发有一个使用.NETStandard的库，那么强烈建议仍然使用.ConfigureAwait(false)。在.NETCore中，这自动是无效的。但是如果有.NETFramework的人最终使用这个库并同步调用它，那么它们将会遇到一堆麻烦。但是随着.NET5是由.NETCore构建的，所以未来大多都是.NetCore调用.Netstandard，你如果不准备让.NetFramework调用你的standard库，大可不必兼容。</p><h4 id="configureawait-false-贯穿始终" tabindex="-1"><a class="header-anchor" href="#configureawait-false-贯穿始终"><span>ConfigureAwait(false) 贯穿始终</span></a></h4><p>如果同步调用有可能调用您的异步方法，那么在整个调用堆栈的每个异步调用上，您都将被迫设置. configureAwait (false) 如果不这样做，就会导致另一个死锁。这里的问题是，每个async/ await对于调用它的当前方法都是本地的。因此，调用链的每个异async/await都可能最终在不同的线程上恢复。如果一个同步调用一路向下，遇到一个没有configurewait(false)的任务，那么这个任务将尝试等待顶部的原始线程完成，然后才能继续。虽然这最终会让你感到心累，因为要检查所有调用是否设置此属性。</p><h4 id="开销" tabindex="-1"><a class="header-anchor" href="#开销"><span>开销</span></a></h4><p>虽然async/ await可以极大地增加应用程序一次处理的请求数量，但是使用它是有代价的。每个async/ await调用最终都将创建一个小状态机来跟踪所有信息。虽然这个开销很小，但是如果滥用async/ await，则会导致速度变慢。只有当线程不得不等待结果时，才应该等待它。</p><h4 id="async-void" tabindex="-1"><a class="header-anchor" href="#async-void"><span>Async Void</span></a></h4><p>虽然几乎所有的async / await方法都应返回某种类型的Task，但此规则有一个例外：有时，您可以使用async void。但是，当您使用它时，调用者实际上不会等待该任务完成后才能恢复自己。它实际上是一种即发即忘的东西。有两种情况你想要使用它。    第一种情况是事件处理程序，如WPF或WinForms中的按钮单击。默认情况下，事件处理程序的定义必须为void。如果你把一个任务放在那里，程序将无法编译，并且返回某些东西的事件会感觉很奇怪。如果该按钮调用异步async，则必须执行async void才能使其正常工作。幸运的是，这是我们想要的，因为这种使用不会阻塞UI。   第二个是请求你不介意等待获得结果的东西。最常见的示例是发送日志邮件，但不想等待它完成或者不关心它是否完成。  然而，对于这两种情况，都有一些缺点。首先，调用方法不能try/catch调用中的任何异常。它最终将进入AppDomain UnhandledException事件。不过，如果在实际的async void方法中放入一个try catch，就可以有效地防止这种情况发生。另一个问题是调用者永远不会知道它何时结束，因为它不返回任何东西。因此，如果你关心什么时候完成某个Task，那么实际上需要返回一个Task。</p><h2 id="参考文档" tabindex="-1"><a class="header-anchor" href="#参考文档"><span>参考文档</span></a></h2>`,45),w={href:"https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/async/",target:"_blank",rel:"noopener noreferrer"},y={href:"https://mp.weixin.qq.com/s/CvpesplSFOcR2I_x5qkJSw",target:"_blank",rel:"noopener noreferrer"},g={href:"https://www.cnblogs.com/xiaoxiaotank/p/13529413.html",target:"_blank",rel:"noopener noreferrer"},h={href:"https://mp.weixin.qq.com/s/t5CTzpnJ7fakUSgRqvGE6w",target:"_blank",rel:"noopener noreferrer"},f={href:"https://mp.weixin.qq.com/s/OPnWHs1aArkBHZ8QALhV1g",target:"_blank",rel:"noopener noreferrer"},A={href:"https://devblogs.microsoft.com/dotnet-ch/async-await%e5%9c%a8-c%e8%af%ad%e8%a8%80%e4%b8%ad%e6%98%af%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c%e7%9a%84/",target:"_blank",rel:"noopener noreferrer"};function _(T,C){const a=o("ExternalLinkIcon");return c(),l("div",null,[k,s("blockquote",null,[s("p",null,[n("引用："),s("a",d,[n("https://mp.weixin.qq.com/s/eefBRr2wVOb8jC-elIVJvA"),t(a)])])]),v,s("p",null,[n("资料："),s("a",m,[n("https://zenn.dev/mayuki/articles/96a17916096714"),t(a)])]),b,s("p",null,[n("微软异步编程概述："),s("a",w,[n("https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/async/"),t(a)]),n(" 理解c#中的configureAwait："),s("a",y,[n("https://mp.weixin.qq.com/s/CvpesplSFOcR2I_x5qkJSw"),t(a)]),n(" / "),s("a",g,[n("https://www.cnblogs.com/xiaoxiaotank/p/13529413.html"),t(a)]),n(" 研究c#异步操作async await状态机的总结："),s("a",h,[n("https://mp.weixin.qq.com/s/t5CTzpnJ7fakUSgRqvGE6w"),t(a)]),n(" async/await 到底是如何工作的："),s("a",f,[n("https://mp.weixin.qq.com/s/OPnWHs1aArkBHZ8QALhV1g"),t(a)]),n(" Async/Await在 C#语言中是如何工作的："),s("a",A,[n("https://devblogs.microsoft.com/dotnet-ch/async-await%e5%9c%a8-c%e8%af%ad%e8%a8%80%e4%b8%ad%e6%98%af%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c%e7%9a%84/"),t(a)])])])}const M=p(r,[["render",_],["__file","tapmoshi.html.vue"]]),I=JSON.parse('{"path":"/dotnet/csharp/threadConcurrencyAndAsync/async/tapmoshi.html","title":"TAP模式","lang":"zh-CN","frontmatter":{"title":"TAP模式","lang":"zh-CN","date":"2023-11-12T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["csharp"],"tag":["无"],"filename":"tapmoshi","slug":"ifashs","docsId":"29634492","description":"描述 async和await关键字可以让你写出来和同步代码一样简洁且结构相同的异步代码。 await关键字简化了附加Continuation的过程 async修饰符会让编译器把await当作关键字而不是标识符(c#5以前可能会使用await作为标识符) async修饰符只能作用于方法(包括lambda表达式) 该方法可以返回void、Task、Task...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dotnet/csharp/threadConcurrencyAndAsync/async/tapmoshi.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"TAP模式"}],["meta",{"property":"og:description","content":"描述 async和await关键字可以让你写出来和同步代码一样简洁且结构相同的异步代码。 await关键字简化了附加Continuation的过程 async修饰符会让编译器把await当作关键字而不是标识符(c#5以前可能会使用await作为标识符) async修饰符只能作用于方法(包括lambda表达式) 该方法可以返回void、Task、Task..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://azrng.gitee.io/kbms/kbms/common/1622078328301-f0e28dc1-9dbe-4359-b144-d00269bf0b4c.webp"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-26T15:41:29.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-11-12T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-26T15:41:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"TAP模式\\",\\"image\\":[\\"https://azrng.gitee.io/kbms/kbms/common/1622078328301-f0e28dc1-9dbe-4359-b144-d00269bf0b4c.webp\\",\\"https://azrng.gitee.io/kbms/kbms/common/1677077797920-bedf58c6-47f4-4219-b3bf-0f7c4d458cdf.png\\"],\\"datePublished\\":\\"2023-11-12T00:00:00.000Z\\",\\"dateModified\\":\\"2024-03-26T15:41:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"描述","slug":"描述","link":"#描述","children":[]},{"level":2,"title":"示例","slug":"示例","link":"#示例","children":[]},{"level":2,"title":"工作机制","slug":"工作机制","link":"#工作机制","children":[]},{"level":2,"title":"await之后的执行线程","slug":"await之后的执行线程","link":"#await之后的执行线程","children":[]},{"level":2,"title":"async/await语法糖的底层原理","slug":"async-await语法糖的底层原理","link":"#async-await语法糖的底层原理","children":[]},{"level":2,"title":"有些异步方法没有async和await","slug":"有些异步方法没有async和await","link":"#有些异步方法没有async和await","children":[]},{"level":2,"title":"编写异步函数","slug":"编写异步函数","link":"#编写异步函数","children":[]},{"level":2,"title":"优化同步完成","slug":"优化同步完成","link":"#优化同步完成","children":[{"level":3,"title":"使用Result方法死锁","slug":"使用result方法死锁","link":"#使用result方法死锁","children":[]}]},{"level":2,"title":"ConfigureAwait","slug":"configureawait","link":"#configureawait","children":[{"level":3,"title":"缺点","slug":"缺点","link":"#缺点","children":[]},{"level":3,"title":"防止卡死的场景","slug":"防止卡死的场景","link":"#防止卡死的场景","children":[]},{"level":3,"title":"注意事项","slug":"注意事项","link":"#注意事项","children":[{"level":4,"title":"同步方法调用异步方法","slug":"同步方法调用异步方法","link":"#同步方法调用异步方法","children":[]},{"level":4,"title":".NET Standard与ConfigureAwait(false)","slug":"net-standard与configureawait-false","link":"#net-standard与configureawait-false","children":[]},{"level":4,"title":"ConfigureAwait(false) 贯穿始终","slug":"configureawait-false-贯穿始终","link":"#configureawait-false-贯穿始终","children":[]},{"level":4,"title":"开销","slug":"开销","link":"#开销","children":[]},{"level":4,"title":"Async Void","slug":"async-void","link":"#async-void","children":[]}]}]},{"level":2,"title":"参考文档","slug":"参考文档","link":"#参考文档","children":[]}],"git":{"createdTime":1700232644000,"updatedTime":1711467689000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":2}]},"readingTime":{"minutes":18,"words":5399},"filePathRelative":"dotnet/csharp/threadConcurrencyAndAsync/async/tapmoshi.md","localizedDate":"2023年11月12日","excerpt":"<h2>描述</h2>\\n<ul>\\n<li>async和await关键字可以让你写出来和同步代码一样简洁且结构相同的异步代码。</li>\\n<li>await关键字简化了附加Continuation的过程</li>\\n<li>async修饰符会让编译器把await当作关键字而不是标识符(c#5以前可能会使用await作为标识符)</li>\\n<li>async修饰符只能作用于方法(包括lambda表达式)\\n<ul>\\n<li>该方法可以返回void、Task、<code>Task&lt;TResult&gt;</code></li>\\n</ul>\\n</li>\\n<li>async修饰符对方法的签名或者public元数据没有影响，它只会影响方法内部\\n<ul>\\n<li>在接口内使用async是没有意义的</li>\\n<li>使用async来重载非async的方法却是合理的(只要方法签名一致)</li>\\n</ul>\\n</li>\\n<li>在C#中只要类包含GetAwaiter() 方法和bool IsCompleted属性，并且GetAwaiter()的返回值包含 GetResult()方法、bool IsCompleted属性和实现了 INotifyCompletion接口，那么这个类的实例就是可以await 的</li>\\n</ul>","autoDesc":true}');export{M as comp,I as data};
