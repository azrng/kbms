import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as s,d as t}from"./app-Bfb6-vFH.js";const a={},i=t(`<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>.Net调用RestAPI时候通常有三种选择，分别为：<code>WebClient, HttpWebRequest，HttpClient</code></p><ul><li><code>HttpWebRequest</code> 是一种相对底层的处理 Http request/response 的方式。</li><li><code>WebClient</code> 提供了对 HttpWebRequest 的高层封装，来简化使用者的调用。</li><li><code>HttpClient</code> 是一种新的处理 Http request/response 工具包，具有更高的性能。</li></ul><h2 id="httpwebrequest-不推荐" tabindex="-1"><a class="header-anchor" href="#httpwebrequest-不推荐"><span>HttpWebRequest(不推荐)</span></a></h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p>.NetCore中不使用该方法</p></div><p>WebRequest 是一种基于特定的 http 实现, 它是一个抽象类, 所以在处理 Reqeust 请求时底层会根据传进来的 url 生成相应的子类，如：HttpWebRequest 或 FileWebRequest ，下面的代码展示了如何使用 WebRequest。</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token class-name">WebRequest</span> webRequest <span class="token operator">=</span> WebRequest<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span>
webRequest<span class="token punctuation">.</span>Credentials <span class="token operator">=</span> CredentialCache<span class="token punctuation">.</span>DefaultCredentials<span class="token punctuation">;</span>
webRequest<span class="token punctuation">.</span>Method <span class="token operator">=</span><span class="token string">&quot;GET&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">HttpWebResponse</span> webResponse <span class="token operator">=</span> <span class="token punctuation">(</span>HttpWebResponse<span class="token punctuation">)</span>webRequest<span class="token punctuation">.</span><span class="token function">GetResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>WebRequest 是 .NET Framework 中第一个用来处理 Http 请求的类，在处理 <code>Http请求和响应</code> 方面给调用者提供了诸多的灵活性，你还可以使用这个类来存取 headers, cookies, protocols 和 timeouts 等等，下面的代码展示了其实现子类 HttpWebRequest 是如何使用的。</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token class-name">HttpWebRequest</span> http <span class="token operator">=</span> HttpWebRequest<span class="token punctuation">)</span>WebRequest<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span>“http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token punctuation">:</span><span class="token number">8900</span><span class="token operator">/</span>api<span class="token operator">/</span><span class="token keyword">default</span>”<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">WebResponse</span> response <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">GetResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">MemoryStream</span> memoryStream <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">GetResponseStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">StreamReader</span> streamReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StreamReader</span><span class="token punctuation">(</span>memoryStream<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">string</span></span> data <span class="token operator">=</span> streamReader<span class="token punctuation">.</span><span class="token function">ReadToEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="webclient-不推荐" tabindex="-1"><a class="header-anchor" href="#webclient-不推荐"><span>WebClient(不推荐)</span></a></h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p>.NetCore中不使用该方法</p></div><p>老版本的 .NET 由于没有方便的 HttpClient 存在，所以只能使用 WebClient 或借助第三方包进行 Web API 的调用。WebClient 是 HttpWebRequest 的高层封装，它给调用者提供了更便捷的使用方式，理所当然做出的牺牲就是 WebClient 的性能略逊于 HttpWebRequest，如果你的业务场景只是简单访问第三方的 Http Service，那么我建议你使用 WebClient ，同理如果你有更多的精细化配置则使用 HttpWebRequest</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">string</span></span> data <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

<span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> webClient <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">WebClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    data <span class="token operator">=</span> webClient<span class="token punctuation">.</span><span class="token function">DownloadString</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="get" tabindex="-1"><a class="header-anchor" href="#get"><span>Get</span></a></h3><div class="language-c# line-numbers-mode" data-ext="c#" data-title="c#"><pre class="language-c#"><code>using (var client = new WebClient())
{
    client.Headers[HttpRequestHeaders.Accept] = &quot;application/json&quot;;
    string result = client.DownloadString(&quot;http://example.com/values&quot;);
    // now use a JSON parser to parse the resulting string back to some CLR object
    var todo = JsonConvert.DeserializeObject&lt;Todo&gt;(result);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="put" tabindex="-1"><a class="header-anchor" href="#put"><span>Put</span></a></h3><div class="language-c# line-numbers-mode" data-ext="c#" data-title="c#"><pre class="language-c#"><code>string data = JsonConvert.SerializeObject(record);
try
{
    // 好像是因为官方 Headers 设置存在问题，所以没法把 Content-Type 和 Accept 放在一起初始化
    client.Headers[&quot;Content-Type&quot;] = &quot;application/json&quot;;
    client.UploadString(&quot;http://example.com/values&quot;, WebRequestMethods.Http.Put, data);
}
catch (WebException ex)
{
    Logger.Error(ex, $&quot;PUT failed data: {data}&quot;);
    throw;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="post" tabindex="-1"><a class="header-anchor" href="#post"><span>Post</span></a></h3><div class="language-c# line-numbers-mode" data-ext="c#" data-title="c#"><pre class="language-c#"><code>using (var client = new WebClient())
{
    client.Headers[HttpRequestHeader.ContentType] = &quot;application/json&quot;;
    client.Headers[HttpRequestHeader.Accept] = &quot;application/json&quot;;
    var data = Encoding.UTF8.GetBytes(&quot;{\\&quot;foo\\&quot;:\\&quot;bar\\&quot;}&quot;);
    byte[] result = client.UploadData(&quot;http://example.com/values&quot;, &quot;POST&quot;, data);
    string resultContent = Encoding.UTF8.GetString(result, 0, result.Length);        
    // now use a JSON parser to parse the resulting string back to some CLR object 
    var content = JsonConvert.DeserializeObject&lt;Content&gt;(resultContent);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="下载内容" tabindex="-1"><a class="header-anchor" href="#下载内容"><span>下载内容</span></a></h3><p>方式一</p><div class="language-c# line-numbers-mode" data-ext="c#" data-title="c#"><pre class="language-c#"><code>WebRequest wreq = WebRequest.Create(&quot;http://files.jb51.net/file_images/article/201205/logo.gif&quot;);
HttpWebResponse wresp = (HttpWebResponse)wreq.GetResponse();
Stream s = wresp.GetResponseStream();
System.Drawing.Image img;
img = System.Drawing.Image.FromStream(s);
//保存文件
img.Save(&quot;D:\\\\aa.gif&quot;, ImageFormat.Gif);
// 输出文件
MemoryStream ms = new MemoryStream();
img.Save(ms, ImageFormat.Gif);
img.Dispose();
Response.ClearContent();
Response.ContentType = &quot;image/gif&quot;;
Response.BinaryWrite(ms.ToArray());
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方式二</p><div class="language-c# line-numbers-mode" data-ext="c#" data-title="c#"><pre class="language-c#"><code>WebClient my = new WebClient();
byte[] mybyte;
mybyte = my.DownloadData(&quot;http://files.jb51.net/file_images/article/201205/logo.gif&quot;);
MemoryStream ms = new MemoryStream(mybyte);
System.Drawing.Image img;
img = System.Drawing.Image.FromStream(ms);
//保存
img.Save(&quot;D:\\\\a.gif&quot;, ImageFormat.Gif);
//下面直接输出
Response.ClearContent();
Response.ContentType = &quot;image/gif&quot;;
Response.BinaryWrite(mybyte);
如果是真实的图片地址直接该方法进行保存
my.DownloadFile(&quot;http://files.jb51.net/file_images/article/201205/logo.gif&quot;, &quot;D:\\\\a.gif&quot;);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="httpclient" tabindex="-1"><a class="header-anchor" href="#httpclient"><span>HttpClient</span></a></h2><p>HttpClient 是在 .NET Framework 4.5 中被引入的，如果你的项目是基于 .NET 4.5 以上版本，除一些特定的原因之外，建议你优先使用 HttpClient，本质上来说，HttpClient 作为后来之物，它吸取了 HttpWebRequest 的灵活性及 WebClient 的便捷性。</p><p>HttpWebRequest 在 <code>request/response</code> 对象上提供了非常精细化的配置，同时你也要注意 HttpClient 的出现并不是为了取代 WebClient，言外之意就是 HttpClient 也有缺点，比如说：不能提供 <code>进度处理</code> 和 <code>URI 定制</code>，不支持 FTP 等等，HttpClient 的优点也有很多，它所有关于 IO 操作的方法都是异步的，当然有特殊原因的话也可以使用同步方式</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">HttpClient</span> _client<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token function">WeatherForecastController</span><span class="token punctuation">(</span><span class="token class-name">IHttpClientFactory</span> httpClientFactory<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    _client <span class="token operator">=</span> httpClientFactory<span class="token punctuation">.</span><span class="token function">CreateClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">HttpGet</span></span><span class="token punctuation">]</span>
<span class="token keyword">public</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">string</span><span class="token punctuation">&gt;</span></span> <span class="token function">GetAuthorsAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">HttpResponseMessage</span> response <span class="token operator">=</span> <span class="token keyword">await</span> _client<span class="token punctuation">.</span><span class="token function">GetAsync</span><span class="token punctuation">(</span><span class="token string">&quot;https://www.baidu.com/&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    response<span class="token punctuation">.</span><span class="token function">EnsureSuccessStatusCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//response异常时候默认情况下不会抛出异常，通过改变该配置就可以</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>response<span class="token punctuation">.</span>IsSuccessStatusCode<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">await</span> response<span class="token punctuation">.</span>Content<span class="token punctuation">.</span><span class="token function">ReadAsStringAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>推荐的做法是保持 HttpClient 的单例化，如果不这么做的话，每次 Request 请求实例化一次 HttpClient ，那么大量的请求必将你的 socket 耗尽并抛出 <code>SocketException</code> 异常。NetCore中通过注入HttpClientFactory来创建HttpClient</p>`,29),p=[i];function l(o,c){return e(),s("div",null,p)}const d=n(a,[["render",l],["__file","httpRequest.html.vue"]]),m=JSON.parse('{"path":"/dotnet/api/remoteProcedureCall/httpRequest.html","title":"HTTP请求","lang":"zh-CN","frontmatter":{"title":"HTTP请求","lang":"zh-CN","date":"2023-10-27T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["dotNET"],"tag":["无"],"description":"前言 .Net调用RestAPI时候通常有三种选择，分别为：WebClient, HttpWebRequest，HttpClient HttpWebRequest 是一种相对底层的处理 Http request/response 的方式。 WebClient 提供了对 HttpWebRequest 的高层封装，来简化使用者的调用。 HttpClient...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dotnet/api/remoteProcedureCall/httpRequest.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"HTTP请求"}],["meta",{"property":"og:description","content":"前言 .Net调用RestAPI时候通常有三种选择，分别为：WebClient, HttpWebRequest，HttpClient HttpWebRequest 是一种相对底层的处理 Http request/response 的方式。 WebClient 提供了对 HttpWebRequest 的高层封装，来简化使用者的调用。 HttpClient..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-09T07:25:08.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-10-27T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-09T07:25:08.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"HTTP请求\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-10-27T00:00:00.000Z\\",\\"dateModified\\":\\"2024-03-09T07:25:08.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"HttpWebRequest(不推荐)","slug":"httpwebrequest-不推荐","link":"#httpwebrequest-不推荐","children":[]},{"level":2,"title":"WebClient(不推荐)","slug":"webclient-不推荐","link":"#webclient-不推荐","children":[{"level":3,"title":"Get","slug":"get","link":"#get","children":[]},{"level":3,"title":"Put","slug":"put","link":"#put","children":[]},{"level":3,"title":"Post","slug":"post","link":"#post","children":[]},{"level":3,"title":"下载内容","slug":"下载内容","link":"#下载内容","children":[]}]},{"level":2,"title":"HttpClient","slug":"httpclient","link":"#httpclient","children":[]}],"git":{"createdTime":1698414586000,"updatedTime":1709969108000,"contributors":[{"name":"zhangyunpeng","email":"zhang.yunpeng@synyi.com","commits":1}]},"readingTime":{"minutes":3.35,"words":1005},"filePathRelative":"dotnet/api/remoteProcedureCall/httpRequest.md","localizedDate":"2023年10月27日","excerpt":"<h2>前言</h2>\\n<p>.Net调用RestAPI时候通常有三种选择，分别为：<code>WebClient, HttpWebRequest，HttpClient</code></p>\\n<ul>\\n<li><code>HttpWebRequest</code> 是一种相对底层的处理 Http request/response 的方式。</li>\\n<li><code>WebClient</code> 提供了对 HttpWebRequest 的高层封装，来简化使用者的调用。</li>\\n<li><code>HttpClient</code> 是一种新的处理 Http request/response 工具包，具有更高的性能。</li>\\n</ul>","autoDesc":true}');export{d as comp,m as data};
