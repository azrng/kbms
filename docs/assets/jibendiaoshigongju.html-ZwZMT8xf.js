import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as l,o as s,c as r,b as e,e as o,f as n,d as t}from"./app-CBxp4zeL.js";const d="/kbms/common/1624800292646-5921ead7-6575-4f5a-9faf-8c3554b923e4.jpeg",c="/kbms/common/1624800292508-c697af76-7964-4933-b0dd-7c300f55391e.jpeg",p="/kbms/common/1624800292404-2b3ca874-3019-4fbf-9c7b-46dd879c832a.webp",m="/kbms/common/1624800292374-61fa2c6a-83fd-4195-ad12-1db7152bfdc5.webp",h="/kbms/common/1624800292397-a79bccd3-b8b9-45eb-967f-42c7dde3aaba.webp",g="/kbms/common/1624800292431-6b37f545-9693-48d3-87e8-b1b63cfa5afe.jpeg",u="/kbms/common/1624800292680-e4b2920a-c445-4fa2-afd3-10762f627e52.jpeg",b="/kbms/common/1624800292477-9c463d3b-e331-4ca4-8364-4cbcf6623249.webp",f="/kbms/common/1624800292510-35ccd212-2a9f-41bd-8606-f67d6feead65.webp",_="/kbms/common/1624800292561-218a1833-306e-42e9-8841-7689646a350e.jpeg",k="/kbms/common/1624800292675-4475b95f-4b34-492b-a151-f6f7c3d1ea2e.jpeg",y={},T=t('<h2 id="说明" tabindex="-1"><a class="header-anchor" href="#说明"><span>说明</span></a></h2><p>在调试软件时，工具非常重要。获取正确的工具，然后再调试时提取正确的信息。根据获取的正确的错误信息，可以找到问题的根源所在。找到问题根源所在，你就能够解决该错误了。 你将看到我认为最基本的解决在C## .NET 中错误问题的工具的列表。这些将帮助你找到任何难题的根本原因并加以解决。 除了代码中的常见问题外，一下工具还可以处理各种问题类型，包括：</p><ul><li>性能问题</li><li>内存问题（GC压力和内存泄漏）</li><li>第三方引用库问题</li><li>生产中的问题</li><li>网络问题</li></ul><p>高级调试，windbg、clrprofiler、dotTrace、dotMemory、dotnet-dump、lldb</p><h2 id="_1、visual-studio" tabindex="-1"><a class="header-anchor" href="#_1、visual-studio"><span>1、Visual Studio</span></a></h2><p>当涉及调试时，我们的主要工具就是Visual Studio。它是世界上最好的IDE之一，而不仅仅是在<code>.NET</code> 领域。它具有大量功能来帮助你进行调试，包括各种工具窗口，异常选项，工具提示等。根据2019年StackOverflow的调查，微软设法将基本功能和高级功能都整合到一个非常直观的程序中，是Visual Sudio成为所有开发人员第二受欢迎的IDE。 近年来，出现了两个竞争对手来挑战<code>.NET IDE</code> 领域：Rider和Visual Studio Code。根据我的经验，两者的调试功能仍然远远落后于Visual Studio。尽管Rider的重构功能和性能令人印象深刻。 除了交互式（传统）调试，VS还包括许多其他分析工具：</p><ul><li>性能分析</li><li>内存分析</li><li>使用IntelliTrace进行历史调试</li><li>云调试（作为云探索的一部分）</li></ul><p>对于上述所有类别，我更喜欢使用其他工具。继续进行阅读，它们都在本次清单中。</p><h2 id="_2、dnspy" tabindex="-1"><a class="header-anchor" href="#_2、dnspy"><span>2、dnSpy</span></a></h2><p>dnSpy 是用于 .NET 调试的最有用的工具之一。它是一个很好的反编译器。但是它的主要用途是作为调试器。dnSpy允许你调试任何 .NET程序你，而无需考虑符号或者源代码。 该工具的外观和感觉类似于Visual Studio。当你开始调试没有符号或者源代码的.NET进程时，dnSpy将向你显示反编译的代码。现在，这里有个魔术：你可以在反编译的代码本上中放置断点。遇到这些断点时，你将看到局部变量，线程，调用堆栈，并具有完整的调试经验。这使dnSpy成为调试第三方代码和调试生产环境的首选工具。 它轻巧，无需安装。只需将文件夹复制到任何生产机器上，然后开始调试。 <img src="'+d+'" alt="" loading="lazy"></p><blockquote><p>这个工具有个小窍门。如果你使用dnSpy启动进程，那么一切将正常运行。但是，如果你附加到正在运行的进程时，则已加载的模块将保持优化状态。也就是说它们是在 <code>Release</code>模式下构建的。优化代码后，将不会遇到某些断点，也不会显示某些局部变量。这几乎破坏了调试体验。解决方案是使用dsSpy启动进程，而不是附加到进程中。</p></blockquote><h2 id="_3、dotpeek" tabindex="-1"><a class="header-anchor" href="#_3、dotpeek"><span>3、dotPeek</span></a></h2><p>dotPeek是JetBrains的免费.NET反编译器。它们的许多工具实际上进入了该列表。与两个反编译器（如ILSpy或JustDecompile）相比，我更喜欢dotPeek，这有两个原因：</p><ol><li>dotPeek提供了更好的用户体验。或至少我感到自在。它看起来和感觉都像Resharper。所以这可能是原因。</li><li>dotPeek可以从任何程序集中创建符号服务区，即使没有符号或源代码也是如此。它像dnSpy一样，它或反编译代码并从中创建符号。借助dotPeek，Visual Studio就像dnSpy一样调试任何第三方代码。要查看准确程度，请参阅我的文章：在Visual Studio中调试没有符号的第三方.NET代码，后续会进行翻译。</li></ol><h2 id="_4、dottrace" tabindex="-1"><a class="header-anchor" href="#_4、dottrace"><span>4、dotTrace</span></a></h2><p>dotTrace是JetBrains的另一个出色工具。这是我最喜欢的性能分析工具。dotTrance允许你“记录”应用程序的运行，然后分析记录的性能。你将能够看到每种调用方法花费了多长时间，数据库调用，HTTP请求以及垃圾回收期间花费的时间等等。 <img src="'+c+'" alt="" loading="lazy"> 上图显示了对Visual Studio的简短记录分析。你可以看到 <code>ShowWindow</code>花费了155毫秒，其中包括 <code>HwndSourceHook</code>（42ms）， <code>Convert</code>（16ms）等方法用时。此方法的执行包括42%的WPF调用，20%的用户代码，12%的GC等待，10%的 <code>Collections</code>代码，10%的反射和5%的系统代码。太好了吧？ 首先，这是一个学习曲线，但是一旦习惯了，它会变得非常直观。</p><h2 id="_5、scitech-s-net-memory-profiler" tabindex="-1"><a class="header-anchor" href="#_5、scitech-s-net-memory-profiler"><span>5、SciTech&#39;s .NET Memory Profiler</span></a></h2><p>内存分析器是解决内存问题必不可少的另一类工具。这些可能是由于GC（GC压力）引起的内存泄露或性能影响。如果你有足够大的应用程序，那么迟早会遇到内存问题。我希望为你以后着想，因为这些类型的问题可能是毁灭性的。 内存探查器可以拍摄“内存快照”，并让你对器进行调查。你将看到哪些对象占用最多的内存，谁引用了它们，以及为什么未进行垃圾回收。通过比较两个快照，可以发现内存泄露。 有几种可用的内存分析器，但是SciTech&#39;s .NET Memory Profiler是我的最爱。我发现它是功能最强大的产品，问题最少。</p><h2 id="_6、ozcode" tabindex="-1"><a class="header-anchor" href="#_6、ozcode"><span>6、OzCode</span></a></h2><p>OzCode是独特的Visual Studio扩展。其唯一目的是帮助你在Visual Studio中进行交互式调试。OzCode具有很多功能，可以分为4部分：</p>',20),z=e("li",null,[e("p",null,[o("上方显示 - OzCode在调试期间添加了一些有用的可视化功能。这包括红色/绿色突出显示并显示对象的选定属性： "),e("img",{src:p,alt:"",loading:"lazy"}),o(" 还有其他内容，例如将表达式分解成各个部分: "),e("img",{src:m,alt:"",loading:"lazy"})])],-1),S=e("img",{src:h,alt:"",loading:"lazy"},null,-1),P={href:"http://mp.weixin.qq.com/s?__biz=MzI2MDQ3NDkxMA==&mid=2247483934&idx=1&sn=137cc6f5f01e30f7c1c227435f3aaccc&chksm=ea68536fdd1fda79d27d5a1ac750493c908f56264e786b49c833c8e0b818c290e9324fe18842&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"},w=e("li",null,[e("p",null,"数据提示 - 数据提示是将鼠标悬停在Visual Studio中的变量上时看到的弹出窗口。OzCode用自己的更好的数据提示替换了该窗口。它允许“收藏夹”属性，搜索，导出为JSON和其他功能。")],-1),N=e("li",null,[e("p",null,[o("时间穿梭 - OzCode 4 添加了新的革命性调试功能。它可以预测未来而无需移动断点。也就是说，你将能够看到当前调试位置之后发生的代码行中发生的情况。不过，此功能并非在所有情况下都有效。例如，OzCode无法预测HTTP请求结果或SQL请求之类的事情，因为它必须为此执行它们。 "),e("img",{src:g,alt:"",loading:"lazy"})])],-1),x=t('<h2 id="_7、sysinternals-suite" tabindex="-1"><a class="header-anchor" href="#_7、sysinternals-suite"><span>7、SysInternals Suite</span></a></h2><p>SysInternals是一套用于对Windows软件进行故障排除和监视的实用程序。它包括一些我们调试所需的最重要的工具。我建议下载整个套件并将其保存在易于命令行键入的位置，例如：<code>C:\\Sysinternals</code>。有很多工具，其中一些比其他工具更有用。让我们列出一些.NET最重要的。</p><h4 id="process-explorer" tabindex="-1"><a class="header-anchor" href="#process-explorer"><span>Process Explorer</span></a></h4><p>Process Explorer就像类固醇上的Windows Task Manager。它具有许多对调试有用的功能，这里是其中的一些：</p><ul><li>查看加载的模块</li><li>查看句柄</li><li>创建Dump</li><li>查看进程树</li><li>查看性能计数器</li></ul><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="process-monitor" tabindex="-1"><a class="header-anchor" href="#process-monitor"><span>Process Monitor</span></a></h4><p>Process Monitor 也称为ProcMon，允许你监视流程活动事件。具体的说，你可以看到注册表事件，文件事件，网络事件，线程活动和性能分析事件。如果你想找出你的过程涉及哪些文件或注册表，那么ProcMon可以为你提供帮助。 <img src="'+b+'" alt="" loading="lazy"></p><h4 id="procdump" tabindex="-1"><a class="header-anchor" href="#procdump"><span>ProcDump</span></a></h4><p>ProcDump是用于保存转储文件的命令行工具。它可以立即或在触发器上生成转储。例如，在崩溃或挂起时创建转储。这是我推荐的用于捕获转储的工具。以下是它的一些功能：</p><ul><li>立即创建转储</li><li>创建具有特定间隔的多个转储（例如3个转储，相隔5秒）</li><li>一旦超过CPU阈值，就创建转储</li><li>如果进程挂起，则创建转储</li><li>崩溃时创建转储</li></ul>',11),E={href:"https://michaelscodingspot.com/how-to-create-use-and-debug-net-application-crash-dumps-in-2019/",target:"_blank",rel:"noopener noreferrer"},V=t('<h2 id="_8、performance-monitor-perfmon" tabindex="-1"><a class="header-anchor" href="#_8、performance-monitor-perfmon"><span>8、Performance Monitor (PerfMon)</span></a></h2><p>Windows中有一种称为“性能计数器”的内置机制。这些计数器可让你根据计算机上发生的事情跟踪大量有用的指标。这些可能是系统范围内的指标，也可能是针对特定过程的指标。以下是一些可以使用性能计数器衡量的事情的示例：</p><ul><li>CPU使用率</li><li>内存使用率</li><li>进程中引发的异常数</li><li>I/O字节的读写</li><li>对你的asp.net应用程序的请求数</li><li>在asp.net应用程序中请求响应时间</li></ul><p>你可能会监视成千上万种不同的计数器，它们会尽可能的具体。例如，如果你想了解进程的内存使用情况，则有以下计数器：私有字节，虚拟字节，工作集，私有工作集，Gen X 集合，GC时间百分比，大对象堆大小 等等。 性能监视器是使你可以直观地看到这些计数器的工具（尽管也有其他工具）。它以在Windows设备预安装上了。要运行它，只需要在开始菜单中键入“Performance Monitor”，或在命令提示符下键入 <code>perfmon</code>。 <img src="'+f+'" alt="" loading="lazy"></p><h2 id="_9、perfview" tabindex="-1"><a class="header-anchor" href="#_9、perfview"><span>9、PerfView</span></a></h2><p>PerfView是一个开源通用分析工具。它可以做很多事情，以下是其中一些：</p><ul><li>性能分析</li><li>内存分析</li><li>分析ETW事件</li><li>从Linux导入性能快照</li><li>有关应用程序行为的各种报告，包括JIT编译时间，垃圾回收时间等</li></ul>',7),C={href:"https://channel9.msdn.com/Series/PerfView-Tutorial",target:"_blank",rel:"noopener noreferrer"},j=e("img",{src:_,alt:"",loading:"lazy"},null,-1),v=t('<h2 id="_10、fiddler" tabindex="-1"><a class="header-anchor" href="#_10、fiddler"><span>10、Fiddler</span></a></h2><p>Fiddler是Progress Telerik的免费工具。这是我最喜欢的网络请求调试工具之一。它被称为HTTP代理服务器，仅此而已。它捕获所有HTTP请求，记录数据，并按其方式发送请求。 <img src="'+k+'" alt="" loading="lazy"> 对于每一个请求，你都可以查看流程，Headers，payload，response，status等所有的内容。 对于调试，Fiddler具有两个有用功能：</p><ul><li>重新请求 - 你可以右键单击任何请求，然后单击“Replay”，这将再次发送完全相同的请求。在调试服务器端问题时非常有用。如果你要重现有问题的请求，Fiddler可以避免在客户端上重新运行方案以再次发送相同请求的麻烦。它还有助于处理难以重现的请求。</li><li>编辑并重新请求 - 除了重新请求外，Fiddler允许我们修改请求。你可以更改标题，正文，甚至URL本身。你可以使用它来查看服务器端如何处理极端情况。或重现特定请求上发生的问题。</li></ul><h2 id="_11、dotmemory-上手容易" tabindex="-1"><a class="header-anchor" href="#_11、dotmemory-上手容易"><span>11、dotMemory(上手容易)</span></a></h2><p>dotMemory 是一个 .NET 的内存分析工具，可以帮助你优化 .NET 应用的内存使用，找出内存泄漏和其他的内存使用问题。</p><h2 id="哪一个没有提到" tabindex="-1"><a class="header-anchor" href="#哪一个没有提到"><span>哪一个没有提到</span></a></h2><p>你可能会想知道我未提及的某些工具，如果你已经做开发很长时间了，你可能会想到WinDbg。如果你不熟悉WinDbg，它是一个命令行调试器，曾经是Windows的主要调试工具。有点像现在的Visual Studio用于.NET。我觉得这在2020年以及以后并不重要。至少不适用于.NET开发。你可以使用Visual Studio进行几乎所有操作，并且它将变得越来越容易和快捷。 WinDbg的某些功能仍然是好的。像它的脚本功能一样，易于远程处理和方便的生产调试。你可以将WinDbg复制到生产计算机上，并快速调查转储文件。它不需要像Visual Studio这样的大型安装。但是我总是发现自己将转储文件复制到我的开发机器上，并使用内存分析器或者Visual Studio打开它们。这样更加有效。因此，我认为WinDbg不再是.NET开发所必需的调试工具。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>我们介绍了一些最佳的调试工具。我认为，了解这些工具对于成为高级开发人员至关重要。其中提到了一些可以用其类别中的类似工具代替。例如，你可以将dotMemory用作内存分析器，Visual Studio的内置分析器甚至PrefView。或者你可以使用RedGate的性能分析器来代替dotTrace。 无论你选择什么，都至少知道一个性能分析器可以帮助你解决本来会遇到的难题。内存分析器、生产调试工具（如dnSpy），反编译器以及其余的工具也是如此。</p><h2 id="参考文档" tabindex="-1"><a class="header-anchor" href="#参考文档"><span>参考文档</span></a></h2>',10),M={href:"https://mp.weixin.qq.com/s/sNJbVNKst0dZVJdnqG_LQg",target:"_blank",rel:"noopener noreferrer"};function I(D,W){const i=l("ExternalLinkIcon");return s(),r("div",null,[T,e("ol",null,[z,e("li",null,[e("p",null,[o("LINQ调试 - LINQ在编写代码时很棒，但是很难调试。OzCode允许在调试过程中以几乎完美的方式研究LINQ表达式。 "),S,o(" 要了解有关使用或不使用OzCode调试LINQ的更多信息，请查看我的文章："),e("a",P,[o("如何在C#中调试LINQ查询"),n(i)]),o("。")])]),w,N]),x,e("p",null,[o("若要查找有关ProcDump和Dump的更多信息，请参阅我的文章：2019年如果创建、使用和调试.NET 应用程序崩溃转储 "),e("a",E,[o("https://michaelscodingspot.com/how-to-create-use-and-debug-net-application-crash-dumps-in-2019/"),n(i)]),o("。")]),V,e("p",null,[o("它的分析是基于Windows事件跟踪（ETW）事件。这是一个内置的日志记录系统，运行速度非常快，Windows的每个部分都可以使用它。一切都将事件记录到ETW，包括内核，Windows操作系统，CLR运行时，IIS，ASP.NET框架，WPF等。 PerfView很容易成为此列表中最复杂的工具。但是它也非常强大。要开始使用PerfView，我建议在第九频道观看Vance Morrison的视频课程系统 "),e("a",C,[o("https://channel9.msdn.com/Series/PerfView-Tutorial"),n(i)]),o("。 "),j]),v,e("p",null,[o("10个用于C＃.NET开发的基本调试工具："),e("a",M,[o("https://mp.weixin.qq.com/s/sNJbVNKst0dZVJdnqG_LQg"),n(i)])])])}const q=a(y,[["render",I],["__file","jibendiaoshigongju.html.vue"]]),G=JSON.parse(`{"path":"/dotnet/debugging/jibendiaoshigongju/jibendiaoshigongju.html","title":"基本调试工具","lang":"zh-CN","frontmatter":{"title":"基本调试工具","lang":"zh-CN","date":"2023-09-20T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["dotNET"],"tag":["无"],"filename":"jibendiaoshigongju","slug":"llgl6g","docsId":"47904330","description":"说明 在调试软件时，工具非常重要。获取正确的工具，然后再调试时提取正确的信息。根据获取的正确的错误信息，可以找到问题的根源所在。找到问题根源所在，你就能够解决该错误了。 你将看到我认为最基本的解决在C## .NET 中错误问题的工具的列表。这些将帮助你找到任何难题的根本原因并加以解决。 除了代码中的常见问题外，一下工具还可以处理各种问题类型，包括： 性...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dotnet/debugging/jibendiaoshigongju/jibendiaoshigongju.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"基本调试工具"}],["meta",{"property":"og:description","content":"说明 在调试软件时，工具非常重要。获取正确的工具，然后再调试时提取正确的信息。根据获取的正确的错误信息，可以找到问题的根源所在。找到问题根源所在，你就能够解决该错误了。 你将看到我认为最基本的解决在C## .NET 中错误问题的工具的列表。这些将帮助你找到任何难题的根本原因并加以解决。 除了代码中的常见问题外，一下工具还可以处理各种问题类型，包括： 性..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://azrng.gitee.io/kbms/kbms/common/1624800292646-5921ead7-6575-4f5a-9faf-8c3554b923e4.jpeg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-10T15:09:39.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-09-20T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-10T15:09:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"基本调试工具\\",\\"image\\":[\\"https://azrng.gitee.io/kbms/kbms/common/1624800292646-5921ead7-6575-4f5a-9faf-8c3554b923e4.jpeg\\",\\"https://azrng.gitee.io/kbms/kbms/common/1624800292508-c697af76-7964-4933-b0dd-7c300f55391e.jpeg\\",\\"https://azrng.gitee.io/kbms/kbms/common/1624800292404-2b3ca874-3019-4fbf-9c7b-46dd879c832a.webp\\",\\"https://azrng.gitee.io/kbms/kbms/common/1624800292374-61fa2c6a-83fd-4195-ad12-1db7152bfdc5.webp\\",\\"https://azrng.gitee.io/kbms/kbms/common/1624800292397-a79bccd3-b8b9-45eb-967f-42c7dde3aaba.webp\\",\\"https://azrng.gitee.io/kbms/kbms/common/1624800292431-6b37f545-9693-48d3-87e8-b1b63cfa5afe.jpeg\\",\\"https://azrng.gitee.io/kbms/kbms/common/1624800292680-e4b2920a-c445-4fa2-afd3-10762f627e52.jpeg\\",\\"https://azrng.gitee.io/kbms/kbms/common/1624800292477-9c463d3b-e331-4ca4-8364-4cbcf6623249.webp\\",\\"https://azrng.gitee.io/kbms/kbms/common/1624800292510-35ccd212-2a9f-41bd-8606-f67d6feead65.webp\\",\\"https://azrng.gitee.io/kbms/kbms/common/1624800292561-218a1833-306e-42e9-8841-7689646a350e.jpeg\\",\\"https://azrng.gitee.io/kbms/kbms/common/1624800292675-4475b95f-4b34-492b-a151-f6f7c3d1ea2e.jpeg\\"],\\"datePublished\\":\\"2023-09-20T00:00:00.000Z\\",\\"dateModified\\":\\"2024-03-10T15:09:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"说明","slug":"说明","link":"#说明","children":[]},{"level":2,"title":"1、Visual Studio","slug":"_1、visual-studio","link":"#_1、visual-studio","children":[]},{"level":2,"title":"2、dnSpy","slug":"_2、dnspy","link":"#_2、dnspy","children":[]},{"level":2,"title":"3、dotPeek","slug":"_3、dotpeek","link":"#_3、dotpeek","children":[]},{"level":2,"title":"4、dotTrace","slug":"_4、dottrace","link":"#_4、dottrace","children":[]},{"level":2,"title":"5、SciTech's .NET Memory Profiler","slug":"_5、scitech-s-net-memory-profiler","link":"#_5、scitech-s-net-memory-profiler","children":[]},{"level":2,"title":"6、OzCode","slug":"_6、ozcode","link":"#_6、ozcode","children":[]},{"level":2,"title":"7、SysInternals Suite","slug":"_7、sysinternals-suite","link":"#_7、sysinternals-suite","children":[{"level":4,"title":"Process Explorer","slug":"process-explorer","link":"#process-explorer","children":[]},{"level":4,"title":"Process Monitor","slug":"process-monitor","link":"#process-monitor","children":[]},{"level":4,"title":"ProcDump","slug":"procdump","link":"#procdump","children":[]}]},{"level":2,"title":"8、Performance Monitor (PerfMon)","slug":"_8、performance-monitor-perfmon","link":"#_8、performance-monitor-perfmon","children":[]},{"level":2,"title":"9、PerfView","slug":"_9、perfview","link":"#_9、perfview","children":[]},{"level":2,"title":"10、Fiddler","slug":"_10、fiddler","link":"#_10、fiddler","children":[]},{"level":2,"title":"11、dotMemory(上手容易)","slug":"_11、dotmemory-上手容易","link":"#_11、dotmemory-上手容易","children":[]},{"level":2,"title":"哪一个没有提到","slug":"哪一个没有提到","link":"#哪一个没有提到","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"参考文档","slug":"参考文档","link":"#参考文档","children":[]}],"git":{"createdTime":1697962303000,"updatedTime":1710083379000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":1},{"name":"zhangyunpeng","email":"zhang.yunpeng@synyi.com","commits":1}]},"readingTime":{"minutes":12.13,"words":3639},"filePathRelative":"dotnet/debugging/jibendiaoshigongju/jibendiaoshigongju.md","localizedDate":"2023年9月20日","excerpt":"<h2>说明</h2>\\n<p>在调试软件时，工具非常重要。获取正确的工具，然后再调试时提取正确的信息。根据获取的正确的错误信息，可以找到问题的根源所在。找到问题根源所在，你就能够解决该错误了。\\n你将看到我认为最基本的解决在C## .NET 中错误问题的工具的列表。这些将帮助你找到任何难题的根本原因并加以解决。\\n除了代码中的常见问题外，一下工具还可以处理各种问题类型，包括：</p>\\n<ul>\\n<li>性能问题</li>\\n<li>内存问题（GC压力和内存泄漏）</li>\\n<li>第三方引用库问题</li>\\n<li>生产中的问题</li>\\n<li>网络问题</li>\\n</ul>\\n<p>高级调试，windbg、clrprofiler、dotTrace、dotMemory、dotnet-dump、lldb</p>","autoDesc":true}`);export{q as comp,G as data};
