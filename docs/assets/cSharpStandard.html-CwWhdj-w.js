import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,o as n,e as a}from"./app-BY9DQv5u.js";const i={},s=a('<h2 id="指导信息" tabindex="-1"><a class="header-anchor" href="#指导信息"><span>指导信息</span></a></h2><p>命名准则：https://learn.microsoft.com/zh-cn/dotnet/standard/design-guidelines/naming-guidelines</p><p>编码风格：https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/coding-style.md</p><p>编码约定：https://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/coding-style/coding-conventions</p><h2 id="正确操作字符串" tabindex="-1"><a class="header-anchor" href="#正确操作字符串"><span>正确操作字符串</span></a></h2><ul><li>拼接字符串一定要考虑使用StringBuilder ,默认长度为16,实际看情况设置。</li><li>StringBuilder本质：是以非托管方式分配内存。</li><li>同时StringFormat方法内部也是使用StringBuilder进行字符串格式化。</li></ul><h2 id="区别对待强制转型与as和is" tabindex="-1"><a class="header-anchor" href="#区别对待强制转型与as和is"><span>区别对待强制转型与as和is</span></a></h2><p>为了编译更强壮的代码，建议更常使用as和is</p><p>什么时候使用as</p><p>如果类型之间都上溯到了某个共同的基类，那么根据此基类进行的转型（即基类转型为子类本身）应该使用as。子类与子类之间的转型，则应该提供转换操作符，以便进行强制转型。</p><p>as操作符永远不会抛出异常，如果类型不匹配（被转换对象的运行时类型既不是所转换的目标类型，也不是其派生类型），或者转型的源对象为null，那么转型之后的值也为null。</p><p>什么时候使用is</p><p>as操作符有一个问题，即它不能操作基元类型。如果涉及基元类型的算法，就需要通过is转型前的类型来进行判断，以避免转型失败。</p><h2 id="区别readonly和const的使用方法" tabindex="-1"><a class="header-anchor" href="#区别readonly和const的使用方法"><span>区别readonly和const的使用方法</span></a></h2><p>使用const的理由只有一个，那就是效率。之所以说const变量的效率高，是因为经过编译器编译后，我们在代码中引用const变量的地方会用const变量所对应的实际值来代替。比如： const=100, const和100被使用的时候是等价，const自带static光圈。</p><p>const和readonly的本质区别如下：</p><ul><li>const是编译期常量，readonly是运行期常量</li><li>const只能修饰基元类型、枚举类型或字符串类型，readonly没有限制。</li></ul><p>注意：在构造方法内，可以多次对readonly赋值。即在初始化的时候。</p><h2 id="将0值作为枚举的默认值" tabindex="-1"><a class="header-anchor" href="#将0值作为枚举的默认值"><span>将0值作为枚举的默认值</span></a></h2><p>允许使用的枚举类型有byte、sbyte、short、ushort、int、uint、long和ulong。应该始终将0值作为枚举类型的默认值。不过，这样做不是因为允许使用的枚举类型在声明时的默认值是0值，而是有工程上的意义。</p><p>既然枚举类型从0开始，这样可以避免一个星期多出来一个0值。</p><h2 id="区别对待-和equals" tabindex="-1"><a class="header-anchor" href="#区别对待-和equals"><span>区别对待==和Equals</span></a></h2><p>无论是操作符“==”还是方法“Equals”，都倾向于表达这样一个原则：</p><ul><li>对于值类型，如果类型的值相等，就应该返回True。</li><li>对于引用类型，如果类型指向同一个对象，则返回True。</li></ul><p>注意</p><ul><li>由于操作符“==”和“Equals”方法从语法实现上来说，都可以被重载为表示“值相等性”和“引用相等性”。所以，为了明确有一种方法肯定比较的是“引用相等性”，FCL中提供了Object.ReferenceEquals方法。该方法比较的是：两个示例是否是同一个示例。</li><li>对于string这样一个特殊的引用类型，微软觉得它的现实意义更接近于值类型，所以，在FCL中，string的比较被重载为针对“类型的值”的比较，而不是针对“引用本身”的比较。</li></ul><h2 id="资料" tabindex="-1"><a class="header-anchor" href="#资料"><span>资料</span></a></h2><p>https://mp.weixin.qq.com/s/SZAkiBbbn8YRvdOkPQ_BcA | C# 规范整理·语言要素</p>',28),o=[s];function l(r,c){return n(),t("div",null,o)}const h=e(i,[["render",l],["__file","cSharpStandard.html.vue"]]),m=JSON.parse('{"path":"/dotnet/csharp/cSharpStandard.html","title":"CSharp规范","lang":"zh-CN","frontmatter":{"title":"CSharp规范","lang":"zh-CN","date":"2023-09-02T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["csharp"],"tag":["规范"],"filename":"cSharpStandard","docsId":"03dbe131-f0f9-47c4-887d-efea272647c2","article":false,"description":"指导信息 命名准则：https://learn.microsoft.com/zh-cn/dotnet/standard/design-guidelines/naming-guidelines 编码风格：https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/coding-st...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dotnet/csharp/cSharpStandard.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"CSharp规范"}],["meta",{"property":"og:description","content":"指导信息 命名准则：https://learn.microsoft.com/zh-cn/dotnet/standard/design-guidelines/naming-guidelines 编码风格：https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/coding-st..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-11-24T01:54:02.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"规范"}],["meta",{"property":"article:published_time","content":"2023-09-02T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-11-24T01:54:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"CSharp规范\\",\\"description\\":\\"指导信息 命名准则：https://learn.microsoft.com/zh-cn/dotnet/standard/design-guidelines/naming-guidelines 编码风格：https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/coding-st...\\"}"]]},"headers":[{"level":2,"title":"指导信息","slug":"指导信息","link":"#指导信息","children":[]},{"level":2,"title":"正确操作字符串","slug":"正确操作字符串","link":"#正确操作字符串","children":[]},{"level":2,"title":"区别对待强制转型与as和is","slug":"区别对待强制转型与as和is","link":"#区别对待强制转型与as和is","children":[]},{"level":2,"title":"区别readonly和const的使用方法","slug":"区别readonly和const的使用方法","link":"#区别readonly和const的使用方法","children":[]},{"level":2,"title":"将0值作为枚举的默认值","slug":"将0值作为枚举的默认值","link":"#将0值作为枚举的默认值","children":[]},{"level":2,"title":"区别对待==和Equals","slug":"区别对待-和equals","link":"#区别对待-和equals","children":[]},{"level":2,"title":"资料","slug":"资料","link":"#资料","children":[]}],"git":{"createdTime":1693671207000,"updatedTime":1700790842000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":2},{"name":"zhangyunpeng","email":"zhang.yunpeng@synyi.com","commits":1}]},"readingTime":{"minutes":2.98,"words":894},"filePathRelative":"dotnet/csharp/cSharpStandard.md","localizedDate":"2023年9月2日","excerpt":"<h2>指导信息</h2>\\n<p>命名准则：https://learn.microsoft.com/zh-cn/dotnet/standard/design-guidelines/naming-guidelines</p>\\n<p>编码风格：https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/coding-style.md</p>\\n<p>编码约定：https://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/coding-style/coding-conventions</p>","autoDesc":true}');export{h as comp,m as data};
